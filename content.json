{"pages":[],"posts":[{"title":"Hello from zhongzilu","permalink":"http://zhongzilu.github.io/2017/02/20/Hello-from-zhongzilu/","text":"Hello from ZhongziluWelcome to BIT100.I’m zilu Zhong,an Android developer.Here is my blog website.I will post some blog articel which include technology,psychology and other notes in some time.In order to facilitating more people,I will sharing something which is be useful to everyone,because i believe that the knowledge more sharing more valuable.Sorry!My English is poor.So,Don’t be care. 欢迎来到我的网站，我是钟子路(zhongzilu)，是一个安卓开发者。这个网站是我的博客网站，我会不定时更新一些博客，博客类型包括技术博客，心理学笔记以及一些随笔，总之，是把我觉得对大家有用的东西分享出来，以便利更多人。我相信，知识越分享越有价值。 作者：zhongziluGitHub： https://github.com/zhongzilu简书: http://www.jianshu.com/users/0551ca89845b/latest_articles安卓社区: http://ask.android-studio.org/?/people/zhongzilu网易云音乐 http://music.163.com/#/user/home?id=28448237微博 http://weibo.com/2719197280/profile?topnav=1&amp;wvr=6&amp;is_all=1"},{"title":"一行代码将RecyclerView的指定位置置顶显示","permalink":"http://zhongzilu.github.io/2017/01/17/一行代码将RecyclerView的指定位置置顶显示/","text":"一行代码将RecyclerView的指定位置置顶显示标签 Android RecyclerView scrollToPosition zhongzilu bit100 如果你有需求是将RecyclerView的指定位置置顶，那么这里有个最简单的方法，一行代码搞定，代码如下 private void scrollToPosition(LayoutManager manager,int index){ manager.scrollToPositionWithOffset(index, (int) manager.computeScrollVectorForPosition(index).y); } 其中manager是给RecyclerView设置的布局管理器，index是指定的位置。是不是很简单？ 查看演示视频请到原文地址观看 点击下载源文件：ScrollToPositionTest.zip 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/一行代码将RecyclerView的指定位置置顶显示/"},{"title":"使用FFmpeg合成延时视频","permalink":"http://zhongzilu.github.io/2017/01/16/使用FFmpeg合成延时视频/","text":"使用FFmpeg合成延时视频 玩过延时摄影的童鞋都知道，所谓的延时摄影就是把很多张连续拍摄的照片合成一个视频文件 要怎么把多张图片合成视频文件呢？ 开源免费的FFmpeg是不二之选 使用方法也很简单，只需要在你存放照片的目录下执行以下命令 # -r 帧率，在这里取每秒 24 帧 # -s 视频分辨率，缩放比例与原照片分辨率比例一致 # -i 照片名字的编码格式，我的照片格式是 DSC*****.jpg 五位数字 # -start_number 照片的起始编号 # 最后输入视频名称，在这里是 video.mp4 $ ffmpeg -r 24 -s 1200x800 -i DSC%05d.jpg -start_number 2931 video.mp4"},{"title":"一道腾讯面试题的思考_到底谁会赢","permalink":"http://zhongzilu.github.io/2017/01/15/一道腾讯面试题的思考-到底谁会赢/","text":"一道腾讯面试题的思考_到底谁会赢 最近看到一道腾讯面试题，觉得很有意思。题干如下： 有甲乙两家伙用一个英语单词玩游戏（无聊的人还是很多的！！！）。两个人轮流进行，每个人每次从中删掉任意一个字母，如果剩余的字母序列是严格单调递增的（按字典序a &lt; b &lt; c &lt;….&lt;z，假设单词字母不区分大小写，也就是说，a与A算相等），则这个人胜利。假设两个人都足够聪明（即如果有赢的方案，都不会选输的方案 ），甲先开始，问他能赢么？ 输入： 一连串英文小写字母，长度任意（当然要在计算机能承受的范围内）,保证最开始的状态不是一个严格单增的序列。 输出：1表示甲可以赢，0表示甲不能赢。 例如: 输入 bad， 则甲可以删掉b或者a,剩余的是ad或者bd，他就赢了，输出1。 又如: 输入 aaa， 则甲只能删掉1个a，乙删掉一个a,剩余1个a，乙获胜，输出0。 下面给出我用Java实现的算法，如果大家有其他的实现方法，欢迎跟帖和探讨。语言不限。 我的基本实现思路将给定的单词分成若干个单调递增的序列。然后按每个序列中包含单词个数多少进行递减排序，也就是说，排在前面的单调递增序列中包含的字母个数最少。然后由甲开始从排在前面的递增序列中选择一个字母。直到该递增序列中的字母全部被选中。然后继续从下一个递增序列选择字母。按着这样的方法做，直到剩下最后一个单调递增序列，随最后选择了倒数第二个单调递增序列中的最后一个字母，谁就赢了。 例如，单词hela，可以分为三个单调递增序列：h、a、el。从甲开始选择。 甲：h 乙：a 由于a是倒数第二个单调递增序列的最后一个字母，所以乙赢了。 对于单词money可以分成三个单调递增序列：mo、n、ey。排序后：n、mo、ey。 甲：n 乙：m 甲：o 所以甲赢。 具体的实现算法如下： public class Test { // 实现算法的方法，in为一个给定的单词 public static int who(String in){ // 基本思路就是找到该单词中所有递增的子序列， // 然后从字符最少的子序列甲乙轮回删除字母， // 直到还剩下最后一个子序列为止 // 谁删除了最后一个字母，谁就赢了！ // in不能为null if(in == null) return 0; // 单词至少需要有一个字母 if(in.length() == 0) return 0; in = in.toLowerCase(); // 都变成小写字母 // 所有递增数列集合 java.util.List&lt;StringBuilder&gt; ascendingList = new java.util.ArrayList&lt;StringBuilder&gt;(); char lastChar = in.charAt(0); // 存储当前递增的字符列表 StringBuilder sb = new StringBuilder(); sb.append(lastChar); for(int i = 1; i &lt; in.length(); i++){ // 当前字符属于当前的递增序列 if(in.charAt(i) &gt; lastChar){ sb.append(in.charAt(i)); } // 当前字符属于下一个递增序列，所以需要存储上一个递增序列 else { ascendingList.add(sb); sb = new StringBuilder(); sb.append(in.charAt(i)); } lastChar = in.charAt(i); } if(sb.length() &gt; 0){ ascendingList.add(sb); } // 下面就开始游戏了 // 从甲开始删字母，从字符最少的递增序列开始删除第一个字母，直到之后只剩下一个递增序列为止，谁删除的最后一个之母，谁就赢了 // 这里本应该判断如果单词本身就是递增序列，那么甲就win了， // 不过既然题目说没有这种情况，所以就注释掉了 /*if(ascendingList.size() == 1){ return 1; }*/ java.util.Collections.sort(ascendingList, new java.util.Comparator&lt;StringBuilder&gt;(){ @Override public int compare(StringBuilder sb1, StringBuilder sb2){ if(sb1.length() &gt; sb2.length()){ return 1; } else if(sb1.length() == sb2.length()){ return 0; } else { return -1; } } }); int win = 0; // 1代表甲赢，0代表乙赢 while(ascendingList.size() &gt; 1){ if(win == 0) win = 1; // 甲开始 else win = 0; // 乙开始 // 删除第一个递增序列的第一个字母，如果该递增序列 ascendingList.get(0).delete(0, 1); if(ascendingList.get(0).length() == 0){ ascendingList.remove(0); } } return win; } public static void main(String[] args){ System.out.println(who(&quot;money&quot;)); } }"},{"title":"经典面试问题：Cookie被禁用了-Session还能用吗","permalink":"http://zhongzilu.github.io/2017/01/14/经典面试问题：Cookie被禁用了-Session还能用吗/","text":"面试经典问题：Cookie被禁用了，Session还能用吗？ 面试的时候经常被问到Cookie禁用了，Session还能用吗？不同的公司给出的答案也有点不同，到底Cookie禁用了，Session还能用吗？ 默认SESSION配置在默认的JSP、PHP配置中，SessionID是需要存储在Cookie中的，默认Cookie名为： PHPSESSIONID JSESSIONID 以下以PHP为例： 1. 你第一次访问网站时， 2. 服务端脚本中开启了Session`session_start();`, 3. 服务器会生成一个不重复的SESSIONID 的文件`session_id();`，比如在`/var/lib/php/session`目录 4. 并将返回(Response)如下的HTTP头 `Set-Cookie:PHPSESSIONID=xxxxxxx` 5. 客户端接收到`Set-Cookie`的头，将`PHPSESSIONID`写入cookie 6. 当你第二次访问页面时，所有Cookie会附带的请求头(Request)发送给服务器端 7. 服务器识别`PHPSESSIONID`这个cookie，然后去session目录查找对应session文件， 8. 找到这个session文件后，检查是否过期，如果没有过期，去读取Session文件中的配置；如果已经过期，清空其中的配置 如果客户端禁用了Cookie，那PHPSESSIONID都无法写入客户端，Session还能用？ 答案显而易见：不能 并且服务端因为没有得到PHPSESSIONID的cookie，会不停的生成session_id文件 取巧传递session_id但是这难不倒服务端程序，聪明的程序员想到，如果一个Cookie都没接收到，基本上可以预判客户端禁用了Cookie，那将session_id附带在每个网址后面(包括POST)，比如： GET http://www.xx.com/index.php?session_id=xxxxx POST http://www.xx.com/post.php?session_id=xxxxx 然后在每个页面的开头使用session_id($_GET[&#39;session_id&#39;])，来强制指定当前session_id 这样，答案就变成了：能 聪明的你肯定想到，那将这个网站发送给别人，那么他将会以你的身份登录并做所有的事情（目前很多订阅公众号就将openid附带在网址后面，这是同样的漏洞）。 其实不仅仅如此，cookie也可以被盗用，比如XSS注入，通过XSS漏洞获取大量的Cookie，也就是控制了大量的用户，腾讯有专门的XSS漏洞扫描机制，因为大量的QQ盗用，发广告就是因为XSS漏洞 所以Laravel等框架中，内部实现了Session的所有逻辑，并将PHPSESSIONID设置为httponly并加密，这样，前端JS就无法读取和修改这些敏感信息，降低了被盗用的风险。 Cookie在现代禁用Cookie是 IE6 那个年代的事情，现在的网站都非常的依赖Cookie，禁用Cookie会造成大量的麻烦。 在Flash还流行的年代，Flash在提交数据会经常出现用户无法找到的情况，其实是因为Flash在IE下是独立的程序，无法得到IE下的Cookie。 所以在Flash的flash_var中，一般都会指定当前的session_id，让Flash提交数据的时候，将这个session_id附带着提交过去 Chrome中使用 Flash沙箱 已经解决了cookie的问题，但是为了兼容IE，比如swfupload等flash程序都要求开发者附带一个session_id 面试者的用意面试者出此题也是为了考察你对HTTP协议和服务器会话的理解。"},{"title":"Android监听SearchView的展开和关闭事件","permalink":"http://zhongzilu.github.io/2016/12/15/Android监听SearchView的展开和关闭事件/","text":"Android监听SearchView的展开和关闭事件@(标签)[Android，SearchView，监听器，zhongzilu，bit100] 最近在做搜索功能，虽然Github上有很多搜索控件的“轮子”，但我想要简单一点，于是使用了Android的SearchView。 一般在搜索完毕之后，关闭搜索框就应该恢复搜索前的数据，于是想监听SearchView的关闭事件，在关闭的时候进行恢复之前的显示内容。 首先发现有个setOnCloseListener，认为就是它了，结果搞了半天没有反应，然后就去查找原因 1 源码里面，实现setOnCloseListener里的close()法，有一个是清空输入框，也许会和SearchView的setOnQueryTextListener接口onQueryTextSubmit(String query)冲突 2 setOnCloseListener只能在3.2下才能有效，而原生的SeachView 是 (SearchView) menuItem.getActionView(); 那就从menuItem入手，发现了一个设置监听的方法setOnActionExpandListener() 设置监听如下： if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) { menuItem.setOnActionExpandListener( new MenuItem.OnActionExpandListener() { @Override public boolean onMenuItemActionExpand(MenuItem item) { //TODO 展开事件 return true; } @Override public boolean onMenuItemActionCollapse(MenuItem item) { //TODO 关闭事件 return true; } }); } else { mSearchView.setOnCloseListener( new SearchView.OnCloseListener() { @Override public boolean onClose() { //TODO 关闭事件 return false; } }); } 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/Android监听SearchView的展开和关闭事件/"},{"title":"SwipeRefreshLayout进入页面自动刷新","permalink":"http://zhongzilu.github.io/2016/12/14/SwipeRefreshLayout进入页面自动刷新/","text":"SwipeRefreshLayout进入页面自动刷新@(标签)[SwipeRefreshLayout，下拉刷新，Android，zhongzilu，bit100] 通常在使用SwipeRefreshLayout控件的时候，是要通过下拉动作才能显示刷新动画和触发监听器SwipeRefreshLayout.OnRefreshListener的onRefresh方法。 要想一进Activity或Fragment就显示下拉刷新动画，直接调用mRefresh.setRefreshing(true)是不会有刷新动画的。 可以使用以下方法 mRefresh.post(new Runable() { @Override public void run(){ mRefresh.setRefreshing(true); } }); 要关闭刷新 mRefresh.setRefreshing(false); 不过，上面的方法是不会调用刷新监听器的onRefresh()方法的 要想一进入Activity或Fragment就显示刷新动画，并且调用刷新监听器的话，需要手动调用 OnRefreshListener listener = new OnRefreshListener(){ public void onRefresh(){ //TODO } }; SwipeRefreshLayout mRefresh = (SwipeRefreshLayout) findviewbyId(R.id.refresh); mRefresh.setOnRefreshListener(listener); 在onCreate中: mRefresh.post(new Runable(){ @Override public void run() { mRefresh.setRefreshing(true); } }); listener.onRefresh() 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/SwipeRefreshLayout进入页面自动刷新/"},{"title":"如何在Windows或Linux-Ubuntu下开启和关闭PHP的错误显示功能","permalink":"http://zhongzilu.github.io/2016/12/13/如何在Windows或Linux-Ubuntu下开启和关闭PHP的错误显示功能/","text":"如何在Windows或Linux(Ubuntu)下开启和关闭PHP的错误显示功能@(标签)[Windows，Linux，Ubuntu，PHP，zhongzilu，bit100] 写过PHP程序的人都知道，要想知道自己写的PHP代码有没有问题，只有运行的时候才知道，这对于编写代码阶段很是繁琐，而且很多时候在自己的测试环境下没问题，放到真实环境的时候就出问题了，特别是有了一定用户之后，突然某天出问题了，用户看到的就是一个错误显示页面，这样的用户体验很不好。 要想解决这样的问题，最好的方式就是打开PHP的错误和警告提示。 警告!!：最好是在开发阶段和测试环境下启用，在正式环境下关闭或者将错误记录到日志 如何在Windows环境下开起PHP的错误显示？如果你是Windows平台，你只需要找到php.ini这个文件，通常这个文件就在你安装的Apache服务器的根目录下，如果你使用的是其他服务器，你可能需要搜索该文件 1.打开php.ini，利用查找功能找到以下代码 display_errors = Off 2.将它替换成 display_errors = On 保存文件之后，重启你的Apache服务器或其他的服务器，这就完了。 ####如何在Linux(Ubuntu)环境下开起PHP的错误显示？如果你是Ubuntu或Linux用户，同样是找到php.ini文件，通常会在/etc/目录下，然后就是查找和替换，方法和在Windows下一样 最后通过命令重启服务器，比如Apache服务器： sudo service apache2 restart 如果是nginx服务器 sudo service nginx restart 这就完了！如果你依然没能解决问题，请移步到这篇文章 开启PHP错误提示 — BIT100 我是Zhongzilu，Thanks for watching!"},{"title":"开启PHP错误提示","permalink":"http://zhongzilu.github.io/2016/12/13/开启PHP错误提示/","text":"开启PHP错误提示@(标签)[PHP，错误提示，zhongzilu，bit100] 想要在代码中显示PHP的错误提示吗？这篇文章应该对你有帮助 想要开启错误报告和警告功能，只需要在PHP标签中加上以下代码： error_reporting(E_ALL^E_NOTICE); ini_set(&#39;display_errors&#39;, &#39;On&#39;); 以上代码只是显示错误和警告，并没有建议提示，要显示所有的错误，只需要去掉E_NOTICE error_reporting(E_ALL); ini_set(&#39;display_errors&#39;,&#39;On&#39;); 如果你仍然不能显示PHP的错误提示，请移步到下面这篇文章 如何在Windows或Linux(Ubuntu)下开启和关闭PHP的错误显示功能"},{"title":"CentOS升级php5.3到5.5","permalink":"http://zhongzilu.github.io/2016/12/09/CentOS升级php5-3到5-5/","text":"CentOS升级php5.3到5.5@(标签)[Linux，CentOS，PHP，5.3，5.5，zhongzilu，bit100] 比特壹佰（www.bit100.com）使用的是Wordpress博客平台搭建。最近在后台升级了一下SEO插件，结果不能用了，提示我的PHP版本过低，要求是PHP版本必须为5.4以上，于是我就开始升级PHP的操作了。 由于yum仓库中的PHP版本最新为5.3.3，所以需要使用其他的源 安装Webtatic EL6 YUM源 rpm -Uvh http://repo.webtatic.com/yum/el6/latest.rpm 在安装新版本PHP前，需要先移除原来的PHP(在移除前，请确保你知道你对PHP做过哪些特殊配置，最好先备份一下配置文件) yum remove php* 然后安装PHP5.5版本，输入命令 yum install php55w 安装好后可以查看一下版本 php -v 然后安装常用的工具 yum install php55w-pear php55w-odbc php55w-pdo php55w-gd php55w-mysql 查看自己安装了哪些PHP相关的包 rpm -qa |grep php* 到这里PHP就已经升级完了，现在最新PHP版本是PHP7，升级PHP7得小心，可能会遇到很多坑，别问我为什么。Thanks for watching。 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/CentOS升级php5.3到5.5/"},{"title":"如何更改linux超级用户密码","permalink":"http://zhongzilu.github.io/2016/12/09/如何更改linux超级用户密码/","text":"如何更改Linux超级用户密码标签 Linux 超级用户 root zhongzilu bit100 要更改Linux超级用户的密码很简单，不过这样做很危险，建议修改为较为复杂的密码或者使用su root命令来使普通用户临时拥有超级用户的权限 直接在命令行里输入 sudo passwd 然后输入你的登陆密码，之后会提示输入新的UNIX密码，你就输入你想要修改的超级用户密码 之后提示重新输入新的UNIX密码，你再重复输入刚才输入的UNIX密码 之后会提示确认UNIX密码，你再重复一遍就可以了。 例如： zhongzilu@Ubuntu:~$ sudo passwd [sudo] password for zhongzilu: 输入新的UNIX密码： 重新输入新的UNIX密码： 确认输入新的UNIX密码： passwd:已成功更新密码. zhongzilu@Ubuntu:~$ 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/如何更改Linux超级用户密码/"},{"title":"如何在Linux-Ubuntu上安装PHP-MySQL-Apache-LAMP","permalink":"http://zhongzilu.github.io/2016/12/09/如何在Linux-Ubuntu上安装PHP-MySQL-Apache-LAMP/","text":"如何在Linux/Ubuntu上安装PHP，MySQL和Apache（LAMP）标签 Linux Ubuntu PHP MySQL Apache zhongzilu bit100 如果你是Linux新手，想在Linux上安装PHP、MySQL、Apache，最简单的方法就是通过命令行安装，命令如下： 1.安装Apachesudo apt-get install apache2 启动Apachesudo /etc/init.d/apache2 start 停止Apachesudo /etc/init.d/apache2 stop 重启Apachesudo /etc/init.d/apache2 restart 2.安装PHP5sudo apt-get install php5 libapache2-mod-php5 3.安装MySQL服务端sudo apt-get install mysql-server 4.检查以上都安装完后，重启Apache服务器 sudo /etc/init.d/apache2 restart 然后打开浏览器，在地址栏输入：http://localhost，之后你应该会看到It works的字样，这就表示Apache服务器没问题 现在来检查PHP，默认情况下在命令行中输入 cd /var/www 然后将index.html文件更改为index.php mv index.html index.php (注意中间的空格) 然后编辑index.php文件，输入如下代码：(编辑的方法有多种，vi/vim/gedit等命令都可以,请自行搜索) &lt;?php echo &quot;Hello Word!&quot;; ?&gt; 最后再打开浏览器，在地址栏输入：http://localhost，之后如果看到Hello Word!字样就表示PHP安装成功了。 是不是很简单，开始你的项目吧！ 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/如何在Linux/Ubuntu上安装PHP,MySQL和Apache(LAMP)"},{"title":"如何在Linux-Ubuntu上运行.chm文件","permalink":"http://zhongzilu.github.io/2016/12/09/如何在Linux-Ubuntu上运行-chm文件/","text":"如何在Linux/Ubuntu上运行.chm文件标签 Linux Ubuntu .chm zhongzilu bit100 如果你想要在Linux或Ubuntu系统上运行.chm格式的文档文件，你可算来对地方了。很简单，你可以直接在Ubuntu的软件中心里搜索xCHM，然后安装。或者你也可以使用命令行的方式： sudo apt-get install xchm 现在你就可以打开.chm格式的文档文件了。另外，还有其他的软件也可以，比如：ChmSee、GnoCHM、CHMViewer等，安装方法都是差不多了，你现在就可以去试试了。 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/如何在Linux/Ubuntu上运行chm文件/"},{"title":"1024程序员节-向改变世界的程序员致敬","permalink":"http://zhongzilu.github.io/2016/10/24/1024程序员节-向改变世界的程序员致敬/","text":"1024程序员节，向改变世界的程序员致敬标签 1024 程序员节 程序猿 2016-10-24 zhongzilu 钟子路 写在前面正值1024程序员节日来临之际，今天心血来潮，想写篇文章来为我们这些猿猿致敬，也算了却一个心愿，让我们这些猿猿们以自己从事的职业为豪为荣。 可能我们的着装遭人吐槽，可能我们的玩笑经常别人听不出笑点，可能我们心照不宣的执着外人觉得莫名其妙，可能我们的举止身边的人觉得实在无趣，也可能我们在如今互联网火热的时候略带优越感的表象让人们越来越觉得我们是异类生物。。。 但即使是这样，我希望你们对我们猿猿的态度是：“即使你不了解我们在做什么，但你们还是爱我们”。出于这种情结，我是程序员，我要为自己和猿猿们带盐！ 1.我们的着装我们最常被吐槽的就是我们的穿着了，套头衫＋牛仔裤，最后再来个夹角拖鞋就齐活了。这是我们特立独行的标配，如果没有特别要求，请允许我们这样穿着，我们觉得会休闲自在，工作也会更有激情。 一个牛逼的程序员是根本没有时间打理自己外貌的。发型就要像爱因斯坦一样，顶着一脑袋鸡窝，凌乱蓬松美，给人随时能从头发里掏出一个鸡蛋的感觉。胡子一大把，彰显自信又从容，不近视则以，近视就要戴酒瓶底子那么厚的大眼镜，一种科研工作者的风格。 2.我们善于学习我们总是喜欢学习、尝试新事物，我们求知的欲望是相当强的。在互联网这个行业，技术的更新迭代速度很快，唯有不断学习和尝试，我们才能立于不败之地，人都是做自己原本不能胜任的事情中，才能快速成长。所以，不要让任何事情成为你不去学习的理由！，你学过的每一样东西，都会在你一生的某个时候派上用场的。 3.我们善于解决问题我们每天打交道最多的就是bug了，bug虐我千百遍，我待bug如初恋。也许是解决问题后的满足感，正是因为这样，我们解决问题的能力超乎你想象。 4.我们很单纯我们是一群单纯而又善良的猿。我们“只对技术不对人”，而且反驳对方观点，都是比较幽默的，不会“出口成脏”的。我们会不厌其烦地为客户改需求，改bug，相对于其他行业，我们少了勾心斗角，多了真诚，领导什么的也比较随和，工作氛围也比较自由。 5.我们喜欢聆听我们的大脑常常高速运转，这是好事也是坏事。好的一面是，我们可以听你讲你的问题好几个小时，坏的一面是我们常常走神，因为我们在想如何解决你的问题。但是起码，我们是喜欢聆听的。 6.我们很有创造力我们是一群富有创造力的猿，爱编程，爱晚起，偶尔也忙到深夜喜欢学习，努力工作，享受生活酷爱技术，创造出了一个又一个奇迹。大家玩地不亦乐乎的lol，改变世界交流方式的Facebook，亦或是让你足不出户就可以订餐或淘宝的软件都是出于我们的创造力，总之，我们为世界创造的价值。(猿们，感觉我越写越傲娇了) 7.我们善于分享 编程夜当午，手握小滑鼠。谁知编程辛，行行皆“心”苦；头昏不觉晓，使劲揉眼角。夜夜太辛苦，睡眠知多少； 即使这样，我们还是乐此不疲地分享我们幸幸苦苦研究的成果，各种开源社区，博客都成为我们的常驻地。技术源于分享，当然，我们也会分享生活趣事，正是因为我们的无私，社会才会进步的更快。所以，建议大家开通博客之类的写点什么吧，好记性不如烂笔头，一来可以督促自己，二来锻炼自己表达能力，三来分享给别人。 8.我们很细心编译，调试，再编译，再调试，功能跑通，SVN提交代码（地震火灾，世界末日，也一定要先提交代码再行离开），绝对不能让程序出乱子，没错，我们是一群细心的猿。 9.和我们约会的好处 优点1：我们不会骗人；没有时间去拈花惹草，当然陪你的时间会相对少点。优点2：我们很聪明，超级聪明。优点3：惹你生气还请包容。优点4：我们不会 bug 你，我们只会用一整天的时间debug代码。优点5：我们会多门语言，是不是很好厉害！优点6：当我们邀请你把玩我们的“小玩意”……你可别想歪，我就是想让你玩我儿时的小玩具，我们是一群可爱 又单纯的程序员。优点7：拥有自己的活动空间，只要给我一台电脑，我从不干涉你的生活。优点8 ：…… 10.活捉程序员的技巧 取萌妹纸饵料一只，放于程序猿经常出没的场所，待引起其注意后，掉头就跑，单纯的程序猿会紧跟着跑来，偶尔回头注意其动向，伺机将其捕获。如遇到挣扎可用亲吻麻痹之。 程序猿日常饲养比较简单，要求猿舍温暖，通风干爽，对猿舍网络状况要求较高。每日以适量萌饲喂之，注意取得程序猿的信任，培养感情，每周可适当带出门散步，程序猿对运动没有特殊要求。 不过需要特别注意的是,一次只能饲养一只程序猿,不要与其他萌妹纸一同饲养 11.值此1024程序员节，我们的愿望作为一枚用代码改变世界，用智慧颠覆未来的程序员，居然还要加班加点透支生命？NO！我们应该给自己更多的关怀 ，1024这一天，我们应当放假或者拒绝强制 无效率 加班！ 勇敢对一切和加班有关的要求说NO!拥抱女友尽情在游戏的世界里徜徉！早点休息，今天不加班！不晚睡！不熬夜！…… 特别提醒：猿猿们切记不要加班 12.附上程序员装逼指南 一.准备工作“工欲善其事必先利其器。” 1.电脑不一定要配置高，但是双屏是必须的，越大越好，能一个横屏一个竖屏更好。一个用来查资料，一个用来写代码。总之要显得信息量很大，效率很高。 2.椅子不一定要舒服，但是一定要可以半躺着。 3.大量的便签，各种的颜色的，用来记录每天要完成的事务，多多益善。沿着电脑屏幕的边框，尽量贴满，显出有很多事情的样子。 4.工具书，orelly的，机械工业，电子工业什么的都可以，能英文就英文，不行影印版的也可以，反正越厚越好，而且千万不要放在书架上，一定要堆在桌上，半打开状。 二.从进门开始 1.着装！着装！不管你是去实验室，或者去公司的大楼，在或者是小公司的民宅，或是自己创业的黑作坊；无论是春夏秋冬白天晚上刮风下雨电闪雷鸣台风 龙卷风，一个装b的程序员都要十分在意自己着装！这里只提出参考建议。初级装：衬衣+牛仔裤+休闲鞋。中级装：T恤+宽松短裤+拖鞋。高级装：背心+宽松 大花裤衩+人字拖。 2.得体的举止。在走廊以及任何形式的过道里，一定要双手插兜，走得像个痞子，至少要看起来有点反社会，如若不行，可走文弱天才型geek路线。。 3.如果有女性在你背后指指点点，小声嘀咕说这一定是一个技术男的时候，应该先低头，然后保持低头状态，缓缓回头，坏坏地蔑笑但是不要出声，然后快步前行。 4.进门后，一定不要跟任何人打招呼，笔直走向自己的位置，最多路过打一杯咖啡，千万不要有多余的动作，显示出自己的专注与心无旁骛。 三.坐下就不要再动了 1.坐下以后，姿势需要略微后仰，能翘着二郎腿最好了，然后在后仰的情况下低着头，以便看到屏幕，然后千万就不要再动了。 2.粗暴地把电脑前的大堆书推开一个口，然后摘下电脑上的一个便签，看一眼，不过3秒，可以开始coding了。 3.能不用IDE就不要用，实在装不了，无论IDE是什么，一定要调成DOS那种黑色背景的。 4.如果写前台界面，就不停地调试后台代码；如果写Java，就在里面混编C；如果写C，就在里面混编汇编。不光要coding，还要时不时的翻出一本什么英文的书翻一翻，看不懂就看看插图，然后扔到面前假装懂了继续coding。 5.什么看起来高端就用什么，不要管实用不实用。例如对C++：switch统统重构成多态；如果有指针，统统改成智能的；C++一定要自己写 template；数字是全部要替换成宏的名字能起多长就起多长；struct就不要出现了，如果出现，也一定要用attriburte修饰一 下；运算都是位操作的；操作符都是重载的；网络都是并发缓冲线程池的；int只用int32_t声明的;继承不用普通的，什么多继承虚继承 啊；helloworld也要写捕获异常的；后人一看代码，中间一堆关键字 extern,asm,auto,XXXXX_cast,volatile,explicit,register,template，让一般总在敲 int,if,else,for的小程序员顿时心生崇拜。 6.注释？算了吧。只有两个路线可以选：一，变量名起得巨长无比，看代码就和读英文文章一样顺畅，根本不需要加注释。 二，代码无比晦涩，加不加注释根本无影响。 7.千万不要用IM工具交流，千万不要问同事问题，显得自己没有水平，都是自己上网或者查书。 8.无论是同事间开玩笑或者发生任何群体性时间，不要抬头，更不要东张西望，即使地震火灾，也一定要先提交代码再行离开。 四.潇洒地离开 1.人走，主机是千万千万不能关的，至少要跑个daily build，实在不行正在svn提交也勉强算过关。 2.书应该已经又堆到屏幕前了，千万不要整理，明天再来推开。 3.不强求最后一个走，但一定要所有的非程序员，什么市场啊前台啊pm啊都走光了，才可以走。 4.走得时候一定要率性，千万不要收拾任何东西，站起来，出门，好的，就这样。 5.如果今天一定要说句话的话，找到那个最苦逼的程序员，跟他说，你进度太慢了啊，不要老让我等你。 写在最后程序员没有沮丧、受伤、挫败感的时候么？有，而且可能今天你还哼着 “倍儿爽”，明天你就突然有 “我想哭但是哭不出来” 的苦闷。所以，需要你们在我们熬夜的时候送来关怀，寂寞的时候送来问候。总之，程序员的日子从没那么精彩，却又精彩处处可见。 参考资料：《程序员装逼指南》文／wblearn（简书作者）原文链接：http://www.jianshu.com/p/292da3de5bcd/comments/5069037#本文链接：http://www.bit100.com/1024程序员节，向改变世界的程序员致敬"},{"title":"(已解决)ViewPager禁止预加载-使用Framgment的setUserVisibleHint导致的问题","permalink":"http://zhongzilu.github.io/2016/09/23/已解决-ViewPager禁止预加载-使用Framgment的setUserVisibleHint导致的问题/","text":"###(已解决)ViewPager禁用预加载，使用Fragment的setUserVisibleHint导致的问题 不久前，写了一篇博客，《ViewPager禁止预加载，滑动到那个页面再加载网络数据》，根据这篇文章的做法，确实可以解决问题，但是当时我忽略了另一种情况，那就是在Activity中重复利用那个Fragment，结果Fragment没有加载数据，显示空白的 这也是我在实际开发中遇到的，因为有个Fragment在ViewPager中显示，在另一个地方需要跳转到一个Activity，Activity显示内容和逻辑和Fragment里的一样，所以为了代码重用，就直接用Activity嵌套Fragment了，结果Activity显示空白，调试发现根本没运行到setUserVisibleHint()，在ViewPager中嵌套Fragment没有遇到这个问题。 于是我在Activity的onResume()中手动调用setUserVisibleHint(true)，结果报空指针，一查才知道，原来setUserVisibleHint()方法要优先于Fragment的onCreateView()，由于Fragment里的必要控件都还没有初始化，所以报空指针了 要解决这个问题，需要用到Fragment的onHiddenChanged()方法， @Override public void onHiddenChanged(boolean hidden) { super.onHiddenChanged(hidden); if (hidden &amp;&amp; isFirst){ //在这里加载数据 isFirst = false; } } 然后在Activity中手动调用onHiddenChanged(true)，这样就能实现和ViewPager + Fragment的方式一样的效果了，在用户看到这个Fragment的时候再加载数据 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/问题ViewPager禁用预加载使用Fragment的setUserVisibleHint导致的问题/"},{"title":"ViewPager禁止预加载-滑动到那个页面再加载网络数据","permalink":"http://zhongzilu.github.io/2016/09/19/ViewPager禁止预加载-滑动到那个页面再加载网络数据/","text":"ViewPager禁止预加载，滑动到那个页面在加载网络数据@(标签)[Android, ViewPager, 预加载, setUserVisibleHint, 2016-09-18, zhongzilu, 钟子路] 用过Android ViewPager的同学都知道，ViewPager预加载是3页，可以取消预加载，但是滑动页面会卡，不推荐。但如果不做限制，这样感觉又比较浪费资源，因为用户很可能只看了第一个，后面两个根本想不想看，结果还是加载了。更糟的是，如果你的Fragment在初始化时需要从网络加载大量的数据，这对资源消耗和用户体验都是不好的。 那么有没有什么办法可以让用户在看到哪个页面的时候再去加载页面数据呢？ 答案当时有的，在使用的ViewPager的时候，通常我是采用的ViewPager + Fragment的方式，这个时候我们可以使用Fragment中的setUserVisibleHint()方法，直接在Fragment中覆写该方法： @Override public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); if (isVisibleToUser){ //在这里加载数据 } } 这样就能在Fragment显示出来的时候再去加载数据了，但是这样有个问题，每次加载Fragment的时候都会去重新加载一次，为了避免这个问题，我们用一个boolean类型的全局变量isFirst来表示只在第一次呈现的时候才加载数据，修改过后的代码如下： private boolean isFirst = true; @Override public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); if (isVisibleToUser &amp;&amp; isFirst){ //在这里加载数据 isFirst = false; } } 这样就能满足使用ViewPager时禁用预加载的要求了！是不是很简单？ 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/viewpager禁止预加载，滑动到那个页面再加载网络数据/"},{"title":"如何看待阿里抢月饼事件","permalink":"http://zhongzilu.github.io/2016/09/13/如何看待阿里抢月饼事件/","text":"如何看待阿里抢月饼事件？@(标签)[阿里巴巴, 月饼, 中秋节, 2016-09-12, zhongzilu, 钟子路] 今天在公司正愉快的敲着代码，突然电脑的右下角企鹅图标开始频繁闪动，我掐指一算，估计有什么大事要发生了（事实证明，这是我瞎编的），点开群消息，就看到一张醒目的图片我不禁被这几行犀利的文字所吸引，看完后顿生感叹：可惜了(liao)。 Life is just like a box of moon cakes. You never know what you’re gonna get.人生就像一盒月饼，你永远不知道下一个是不是五仁馅儿的 原本只是一件小事，被大众这么一传播，就成了大事，我早说过程序猿就是个高危职业。 作为同行，我肯定不能“坐视不管”，于是在某乎上找到一篇贴：如何看待阿里巴巴安全部门的月饼事件？，在看过该篇贴之后，我想在这里仅代表个人意见发表一些看法。 不得不说，阿里这次的决定实在是有点欠妥，这件事原本只是一件小事，或者说是Geek程序猿们开的一次玩笑，像这种事情，大多说公司都是内部警告处分就完事儿了，这样对外界来说，这件事就根本没发生过；对公司来说，也免去了不少的非议，而且最重要的是，那几个因此受到责罚的同事，会从中总结经验教训，并感谢领导们的“不杀之恩”。 从另外一个角度考虑，这几个同事使用技术手段来抢月饼，说明他们还是几个比较有想法的人，至少对自己从事的技术工作抱有好奇心，敢于突破常规，在我看来，只要不犯法，那就不是问题。 但阿里选择了不一样的处理方式，现在很难说这种处理方式是对是错，不过我们可以大胆的猜测一下 猜测： 从发帖内容上看，阿里辞退这几名员工的理由应该是使用了技术手段来达到个人目的，影响了公平性，这种行为是不诚实的行为，和阿里的价值观不符，所以被开除。 我不是阿里人，所以我也不知道阿里的价值观是什么，但在我看过的阿里的相关资料里，我记得阿里在成立初期经历过一次比较严重的问题事件，好像是淘宝上的商户欺诈，用户投诉的事件，阿里当时的做法并非像其他公司一样内部追责，对外咬死不承认，而是开诚布公，向公众说明事实真相，并说明将如何处理该问题。所以我猜测阿里的价值观就是如此，对待事件，开诚布公，说明原由，公开处理方式。 有人说这次的事件是阿里的又一次成功的营销手段，因为阿里用事实证明了：阿里月饼公司专供，好吃到内部抢到开除，我觉得用四个人换阿里月饼畅销还是挺划算得，这个梗我可以玩儿一年。 好像扯远了，回到话题 其实像这次9.12事件，完全有其他的处理方式，比如这几位都说得很有道理，阿里作为一个技术型公司，在面对技术上的问题，应该更加慎重的解决，切不可鲁莽行事，这次的处理方式，还是有草率行事的嫌疑，这让有些人开始怀疑阿里的体制问题了，难道一个企业从小公司到大企业之后，都会变得这么急功近利，冷酷无情了吗？或者说，在天朝内的企业就是这样，我们出不来伟大的公司，因为我们伟大的只是领导和主义？ 最后，我希望阿里能重视这件事情，妥善处理，毕竟有很多的目光在注视着，有看热闹的，有看门道的，也有看笑话的，说不定还有挖墙角的，小心为上！ 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/如何看待阿里抢月饼事件？/"},{"title":"理想三旬","permalink":"http://zhongzilu.github.io/2016/09/12/理想三旬/","text":"理想三旬标签 浓烟下的诗歌电台 理想三旬 陈鸿宇 15平米的出租房，一张床一张桌子，角落装行李的箱子似乎原封不动堆在那里，还是几个月之前的样子，那副裱起来的肖像画似乎特别显眼。 窗外风雨交加，手机今天早上跳出来的新闻说超级台风了，这个房子老旧的似乎摇摇晃晃马上要被吹坏一样。 房东是个独居老太太，衣着干净整洁，讲一口细软的南方普通话，消瘦很精明或者是说有些刻薄和吝啬。 守了6年的唱片公司最终还是入不敷出，他是这家公司的最后一个歌手，吃散伙饭的时候快四十的男人痛声大哭，他看着老板一句话也说不出来。 他几年前卖了攒钱买下的房子，坐上火车南下回到家乡，盘了一家餐厅，亲自装修，亲自三顾茅庐找厨师，亲自去买材料，甚至在后厨刷碗，但是剩下的钱也只够租下这个小屋子。 “我真的不喜欢你们这些说搞音乐的人，真的是不想租的啦，晚上八点以后不要让我听见唱歌啊，弹琴的声音，还有宠物也不要养。” “知道了。” 他打开小冰箱，里面除了啤酒什么都没有，床头柜上有一包昨天吃剩的饼干，把剩下的塞到嘴里，只觉得浑身酸痛。 一个人干几个人的活，员工虽然有休息日，但是自己却只能够在这样自然灾害的天里面休息。 望了一眼墙角的吉他，琴箱上积了一层灰，他伸手拿够到它，然后用布把那些灰擦掉，然后想了想最终还是打开。 他今年三十岁了，古人说三十而立，这个年纪谈梦想似乎让人觉得可笑。这也是他不回家的原因，不过父母知道他开餐厅时候还是挺开心的，这是他姐姐和他说的。 学生时代一起做乐队的朋友大多都已经放弃了，极少数坚持下来的生活似乎也不怎么光鲜，至于之前工作认识的朋友似乎也因为某些原因疏远。他还比较幸运，他们说，至少曾经被人看见过，他觉得也是。看见他们因为业绩和上司闷闷不乐，他觉得自己虽然显得幼稚，但是却还是比较快乐。 音乐从指缝中流出，寂寞而美好，他也不知道怎么就弹出这首曲子。 因为这首歌他被老板看上，出了第一张也是唯一的一张唱片，红极一时，那时候走到街上似乎都是这首歌。 但是这首歌是他写给她女朋友的，那时候他们那么相爱，似乎永远都不会分开。在那个他们一起上学的北方城市，她最终嫁给了一个很平凡但是对她很好很踏实的男人，听说已经有了一个孩子。人有时候真的很善变，也很无情。喜欢的时候那么喜欢，不过忘记也似乎就只要一瞬间。 她给他画的画他还留着，二十多岁的样子和三十多岁的样子真的很不一样。这首歌现在唱和当初在舞台上唱的，似乎也不太一样。如果没有得到过，那么便不会觉得悲伤。 他突然很想抽烟，但是他已经戒烟很久了。他抱着吉他，窗外风雨更急了，路上看不见人影，满屋子的风雨呼啸声。 “笃笃笃。”突然听见敲门声。 他觉得奇怪，开门房东站在门口，手里拿着个饭桶。 “这么大的后生还怕台风啊，哭什么。” 他才发现自己竟然在留眼泪，连忙擦掉:“您怎么来了？有什么事情吗？” “平时看你都是订外卖吃的，台风天人家外卖都不送了，刚好饭做多了给你一点。”房东把饭桶塞到他手里，“和我儿子一个样子，吃外卖还有方便面身体才不好，每天半夜咳嗽我觉都睡不着了。吃完放在我门口就好了。” 他有些懵，只是点了点头。 “真的是和我儿子一个样子，谢谢也不知道说的啊？”她有些生气的样子。 他又慌忙说了一句谢谢。 “嗯。”她点了点头，“不过你弹琴还是蛮好听的，唱歌也比他好，我还是蛮喜欢的。虽然是年轻人的歌，好听的话也可以适当多唱唱。” 作者：王木木原文地址: http://gushi.li/42"},{"title":"(已解决)程序调用魅族系统裁剪之后直接闪退","permalink":"http://zhongzilu.github.io/2016/09/02/已解决-程序调用魅族系统裁剪之后直接闪退/","text":"（已解决）程序调用魅族系统裁剪之后直接闪退 说明几天前发布了一篇博客，是关于程序调用魅族系统裁剪之后直接闪退的问题，在网上找了很久之后也没有找到解决方法，于是决定去请教魅族官方的开发者，我先是在魅族社区里发帖提问，然后有幸在朋友的帮助下得到了魅族运营的联系方式，请求他帮忙联系一下魅族开发者，果然，在一周之后我得到了魅族开发者的回复，我在这里为魅族开发者点赞，感谢他们对待问题的态度，同时也为魅族客服点赞，感谢他们对用户提出的问题进行认真的回复。 好了，废话不多说，今天主要讲讲对于这个问题的解决方案。 魅族官方社区的回复截图根据回复，我们可以得知，魅族在系统层就处理了 我们经常遇到的 因裁剪图片过大可能会导致内存溢出的问题，这一点还是挺人性化的，再次为魅族系统开发者点赞。 回复中共提供了三种解决方案，通过对比，我们把这三种方案进行结合。 解决方案代码如下： /** * 对选择的图片进行裁剪 * @param uri 图片uri * @param outputX 输出图片宽度 * @param outputY 输出图片高度 * @param requestCode 请求码 */ public void cropImage(Uri uri, int outputX, int outputY, int requestCode) { Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.setDataAndType(uri, &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); intent.putExtra(&quot;aspectX&quot;, 1); intent.putExtra(&quot;aspectY&quot;, 1); intent.putExtra(&quot;outputX&quot;, outputX); intent.putExtra(&quot;outputY&quot;, outputY); intent.putExtra(&quot;noFaceDetection&quot;, true); intent.putExtra(&quot;return-data&quot;, true); //这里增加第三种方案的代码 intent.putExtra(&quot;return-path-if-too-large&quot;, true); intent.putExtra(&quot;scale&quot;, true); //这里生成裁剪过后的图片的保存路径 File file = new File( getApplicationContext().getExternalCacheDir(), UUID.randomUUID().toString()); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file)); intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString()); //输入文件格式 startActivityForResult(intent, requestCode); //把自定义的保存路径保存到全局变量中，方便其他地方调用 this.mCropImageUri = Uri.fromFile(file); } 覆写的onActivityResult代码如下： @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { switch (requestCode) { //裁剪图片之后的处理 case REQUEST_CROP_CODE: if (resultCode == RESULT_OK &amp;&amp; data != null){ Uri uri = data.getData(); if (uri != null) { this.mImageRealPath = uri.getPath(); LogUtil.d(&quot;ImageRealPath==&gt;&quot;, mImageRealPath); //更换视频封面 img_video_mask.setImageURI(uri); } else { //在其他机型上裁剪过后的图片uri会包含在data中， //通过data.getData()可以获取到裁剪过后的图片uri //但在魅族机型上，data.getData获取的uri为null //因此需要使用我们在调用裁剪时生成的保存路径 this.mImageRealPath = mCropImageUri.getPath(); LogUtil.d(TAG, &quot;onActivityResult: ImageRealPath==&gt;&quot; + mImageRealPath); img_video_mask.setImageURI(mCropImageUri); } } break; super.onActivityResult(requestCode, resultCode, data); } 作者：zhongzilu原文地址: http://www.bit100.com/（已解决）程序调用魅族系统裁剪之后直接闪退/"},{"title":"程序调用魅族系统j裁剪之后直接闪退","permalink":"http://zhongzilu.github.io/2016/08/30/程序调用魅族系统j裁剪之后直接闪退/","text":"程序调用系统裁剪之后直接闪退说明我原本是想实现更换头像的功能，程序调用系统相册选取图片，选取图片后直接进行裁剪，我在Activity里覆写了onActivityResult方法，然后在该方法里获取返回的图片数据，结果要么是根本没执行到onActivityResult方法里，要么是获取不到数据，在其他手机上没出现这个问题，唯独在魅族的手机上会有这个问题，我想请问一下魅族的开发者大佬们，这个问题该怎么解决呢？ 具体描述有两种情况，第一种没执行到onActivityResult 裁剪请求代码如下： /** * 对选择的图片进行裁剪 * @param uri 图片uri * @param outputX 输出图片宽度 * @param outputY 输出图片高度 * @param requestCode 请求码 */ public void cropImage(Uri uri, int outputX, int outputY, int requestCode) { Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.setDataAndType(uri, &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); intent.putExtra(&quot;aspectX&quot;, 1); intent.putExtra(&quot;aspectY&quot;, 1); intent.putExtra(&quot;outputX&quot;, outputX); intent.putExtra(&quot;outputY&quot;, outputY); intent.putExtra(&quot;noFaceDetection&quot;, true); intent.putExtra(&quot;return-data&quot;, true); intent.putExtra(&quot;scale&quot;, true); File file = new File( getApplicationContext().getExternalCacheDir(), UUID.randomUUID().toString() ); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file)); intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString()); startActivityForResult(intent, requestCode); } 覆写的onActivityResult代码如下： @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { switch (requestCode) { //裁剪图片之后的处理 case REQUEST_CROP_CODE: if (resultCode == RESULT_OK &amp;&amp; data != null){ Uri uri = data.getData(); if (uri != null) { this.mImageRealPath = uri.getPath(); LogUtil.d(&quot;ImageRealPath==&gt;&quot;, mImageRealPath); //更换图片 img_video_mask.setImageURI(uri); } } break; } super.onActivityResult(requestCode, resultCode, data); } 这种情况就是没法运行到onActivityResult方法里，裁剪图片之后，点击确定按钮，就直接闪退了，在debug模式下都没办法 第二种情况是能运行到onActivityResult里，但获取不了返回数据 裁剪请求代码稍微有点区别，具体如下： /** * 对选择的图片进行裁剪 * @param uri 图片uri * @param outputX 输出图片宽度 * @param outputY 输出图片高度 * @param requestCode 请求码 */ public void cropImage(Uri uri, int outputX, int outputY, int requestCode) { Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.setDataAndType(uri, &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); intent.putExtra(&quot;aspectX&quot;, 1); intent.putExtra(&quot;aspectY&quot;, 1); intent.putExtra(&quot;outputX&quot;, outputX); intent.putExtra(&quot;outputY&quot;, outputY); intent.putExtra(&quot;noFaceDetection&quot;, true); intent.putExtra(&quot;return-data&quot;, true); intent.putExtra(&quot;scale&quot;, true); // File file = new File(getApplicationContext().getExternalCacheDir(),UUID.randomUUID().toString()); // intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file)); intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString()); //输入文件格式 startActivityForResult(intent, requestCode); } 覆写的onActivityResult也稍微有点变化，具体代码如下： //裁剪图片之后的处理 case REQUEST_CROP_CODE: if (resultCode == RESULT_OK &amp;&amp; data != null){ Uri uri = data.getData(); if (uri != null) { this.mImageRealPath = uri.getPath(); LogUtil.d(&quot;ImageRealPath==&gt;&quot;, mImageRealPath); //更换图片 img_video_mask.setImageURI(uri); } else { Bundle bundle = data.getExtras(); if (bundle != null) { String filePath = bundle.getString(&quot;filePath&quot;); if (!TextUtils.isEmpty(filePath)){ img_video_mask.setImageURI( Uri.parse(filePath)); } } } } break; 之所以改成这样的写法，是因为我在网上找到一篇文章在说这个问题，并给出一个解决方案，我根据他的解决方案，依然没有解决问题。地址：http://www.cnblogs.com/over140/archive/2012/12/17/2821874.html 在Debug模式下，截图如下 通过截图可以看到uri和filePath都为null，实在没办法，所以来请教一下魅族的开发大佬们，希望能尽快收到你们的回复，小弟在此表示万分感谢！ 作者：zhongzilu原文地址： http://www.bit100.com/程序调用魅族系统裁剪之后直接闪退/"},{"title":"浓烟下的诗歌电台-陈鸿宇","permalink":"http://zhongzilu.github.io/2016/06/22/浓烟下的诗歌电台-陈鸿宇/","text":"浓烟下的诗歌电台-陈鸿宇标签 浓烟下的诗歌电台 安静 吉他 低沉 理想 行路 早春 钟子路 网易云音乐 读一本书，是与作者心灵上的沟通，听一首音乐也是。今天我给大家带来几首陈鸿宇的歌，听他的歌，什么烦恼，浮躁的心，都能烟消云散。 浓烟下的诗歌 浓烟下不过是南方三四月的梅雨时节，早春的树已按耐不住寂寞于冬末出芽，你只是经过而我却再也难忘你的容颜，理想三旬依旧年轻却忘了黑发已不再，霓虹深处灯红酒绿痴男怨女忘情歌唱，途中收到来信一封心中窃喜你还依旧，遗漏了我们一路走来心中畅想的行歌。 理想三旬 他说，理想已存在于月有三旬之前，七月融化在不经意的罅(xia)隙，十二月结成冰，被牢牢抓住在时间里，人有三旬，也不过是右手握着缄口不言的聚散，左手长出脉络骄横的命运，然后山崖无尽，热望不熄，最终死生寻常，悲喜成疾。 途中 独飞时慕侣，寡合乍孤音 行歌 负者歌于途，行者休于树 早春的树 偶然惊鸿一瞥，我心怦然而动，成为一棵早春的树。为你我愿折筋断骨，融入你每一寸生活，只盼守你年年月月，可我不过早春一棵树，只能立于门前，希冀你某天再经过我的荒芜 船子 你只是经过 她出现，又消失，一如日升日落，抑或任何转瞬即逝的事物。就像我们的生活，我们出现，然后我们又消失，我们对一些人是如此重要，但我们只是经过。 来信 窗外下起了小雨，没有你消息的夜是否继续漫长，前些天你说要寄给我一张明信片，我等邮戳漂过远方，等你慢慢变成我的习惯，心里为你留了一扇门，很难再关上，逐渐发现自己有些软弱，大概是惯性吧，像等你的日子，让我无能为力。 霓虹深处 这一刻，我来过的意义，而后恍悟，无谓再提。 浓烟下 歌声沉痛落地再轻浮地扬起，动人的永远只是半成品，和你，歌声沉痛落地再轻浮地扬起，而我能给的，恰好大都无意义。 浓烟下的影子霓虹深处的你都只是经过途中的一处风景 早春有树船有鱼群行歌吟完再读来信理想已三旬 作者：zhongzilu原文地址: http://www.bit100.com/浓烟下的诗歌电台 ——陈鸿宇/"},{"title":"Android Canvas绘制图形-拾音器之动画篇","permalink":"http://zhongzilu.github.io/2016/05/31/Android-Canvas绘制图形-拾音器之动画篇/","text":"Android Canvas绘制图形 拾音器之动画篇标签 Android Canvas View Animation ValueAnimator View动画 属性动画 前几天我写过一篇文章，叫Android Canvas 绘制图形 – 拾音器，那篇文章旨在讲解如何使用Canvas来绘制图形，并没有实现指针的偏转动画实现，那么，今天我们就来看看指针的偏转动画如何实现。 知识准备安卓上实现动画的方式分为两种，一种是View动画，包名：android.view.animation，另一种是属性动画，包名：android.animation。 View动画从字面上理解就是作用对象只能是View的派生类，其他的就只能心有余而力不足了。 属性动画的作用对象就不只是针对View的派生类了，他能操作很多属性，比如改变一个控件的宽高值；一个数值平滑过渡到另一个数值等，总之，View动画能做的他能做，View动画不能做的他也能做。对，你没看错，就是这么屌！ 简单介绍View动画，包括以下几种类型： 类型 说明 AlphaAnimation 渐变透明度 RotateAnimation 画面旋转 ScaleAnimation 尺寸缩放 TranslateAnimation 位置移动 属性动画(Property Animation)，包括以下几种类型： 类型 说明 ObjectAnimator 动画执行类，对对象进行操作 ValueAnimator 动画执行类，对数值进行操作 今天我们将使用到的是ValueAnimation类，接下来对动画进行分析，看看要实现指针偏转的动画需要用到什么方法。 指针偏转是通过旋转角度来实现的，如果我们要使偏转产生动画，就需要动态的改变旋转的角度。 旋转的角度参数类型是float，在ValueAnimator类中的ofFloat()方法正好是动态改变float数值的，所以我们要用到它。 数值每改变一次，我们都要把变化后的数值赋给rotate()方法，使指针旋转相应角度，所以这里需要对数值变化进行监听，因此会用到addUpdateListener()方法 赋值给rotate()方法后，需要对视图进行重绘，因此我们需要用到视图绘制过程中的invalidate()方法 思路这里我们用mValue表示指向数值，用变量mAngle表示通过计算后的偏转角度 通常的做法，我们都是在Activity或者Fragment里通过调用一个方法，将指针要指向的数值(mValue)数的方式传递过去，这样的话，我们就有两种思路。 一：使用ofFloat()方法动态改变指针指向的数值，即传递过来的参数mValue 二：将传递过来的参数进行计算成指针偏转的角度(mAngle)，然后使用ofFloat()方法动态改变角度数值 这两种方法都是可取的，具体情况具体分析，由于在界面上我们要动态显示指针指向的数值，如果采用第二种的话，那么我们要计算两次，一次是将指向mValue计算为mAngle，数值动态变化后还要将mAngle计算为mValue，这样比较麻烦，所以我们采用第一种思路。 因此，要实现指针的偏转动画，代码可以这么写： private int mMaxValue = 50; //分值区间的最大值 private int mMinValue = -50; //分值区间的最小值 /**输入值，通过输入值来计算指针的旋转角度，即{@mAngle}的值, * 最终在界面上呈现的效果是指针指向输入值的刻度上*/ private String mValue = &quot;- -&quot;; /**刻度盘呈现的总弧度，本案例中总弧度为180，呈半圆形*/ private float mArc = 180f; /**指针旋转角度值*/ private float mAngle = 0f; ... /** * 设置指针指向数值，并产生旋转动画 * 这里我们动态改变指向数值 * @param value 指向数值 */ public void setValue(float value){ //{@param value}为指针将要指向的数值，即界面上看到的数值 ValueAnimator startAnimator = ValueAnimator.ofFloat(0, value); startAnimator.addUpdateListener( new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { //通过getAnimatedValue()取变化后的值 float md = (float) animation.getAnimatedValue(); //计算指针当前应该偏转的角度 mAngle = md * (mArc / (float) (mMaxValue - mMinValue)); //界面上显示当前指针显示的数值 mValue = String.valueOf((int)md); //调用重绘方法 invalidate(); } }); startAnimator.setDuration(1000); startAnimator.start(); } 在setValue()方法里我们动态的改变了指针指向的数值和指针偏转的角度，并把这两个数值分别存放在全局变量mValue和mAngle，这样一来，我们只需要在onDraw()方法中，对指针进行旋转和但前指向数值的显示就可以了，代码如下： /** * 注意： * 下方的所以坐标计算和长度计算都是依据在屏幕宽度为621px情况下的 * @param canvas */ @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); ... System.out.println(&quot;mAngle ==&gt;&quot; + mAngle); canvas.rotate(mAngle, xc, yc); //画指针 /** * xc * 0.101449 = 深色刻度线条的长度 * mWidth * 0.064412 = 在屏幕宽度为621下，长度为40 * 所以下面第三个参数的值可以理解为距离深色刻度线下方有40倍数的间隙 */ canvas.drawLine(xc, yc, xc - radius + (xc * 0.101449f + mWidth * 0.064412f), yc + 3, paintCursor); ... //值 pitchValuePaint.setAntiAlias(true); pitchValuePaint.setTextSize((mWidth * 0.080515f)); pitchValuePaint.setColor(getResources().getColor(R.color.colorAccent)); canvas.drawText(mValue, xc - pitchValuePaint.measureText(mValue) / 2, yc + (xc * 0.481481f + mWidth * 0.209339f), pitchValuePaint); ... } 效果如下： 详细的代码，请移步到我的GitHub：https://github.com/zhongzilu/TunerView 我是钟子路，Thanks for watching!"},{"title":"Android Canvas绘制图形-拾音器","permalink":"http://zhongzilu.github.io/2016/05/26/Android-Canvas绘制图形-拾音器/","text":"Android Canvas 绘制图形 — 拾音器 最近在网上看到一个拾音器的设计图，看起来挺美观的，于是我就想把它实现出来，不多废话，先看图，左边是设计图，右边是实现图 除了指针不同，其他的大体上一样 Android Canvas介绍Canvas作为绘制图形的直接对象，提供了以下几个非常有用的方法 Canvas.save() Canvas.restore() Canvas.translate() Canvas.roate() Canvas.save()这个方法，从字面上理解就是保存的意思，而它的作用也正是将之前的画布保存起来，让后续的操作能像在新的画布上一样操作，这个PhotoShop的图层是一个概念Canvas.restore()这个方法，可以理解为合并图层，就是将之前保存下来的图层合并为一个图层Canvas.translate()这个方法，可以理解为移动坐标系，很多人在用时，理解为移动画布，所以在计算坐标时会出一些问题，在这里把他理解为移动坐标系更加恰当。画布的初始坐标系是左上角，如果我们调用translate(x, y)之后，则表示将原点(0, 0)移动到了(x, y)，后面的坐标计算都是在这一点上进行的Canvas.roate()可以理解为旋转坐标系，用法和Canvas.translate()相似，但多了个角度的参数，调用roate(degree, x, y)之后，则表示将以(x, y)为原点的坐标系旋转degree个角度 Paint理解为画笔，在Canvas上所有的图形，都需要这个对象，以下有几个常用方法 paint.setAntiAlias() paint.setStyle() paint.setStrokeWidth() paint.setColor() paint.setAntiAlias()是给画笔设置是否抗锯齿，参数为布尔类型paint.setStyle()是给画笔设置画笔样式paint.setStrokeWidth()给画笔设置画笔宽度paint.setColor()给画笔设置画笔颜色 实现有了上面的理论基础，现在我们可以来实现上面的效果了，先来分析一下上面效果图中有什么 刻度盘——外面的半圆刻度盘 刻度线——整数的深色粗线和其余德灰色细线 圆形底盘——共三个圆形底盘，最上面的深蓝色圆形要在指针上面 指针 新建一个类，继承View public class TunerView extends View { private int mWidth; private int mHeight; public TunerView(Context context){ super(context); //获取屏幕的宽高 WindowManager windowManager = (WindowManager) getContext().Context.WINDOW_SERVICE); mWidth = windowManager.getDefaultDisplay().getWidth(); mHeight = windowManager.getDefaultDisplay().getHeight(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); ... } } 第一步(Step 1)：画刻度盘 由于画布一开始绘制文字时，文字是垂直的，而在设计图中刻度盘是从左往右，文字是水平的，所以需要先对画布坐标系进行旋转 @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); int xc = mWidth / 2; //屏幕中心X坐标 int yc = mHeight / 2; //屏幕中心Y坐标 int radius = xc - 30; //圆半径 /** * 正常情况下，一开始写文字，都是垂直的，但我们的仪表盘 * 要求从左边开始画，文字是水平的，所以需要先对画布坐标系进行逆时针旋转90° */ canvas.rotate(-90, xc, yc); //画刻度盘 Paint paintDegree = new Paint(); paintDegree.setStrokeWidth(3); //画刻度线条 for (int i = -50; i &lt;= 50; i++){ //区别整点和非整点的线条样式 if (i % 10 == 0){ paintDegree.setStrokeWidth(5); paintDegree.setTextSize(30); paintDegree.setAntiAlias(true); paintDegree.setColor(getResources().getColor(R.color.colorAccent)); //这里画线的坐标计算，需要自行去理解，这里我就不多加解释了 canvas.drawLine(xc, yc - radius, xc, yc - radius + 40, paintDegree); String degree = String.valueOf(i); canvas.drawText(degree, //这里使用了Paint对象的measureText()方法, //该方法是传入一个String类型的参数，经过计算之后返回该String对象中 //文字所占用的宽度 xc - paintDegree.measureText(degree) / 2, yc - radius + 70, paintDegree); /** * 由于本案中两个整点之间只被分为了5分，所以每份的间隔就是2 */ } else if (i % 2 == 0){ paintDegree.setStrokeWidth(3); paintDegree.setTextSize(15); paintDegree.setAntiAlias(true); paintDegree.setColor(getResources().getColor(R.color.grey)); canvas.drawLine(xc, yc - radius + 10, xc, yc - radius + 30, paintDegree); } //每画完一条刻度线条，就需要对画布坐标系进行旋转，通过旋转简化坐标运算 //旋转角度为：总度数 / 总份数 //本案例中，总度数为180°, 分值区间为(-50 ~ 50),所以总份数为100份 canvas.rotate((float)(180 / 100), xc, yc); } //画圆形底盘 ... } 运行效果： 第二步(Step 2)：画园形底盘 画实心圆形底盘，通过调用paint.setColor()来设置颜色，调用paint.drawCircle()方法来画出圆形 //画大圆盘 Paint bigCircle = new Paint(); bigCircle.setColor(getResources().getColor(R.color.colorPrimary)); bigCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, xc - 180, bigCircle); //画中等圆盘 Paint midCircle = new Paint(); midCircle.setColor(getResources().getColor(R.color.colorPrimaryDark)); midCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, xc - 280, midCircle); //画小圆盘 Paint smallCircle = new Paint(); smallCircle.setColor(getResources().getColor(R.color.colorAccent)); smallCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, xc - 320, smallCircle); drawCircle()方法有四个参数， cx：圆心的x坐标，float类型 cy：圆心的y坐标，float类型 radius：圆形的半径，float类型 paint：画笔对象，Paint类型 运行效果： 第三步(Step 3)：画指针画指针其实和画线是一个道理，所以我们直接调用drawLine()方法就可以了 //画指针 Paint paintCursor = new Paint(); paintCursor.setStrokeWidth(3); paintCursor.setAntiAlias(true); paintCursor.setColor(getResources().getColor(R.color.colorAccent)); canvas.drawLine(xc, yc, xc - radius + 80, yc + 10, paintCursor); drawLine()方法有5个参数 startX：线条的起始点x坐标，类型float startY：线条的起始点y坐标，类型float stopX：线条的结束点x坐标，类型float stopY：线条的结束点y坐标，类型float paint：画笔对象，Paint类型 运行效果： 这里注意一下，由于我们的指针使用的颜色和最小的那个圆形的颜色是一样的，所以运行效果里看不出问题，如果换一个颜色，就会发现，指针在最小的圆形上面，而设计图上的指针是在最小的圆形下面，那么这要怎么解决呢？不要方，只需要把绘制最小那个圆的canvas.drawCircle()方法放到绘制指针的drawLine()方法之后就可以了 第四步(Step 4)：画正下方的文字 画正下方的文字，只需要调用canvas.drawText()方法就可以了 Paint pitchPaint = new Paint(); pitchPaint.setAntiAlias(true); //设置抗锯齿 pitchPaint.setTextSize(40); pitchPaint.setColor(getResources().getColor(R.color.colorAccent)); String pitch = &quot;Pitch&quot;; canvas.drawText(pitch, xc - pitchPaint.measureText(pitch) / 2, //这里加上180，是因为要加上最外面那个大的圆形的半径 //再加上80，是为了让文字和最大的那个圆产生间隙 yc + 180 + 80, pitchPaint); 运行效果： 可以看到文字的方向不对，为什么文字的方向不对呢？这是因为我们在绘制刻度盘的时候，我们对画布坐标系进行了旋转，画完刻度盘之后，坐标系被旋转了180°，但由于在绘制刻度盘之前，我们对整个画布坐标系进行逆时针旋转了90°，所以实际上只旋转了90°，因此，我们看到绘制的文字不是在正下方，而是在左边，被旋转了90°，那么这要怎么解决呢？最简单的方法当然是在绘制文字之前，把画布坐标系旋转回来。所以需要添加一行代码： canvas.rotate(-90, xc, yc); 运行效果 最后由于上面的案例代码里用到了很多写死的数字代码(Hard Code)，这不利于代码的灵活性，而且，既然有指针，就应该让指针根据一个提供的输入值，来让指针指向对应的数值位置，所以，我对代码进行了改良，代码如下： /** * Created by zhongzilu on 2016/5/25 0025. */ public class DialView extends View { private float mWidth; private float mHeight; private float mAngle = 0; //指针旋转角度，值为0时指针垂直显示 private static int mMaxValue = 50; //分值区间的最大值 private static int mMinValue = -50; //分值区间的最小值 /**输入值，通过输入值来计算指针的旋转角度，即{@mAngle}的值, * 最终在界面上呈现的效果是指针指向输入值的刻度上*/ private float mValue = 0; /**刻度盘呈现的总弧度，本案例中总弧度为180，呈半圆形*/ private float mArc = 180; public DialView(Context context, AttributeSet attrs) { super(context, attrs); //获取屏幕的宽高 WindowManager windowManager = (WindowManager) getContext().getSystemService( Context.WINDOW_SERVICE); mWidth = windowManager.getDefaultDisplay().getWidth(); mHeight = windowManager.getDefaultDisplay().getHeight(); } /** * 注意： * 下方的所以坐标计算和长度计算都是依据在屏幕宽度为621px情况下的 * @param canvas */ @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); float xc = mWidth / 2; //圆中心X坐标 float yc = mHeight / 2; //圆中心Y坐标 float radius = (float)(xc - xc * 0.05314); //圆半径 //画刻度盘 Paint paintDegree = new Paint(); /** * 正常情况下，一开始画线或写文字，都是垂直的，但我们的仪表盘 * 要求从左边开始画，文字是水平的，所以需要先进行画布旋转90° */ canvas.rotate((-mArc / 2), xc, yc); System.out.println(&quot;before rotate==&gt;&quot; + (-mArc / 2)); /** * 本案例中，设置的分值区间为（-50 ~ 50) */ for (int i = mMinValue; i &lt;= mMaxValue; i++){ //区别整点和非整点 if (i % 10 == 0){ //在屏幕宽度为621下，大小为5 paintDegree.setStrokeWidth((float)(mWidth * 0.008051)); //刻度字体大小是依据是：在屏幕宽度为621的分辨率下，刚好为30 paintDegree.setTextSize((float)(mWidth * 0.048309)); paintDegree.setAntiAlias(true); paintDegree.setColor(getResources().getColor(R.color.colorAccent)); canvas.drawLine(xc, yc - radius, xc, (float)(yc - radius + xc * 0.101449), paintDegree); String degree = String.valueOf(i); canvas.drawText(degree, //这里使用了Paint对象的measureText()方法, //该方法是传入一个String类型的参数，经过计算之后返回该String对象中 //文字所占用的宽度 xc - paintDegree.measureText(degree) / 2, //下方mWidth * 0.048309 = 在屏幕宽度为621下，长度为30 yc - radius + (float)(xc * 0.101449 + mWidth * 0.048309), paintDegree); /** * 由于两个整点之间只被分为了5分，所以每份的间隔就是2 */ } else if (i % 2 == 0){ paintDegree.setStrokeWidth((float)(mWidth * 0.004830)); //在屏幕宽度为621下，字体大小为15 paintDegree.setTextSize((float)(mWidth * 0.024154)); paintDegree.setAntiAlias(true); paintDegree.setColor(getResources().getColor(R.color.grey)); /** * 画灰色短横线，坐标计算依据是灰色短横向长度为深色长横线的一半， * 并且，两种刻度线的中点在同一个圆的圆弧上 * 由于深色刻度线的长度 = 正中深色小圆的半径 = 屏幕宽度一半的0.101449倍 */ canvas.drawLine(xc, (float)(yc - radius + xc * 0.101449 / 4), xc, (float)(yc - radius + xc * 0.101449 / 4 * 3), paintDegree); } //通过旋转画布简化坐标运算 canvas.rotate(mArc / (float)(mMaxValue - mMinValue), xc, yc); } /** * 三个圆盘的半径和屏幕宽度的一半的比例为 * 屏幕宽度一半 ：大圆 ：中圆 ：小圆 = * 1 ：0.481481 ：0.201288 ：0.101449 */ //画大圆盘 Paint bigCircle = new Paint(); bigCircle.setColor(getResources().getColor(R.color.colorPrimary)); bigCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, (float)(xc * 0.481481), bigCircle); //画中等圆盘 Paint midCircle = new Paint(); midCircle.setColor(getResources().getColor(R.color.colorPrimaryDark)); midCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, (float)(xc * 0.201288), midCircle); //画小圆盘 Paint smallCircle = new Paint(); smallCircle.setColor(getResources().getColor(R.color.colorAccent)); smallCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, (float)(xc * 0.101449), smallCircle); canvas.save(); //画指针 Paint paintCursor = new Paint(); //在屏幕宽度为621下，大小为3 paintCursor.setStrokeWidth((float)(mWidth * 0.004830)); paintCursor.setAntiAlias(true); paintCursor.setColor(getResources().getColor(R.color.colorAccent)); /** * 思路：要想让指针以圆心为中心旋转一定角度，要么旋转画布，要么根据坐标来画， * 由于旋转角度比根据坐标更简单，所以就用旋转角度的方式来实现 * * 指针具体旋转多少度，得根据算法来计算 * * 算法：角度 = 输入值 * （ 总弧度 / 分值总数） * * 举例：本案例中给出的分值区间为（-50 ~ 50）,所以分值总数为100 * 假设现在输入值为30，那么角度就为54° */ mAngle = mValue * (mArc / (float) (mMaxValue - mMinValue)); System.out.println(&quot;mAngle ==&gt;&quot; + mAngle); canvas.rotate(mAngle, xc, yc); /** * xc * 0.101449 = 深色刻度线条的长度 * mWidth * 0.064412 = 在屏幕宽度为621下，长度为40 * 所以下面第三个参数的值可以理解为距离深色刻度线下方有40倍数的间隙 */ canvas.drawLine(xc, yc, xc - radius + (float)(xc * 0.101449 + mWidth * 0.064412), yc + 3, paintCursor); //覆盖在指针上的圆 /** * 由于之前的坐标系已经发生了旋转，所以要在正下方写上文字，就需要旋转回来 * 当然也可以通过去计算坐标来显示在正下方，但旋转画布的方式更加简单和更容易理解 */ canvas.rotate(-(mAngle + mArc / 2), xc, yc); Paint pitchPaint = new Paint(); pitchPaint.setAntiAlias(true); //在屏幕宽度为621下，字体大小为40 pitchPaint.setTextSize((float)(mWidth * 0.048309)); pitchPaint.setColor(getResources().getColor(R.color.colorAccent)); String pitch = &quot;Pitch&quot;; canvas.drawText(pitch, xc - pitchPaint.measureText(pitch) / 2, //这里加上180，是因为要加上最外面那个大的圆形的半径 //再加上(mWidth * 0.123188)，是为了让文字和最大的那个圆产生间隙 //在屏幕宽度为621下，间隙为80 yc + (float)(xc * 0.481481 + mWidth * 0.123188), pitchPaint); //值 Paint pitchValuePaint = new Paint(); pitchValuePaint.setAntiAlias(true); pitchValuePaint.setTextSize((float)(mWidth * 0.080515)); pitchValuePaint.setColor(getResources().getColor(R.color.colorAccent)); String value = &quot;- -&quot;; canvas.drawText(value, xc - pitchValuePaint.measureText(value) / 2, yc + (float)(xc * 0.481481 + mWidth * 0.209339), pitchValuePaint); canvas.restore(); } } 经过修改过后，只需要修改全局变量mValue的值，就可以使指针指向界面上对应的值了，比如mValue = 30，运行效果 总结总的来说，没什么难度，关键点在于绘图时的坐标计算，以及对旋转画布的理解，旋转画布是旋转的画布坐标系。在本案例中，我没有对指针的旋转做动画处理，是因为本文重在讲解Canvas画图，各位也可以自行加上指针旋转动画代码。好了，以上就是今天的内容，各位可以发挥自己的想象力，绘制出更多更有趣的图形。我是钟子路，Thanks for watching! 作者：zhongzilu源码：https://github.com/zhongzilu/TunerView"},{"title":"【安卓热修复】当你准备开发一个热修复框架需要了解的一切","permalink":"http://zhongzilu.github.io/2016/05/24/【安卓热修复】当你准备开发一个热修复框架需要了解的一切/","text":"【安卓热修复】当你准备开发一个热修复框架的时候，你需要了解的一切很长一段时间前，在我用应用市场软件对我移动设备上的应用更新时，发现每次应用市场提示我更新应用的大小，都有一个节省多少兆大小的醒目文字。当时我很奇怪，难道是对应用安装包进行了压缩吗？过了一段时间后，在我浏览其他人博客时，无意间发现有篇写安卓应用安装包热补丁修复的文章，我仔细看了一遍，一时之间也没看懂，再加上那时也没太多精力，也就搁置起来了，没有进一步了解。 今天工作之余，又在我浏览博客时，再次发现了一篇关于热修复的文章，我看了一下，讲得挺有条理的，特此推荐给大家 原文博客链接：当你准备开发一个热修复框架的时候，你需要了解的一切"},{"title":"SEO如何提高百度权重","permalink":"http://zhongzilu.github.io/2016/05/20/SEO如何提高百度权重/","text":"SEO如何提高百度权重 大家好，我是钟子路，最近在负责公司的网站SEO，我也不是太会，就去查看很多的资料和博客，当然，其中很多方法都是差不多的，所以我在这里就不重复了， 今天就讲讲我无意间发现的，关于如何提高百度权重的方法，由于该方法还没得到验证，所以这里只是提供一种思路，如果可行，请分享给其他有需要的人。 科普时间百度权重是站长工具推出的针对网站优化关键词排名预计给网站带来流量，划分出0-9十个等级的第三方网站欢迎度评估数据。 百度官方目前只公开了竞价推广用户提供0-10不同分值关键词质量度的评级。 权重数值越大，说明网站自然流量越大，自然流量大，那么相应的关键词排名就相对靠前，权重，流量，关键词排名三者之间是相辅相成的。 网站关键词的数量越多，积累的权重也会越高，不过，这还要看关键词的流量，如果关键词的流量非常的低，即便排名很靠前，权重也不会积累到很多，不过可以积少成多。 百度权重的规则： 权重1 百度预计流量1~99权重2 百度预计流量100~499权重3 百度预计流量500~999权重4 百度预计流量1000~4999权重5 百度预计流量5000~9999权重6 百度预计流量10000~49999权重7 百度预计流量50000~199999权重8 百度预计流量200000~999999权重9 百度预计流量1000000以上 站长们要查看自己网站的权重，通常是通过站长工具进行查询的，我也不例外，直接在百度上搜索“站长工具”就可以了，百度权重查询地址http://rank.chinaz.com/，输入自己网站的网址就可以查询到当前的百度权重了。如下图： 思路既然关键字的流量和权重有直接关系，那么我们就可以在自己网站关键字里加入一些高频次、高流量的搜索关键词，这样可以让自己的网站更容易出现在搜索结果里，如果点击了你的网站，就会给自己网站增加一部分流量，而流量的大小决定网站的权重。 那么如何获得高频次、高流量的搜索关键词呢？ 这里就需要通过百度指数来进行查找了，百度指数地址http://index.baidu.com/ 输入要查询的关键字就可以查询到关键字的搜索指数以及历史趋势记录 点击上部【需求图谱】选项卡，可以挖掘指定关键字相近关键字的分布指数 这里的数据挺直观详细的，我就不多赘述了，祝愿各位站长们找到自己满意的关键字，Good luck!"},{"title":"如何在Android Studio中创建File Templates","permalink":"http://zhongzilu.github.io/2016/05/10/如何在Android-Studio中创建File-Templates/","text":"如何在Android Studio中创建File Templates标签： File Template Android Studio 我发现一个可以让写程序变得简单的方法，那就是自定义文件模板(Custom File Templates).那么什么是File Templates呢？说白了，就是一个已经包含一部分代码的源文件 如何创建File Templates首先，找到创建File Template的位置，依次打开File ==&gt; Setting ==&gt; Editor ==&gt; File and Code Templates 之后点击 +号添加一个File Template，这里需要填写 File Template的名称和代码。在本次案例中，我们将创建一个实现了部分方法的RecyclerViewAdapter的File Template。因此就取名叫RecyclerViewAdapter 之后你就可以在下方的代码区域粘贴或者编写你的模板代码了。这里有几个预置的变量可以使用，当文件被创建的时候，这些预置的变量将会被 将会被对应的值替代，变量如下： ${NAME} 选择的文件的文件名 ${PACKAGE_NAME}包名 ${DATE} 系统当前的时间当然，你也可以自定义变量，在本案例中，我们需要提供ViewHolder类和集合List的类型，所以自定义变量分别为${VIEWHOLDER_CLASS}和${ITEM_CLASS} 那么现在就来编写用于创建模板的代码，代码如下： #if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME};#end import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import java.util.List; #parse(&quot;File Header.java&quot;) public class ${NAME} extends RecyclerView.Adapter&lt;${VIEWHOLDER_CLASS}&gt; { private final Context context; private List&lt;${ITEM_CLASS}&gt; items; public ${NAME}(List&lt;${ITEM_CLASS}&gt; items, Context context) { this.items = items; this.context = context; } @Override public ${VIEWHOLDER_CLASS} onCreateViewHolder(ViewGroup parent, int viewType) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.${LAYOUT_RES_ID}, parent, false); return new ${VIEWHOLDER_CLASS}(v); } @Override public void onBindViewHolder(${VIEWHOLDER_CLASS} holder, int position){ ${ITEM_CLASS} item = items.get(position); //TODO Fill in your logic for binding the view. } @Override public int getItemCount() { if (items == null){ return 0; } return items.size(); } } 当你想要使用这个文件模板时，会提示你提供相关变量的值，比如${VIEWHOLDER_CLASS}和${ITEM_CLASS},填写的值会自动替换对应的变量，非常的方便。 要使用已经定义好的File Template，只需要选中要创建位置的文件夹，然后点击鼠标右键，再点“New”，你就可以在列表中看到刚创建的File Template的名字 点击RecyclerViewAdapter后填写相关变量的值 填写完后点击”OK”，之后你就可以看到自动生成的代码了 这样，今后我要实现一个RecyclerView的Adapter时，就不用再去写那么多代码了 如果你有一些比较好的代码模板，也可以分享给我哦 ^_^"},{"title":"如何在Android Studio(IntelliJ)中创建Live Templates","permalink":"http://zhongzilu.github.io/2016/05/10/如何在Android-Studio-IntelliJ-中创建Live-Templates/","text":"如何在Android Studio/IntelliJ中创建Live Templates标签： Android Studio IntelliJ Live Template 何为Live Templates? frequently-used or custom code constructs that you can insert into your source code file quickly, efficiently and accurately.快速，高效，准确的将常用或自定义构造代码插入到你的源代码文件中 通俗的讲，就是像快捷键一样，只需要输入几个简写的英文字母就可以快速自动插入一行或多行代码。 在Android Studio/IntelliJ编辑器中，默认使用Ctrl + J快捷键可以调出Live Templates，可以自动补全所设置的模板的代码，善用它能够很大程度上减少开发时间。 举个例子，输入psfi，然后按回车键，编辑器将会自动生成代码public static final int，这就节省了19个要输入的字母。 Android Studio/IntelliJ编辑器中预置了一些常用的Live Templates，大家可以自行去查看，查看位置File ==&gt; Settings ==&gt; Editor ==&gt; Live Templates 如何创建自定义的Live Templates？ 找到Live Templates的位置，然后点击右上角的+号，再选择Template Group，写上一个名称 接着再点击+号，选择Live Template，之后填写相关的内容 举例我用一个快速插入RecyclerView控件代码的例子来举例，设置如下图： 填写相关内容完毕之后 ，注意下方的一行红字，此时定义的Live Template还没生效，需要点击Define，然后选择该Live Template要应用到什么样的场景中。因为这里我定义的是安卓的控件代码，所以就归类为XML 点击OK按钮生效。注意勾选右下角的Reformat according to style选项 要想使用刚才定义的Live Template，只需要在android的XML布局文件中输入rcv，然后按回车键就可以了，如下图所示： 以上就是如何在Android Studio/IntelliJ编辑器中创建Live Template的方法，相信富有创意的各位能够创建出更多的更方便的Live Template，这对于今后的代码编写大有裨益 另外，我在这里推荐一篇博客：http://blog.csdn.net/DesmondJ/article/details/47017205"},{"title":"Wordpress自定义栏目的使用","permalink":"http://zhongzilu.github.io/2016/05/10/Wordpress自定义栏目的使用/","text":"WordPress自定义栏目的使用 前言 最近有个任务，要实现在公司官网上点击某个商品的购买按钮，就跳转到对应的淘宝店页面去。由于公司官网用的WordPress平台，我之前只是听说过，并没有实质性使用过，所以一开始就是一头雾水，再加上网站原本是由外包公司做的，交接时没有任何文档，因此我根本不知如何下手，但最后还是硬着头皮去做了。 我思考着要完成这个任务我需要怎么做，由于网站上的内容都是动态从数据库中取的，所以如果我要实现点击购买按钮就跳转到对应网店的功能，就不可能在代码中把跳转的店铺地址写死了，必须要从数据库中去读取，并且还要和商品关联起来才行。 这其中肯定涉及到把链接地址写入数据库，WordPress提供了一个管理后台，通过管理后台可以把数据写入数据库。 打开后台，找到文章编辑页面，在右上方有个显示选项，展开后可以显示和隐藏模块。勾选自定义栏目 在页面下方可以看到这个模块，在这里可以新增自定义的数据字段，并给它赋值。 拿我的任务来举例，我点击购买按钮之后跳转到对应的商品淘宝店，所以商品淘宝店的地址就需要写入数据库，所以现在新增一个自定义字段，点击输入新栏目 输入自定义名称和值，输入完成后点击添加自定义栏目 添加完之后就是如下图所示 自定义栏目添加成功了，那么问题来了，我们如何取到自定义栏目的值并显示在页面上呢？ 在WordPress中有个get_post_meta()的函数，官方的解释是： This function returns the values of the custom fields with the specified key from the specified post. 翻译过来大概的意思是：该函数用于取出用户设置的自定义字段的值。 用途 该函数的用处很多，很多主题用来设置文章相应图片的设置，这与将远程图像设置为缩略图有异曲同工之妙，当然自定义字段还可以用于存储许多我们觉得更有用的东西，例如统计信息，等等。 用法 &lt;?php $meta_values = get_post_meta($post_id, $key, $single); ?&gt; 参数解释 $post_id文章的ID（如果在循环中，你可以用 get_the_ID()来设置）,$key自定义字段的名称（键值）,$single是否以字符串形式返回，false会返回数组形式。 缺省用法 &lt;?php $value = get_post_meta(76, &#39;key&#39;); ?&gt; 实例 if (have_posts()) ://如果有文章 while (have_posts()) : the_post(); //开启主循环 $value = get_post_meta(get_the_ID(),&#39;custom_meta&#39;,true); endwhile; endif; 上面介绍完get_post_meta()函数，现在我们就来实现我的这个任务。在项目源代码中找到使用的主题的文件夹，我的文件夹位置为：htdocs/wp-content/themes/jitatheme/再找到function.php文件并打开，在这里我们将封装成一个获取地址的函数，代码如下： /** *获取淘宝店铺商品的地址 */ function getTB_Url($postID){ $key = &#39;direct_to_tb&#39;; $url = get_post_meta($postID, $key, true); return $url; } 然后找到我们要修改的页面，用一个&lt;a&gt;标签来实现点击跳转。我们在&lt;a&gt;标签的href属性中来调用刚才封装的函数，代码如下： &lt;a class=&quot;btn&quot; href=&quot;&lt;?php echo getTB_Url(get_the_ID()); ?&gt;&quot; target=&quot;_blank&quot;&gt;点击购买&lt;/a&gt; 最后在页面上点击测试一下，跳转正确，任务完毕。 总结 了解了如何在WordPress后台管理界面添加自定义栏目 了解了如何获取自定义栏目的值和get_post_meta()函数的使用"},{"title":"MVC&MVP模式有何不同","permalink":"http://zhongzilu.github.io/2016/05/10/MVC-MVP模式有何不同/","text":"MVC &amp; MVP模式有何不同标签 : MVP MVC 本文是翻译国外的一篇文章,英语水平有限,翻译有误的地方希望提出来,以方便修改,谢谢 原文传送门: http://www.infragistics.com/community/blogs/todd_snyder/archive/2007/10/17/mvc-or-mvp-pattern-whats-the-difference.aspx Over the years I have mentored many developers on using design patterns and best practices.多年来我有辅导过很多开发者使用设计模式和最佳实践 One question that keeps coming up over and over again is:What are the differences between the Model View Controller (MVC) and Model View Presenter (MVP) patterns?一遍又一遍出现的一个问题是: 模型 视图 控制器(MVC模式)和模型 视图 主持人(MVP模式)之间有哪些不同? Surprisingly the answer is more complex than what you would suspect.令人惊讶的是答案比你想象中的更复杂 Part of reasons I think many developers shy away from using either pattern is the confusion over the differences.我认为一部分原因是因为许多开发者回避使用两种模式带来的混乱 Before we dig into the differences let’s examine how the patterns work and the key benefits to using either one.在我们深入研究两种模式如何工作和使用其中一种带来的关键利益之前 Both (MVC &amp; MVP) patterns have been use for several years and address a key OO principal namely separation of concerns between the UI and the business layers.这两种模式(MVC &amp; MVP)已经使用了好几年,并且处理面向对象的关键就是分离界面UI层和业务层. There are a number of frameworks is use today that based on these patterns including: JAVA Struts, ROR, Microsoft Smart Client Software Factory (CAB), Microsoft Web Client Software Factory, and the recently announced ASP.Net MVC framework.这里有一些如今正在被使用的,基于这些模式的框架,包括:Java Struts, ROR, Microsoft Smart Client Software Factory (CAB), Microsoft Web Client Software Factory,还有最近发布的ASP.Net MVC框架 Model View Controller (MVC) Pattern The MVC pattern is a UI presentation pattern that focuses on separating the UI (View) from its business layer (Model).MVC模式是一个着重于从业务层(Model)分离UI(View)的UI表示模型 The pattern separates responsibilities across three components: the view is responsible for rending UI elements, the controller is responsible for responding to UI actions, and the model is responsible for business behaviors and state management.模型分离的重任横跨三个组件: 视图层负责渲染UI元素, 控制器负责响应UI操作, 模型层负责业务逻辑和状态管理. In most implementation all three components can directly interact with each other and in some implementations the controller is responsible for determining which view to display (Front Controller Pattern),多数的实现方法，可以使这三个组件互相直接作用影响，有一些实现的方法里，控制器负责确定哪些试图的显示（Front Controller Pattern) Model View Presenter (MVP) Pattern The MVP pattern is a UI presentation pattern based on the concepts of the MVC pattern.MVP模型是基于MVC模型的UI表示模型。 The pattern separates responsibilities across four components: the view is responsible for rending UI elements, the view interface is used to loosely couple the presenter from its view, the presenter is responsible for interacting between the view/model, and the model is responsible for business behaviors and state management.模型分离的重任横跨四个组件:视图层负责渲染UI元素， 视图层接口被用于把中介者（Presenter)从视图中解耦，中介者负责视图（View)和模型(Model)之间的交互,模型层负责业务逻辑和状态管理. In some implementations the presenter interacts with a service (controller) layer to retrieve/persist the model.在某些实现方法中，中介者会和服务层/控制器层交互来获取或持有model。 The view interface and service layer are commonly used to make writing unit tests for the presenter and the model easier.视图接口和服务层通常被用来编写中介者和模型之间的单元测试。 关键优势 Before using any pattern a developers needs to consider the pros and cons of using it.在使用任何开发模式之前，开发人员需要考虑使用它的优点和缺点。 There are a number of key benefits to using either the MVC or MVP pattern (See list below).这里有一些使用MVC和MVP模型的关键好处（请看下面的列表）。 But, there also a few drawbacks to consider. The biggest drawbacks are additional complexity and learning curve.但是，这里也有一些缺点需要考虑。最大的缺点就是它的复杂性和需要付出额外的学习成本。 While the patterns may not be appropriate for simple solutions; advance solutions can greatly benefit from using the pattern.这种模型可能不太适合一般的解决方案；好的解决方案可以从中获得更大的利益。 I’m my experience a have seen a few solutions eliminate a large amount of complexity but being re-factored to use either pattern.在我的经历中，我见过使用这些模式来重构项目，解决了不少的复杂的问题。 Loose coupling – The presenter/controller are an intermediary between the UI code and the model. This allows the view and the model to evolve independently of each other.松散耦合 - presenter或控制器在UI代码和模型之间充当着中间媒介的角色，这就使得视图和控制器之间互相独立。 Clear separation of concerns/responsibility清晰分离关注点和职责（关于concerns的翻译请自行有道）– UI (Form or Page) – Responsible for rending UI elementsUI(表单或页面） - 负责渲染UI元素 – Presenter/controller – Responsible for reacting to UI events and interacts with the model中介者/控制器 - 负责对UI事件与模型进行交互 – Model – Responsible for business behaviors and state management模型 - 负责业务逻辑和状态管理. Test Driven – By isolating each major component (UI, Presenter/controller, and model) it is easier to write unit tests. This is especially true when using the MVP pattern which only interacts with the view using an interface.测试驱动 - 通过分离每个主要组件（UI,Presenter/controller, model)更容易编写单元测试，当使用MVP模型且只通过接口来和视图层交互时，就更应该这样做。 Code Reuse – By using a separation of concerns/responsible design approach you will increase code reuse. This is especially true when using a full blown domain model and keeping all the business/state management logic where it belongs.代码复用 - 通过使用分离关注点和职责的设计可以增加你的代码复用。在使用全面的域模型和保持所属业务和状态管理的逻辑时，就更应该这样做。 Hide Data Access – Using these patterns forces you to put the data access code where it belongs in a data access layer. There a number of other patterns that typical works with the MVP/MVC pattern for data access. Two of the most common ones are repository and unit of work. (See Martin Fowler – Patterns of Enterprise Application Architecture for more details)隐藏数据访问 - 使用这种模式会强迫你使用数据接入层中的数据接入代码。这里有一些其他典型的使用MVP/MVC模型来进行数据访问的模型，最常见的两个就是库和工作单元。（想看更多细节请看Martin Fowler的企业应用架构模式【Martin Fowler - Patterns of Enterprise Application Architecture】) Flexibility/Adaptable – By isolating most of your code into the presenter/controller and model components your code base is more adaptable to change. For example consider how much UI and data access technologies have changed over the years and the number of choices we have available today. A properly design solution using MVC or MVP can support multi UI and data access technologies at the same time.灵活/适用 - 通过分离Presenter/controller和model组件可以使你的代码更灵活适用.举个例子,这些年来有许多UI技术和数据接入技术都有所改变,如今我们有许多的选择.恰当的使用MVC或者MVP模式来设计解决方案,可以同时支持多种UI技术和数据接入技术. 关键区别 So what really are the differences between the MVC and MVP pattern.Actually there are not a whole lot of differences between them.因此,MVC和MVP模式之间真正的区别.其实是没有太多区别. Both patterns focus on separating responsibility across multi components and promote loosely coupling the UI (View) from the business layer (Model).这两者都是专注跨组件分离职责,促进UI层从业务层中解耦. The major differences are how the pattern is implemented and in some advanced scenarios you need both presenters and controllers.主要的区别在于如何实现,在某些高级的应用场景中需要同时有Presenter和Controler Here are the key differences between the patterns:这里有些这两种模式之间的关键区别: MVP模式– View is more loosely coupled to the model. The presenter is responsible for binding the model to the view.视图和模型之间耦合更加松散.中介者负责把model绑定到视图层.– Easier to unit test because interaction with the view is through an interface更加容易编写单元测试,因为都是通过接口和视图交互的.– Usually view to presenter map one to one. Complex views may have multi presenters.通常情况下,视图和中介者是一一对应的.复杂的视图可能会有多个中介者. MVC模式– Controller are based on behaviors and can be shared across views控制器是建立在行为上的,并且可以跨视图共享– Can be responsible for determining which view to display能够负责决定要显示哪个视图 Hopefully you found this post interesting and it helped clarify the differences between the MVC and MVP pattern.希望你会觉得这篇文章是有趣的,这篇文章会帮助你理清MVC和MVP模式之间的区别. If not, do not be discouraged patterns are powerful tools that can be hard to use sometimes.如果没理清,请不要泄气,模型是一个强大的工具,以至于有时在使用时会觉得很困难 One thing to remember is that a pattern is a blue print and not an out of the box solutions.你只需要记住,模型只是一个蓝图,并不是快速的解决方案. Developers should use them as a guide and modify the implementation according to their problem domain.开发者应该把它们作为指导手册,并根据遇到的问题修正实现方案. 作者 :zhongzilu"},{"title":"Android开发之MVP初体验","permalink":"http://zhongzilu.github.io/2016/05/10/Android开发之MVP初体验/","text":"Android开发 MVP之初体验标签 ：Android MVP MVC 熟悉安卓开发的童鞋应该都熟悉MVC架构模式, MVC开发模式即: Model(模型) – View(视图) – Control(控制器) 逻辑图如下: 而这种开发模式有个缺点,就是在项目越来越大时,文件会越来越多,查找起来很不方便,而且Activity或者Fragment里面的代码会越来越臃肿,看起来很凌乱,要修改更是让人头疼,于是就提出了一种MVP的开发模式,MVP开发模式即: Model(模型) – View(视图) – Presente(任命者/中介) 逻辑图如下: 网上有很多讲解MVP的文章和教程,我这里就不详细介绍了,但还有很多人看过教程之后依然不知如何实现MVP,今天主要通过实际代码的方式来体验MVP开发 本次使用的代码为Github上的一个开源项目,名为androidmvp 传送门 https://github.com/antoniolg/androidmvp 先看看界面界面很简单,就是一个登录界面和一个ListView填充的主界面,登录之后跳转到主界面,主界面上显示一个列表 第一步用Android Studio打开项目之后可以看到如下的项目结构 通过截图可以看出,该项目是根据界面来分类的,Login文件夹下放的是所有与登录界面有关的文件,main文件夹下放的是所有与主界面有关的文件 其中, Login文件夹下共有6个文件, 3个类文件, 3个接口文件 类文件: LoginActivity LoginInteratorImpl LoginPresenterImpl 接口文件: LoginView LoginInteractor LoginPresenter 第二步打开LoginActivity.java文件 public class LoginActivity extends Activity implements LoginView, View.OnClickListener { private ProgressBar progressBar; private EditText username; private EditText password; private LoginPresenter presenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); //实例化控件 ... presenter = new LoginPresenterImpl(this); } ... 从上面代码可以看出,该Activity实现了LoginView的接口和View的点击事件, 并且实例化了一个LoginPresenterImpl对象 现在打开LoginView.java public interface LoginView { void showProgress(); void hideProgress(); void setUsernameError(); void setPasswordError(); void navigateToHome(); } 可以看到LoginView文件中定义了几个接口, 通过名称可以很容易知道每个接口是用来干什么的返回LoginActivity也很容易发现是如何实现这几个接口的,如下: Override public void showProgress() { progressBar.setVisibility(View.VISIBLE); } Override public void hideProgress() { progressBar.setVisibility(View.GONE); } Override public void setUsernameError() { username.setError(getString(R.string.username_error)); } Override public void setPasswordError() { password.setError(getString(R.string.password_error)); } @Override public void navigateToHome() { startActivity(new Intent(this, MainActivity.class)); finish(); } 打开LoginPresenter.java public interface LoginPresenter { void validateCredentials(String username, String password); void onDestroy(); } 可以看到定义了两个接口,其中validateCredentials接口是用来验证用户名和密码是否通过验证的在LoginActivity中也有实现 @Override public void onClick(View v) { presenter.validateCredentials(username.getText().toString(), password.getText().toString()); } 看到这里, 我们可以总结出LoginActivity没有做任何逻辑相关的事情,而是在做界面显示相关和界面跳转的事情, 就连验证帐号的逻辑都是交给LoginPresenterImpl类的 那么现在顺藤摸瓜,打开LoginPresenterImpl.java文件 public class LoginPresenterImpl implements LoginPresenter, LoginInteractor.OnLoginFinishedListener { private LoginView loginView; private LoginInteractor loginInteractor; public LoginPresenterImpl(LoginView loginView) { this.loginView = loginView; this.loginInteractor = new LoginInteractorImpl(); } //其他方法的实现 ... } 我们可以看到该类实现了LoginPresenter和LoginInteractor.OnLoginFinishedListener的接口, 并且在构造方法的参数为LoginView, 那么问题来了, 为什么要传递LoginView类型的参数呢? 我们刚才也看到了,在LoginView中定义了几个接口, 而在LoginActivity中有对这几个接口的实现, 所以传递这个参数, 是有利于LoginPresenterImpl类调用LoginActivity的实现方法, 用于界面上的显示, 这就达到了逻辑代码和显示代码的分离 好了,现在来看看是怎么实现LoginPresenter中的validateCredentials接口的吧 @Override public void validateCredentials(String username, String password) { if (loginView != null) { loginView.showProgress(); } loginInteractor.login(username, password, this); } 看到这里,有同学该有疑问了,为什么在这个方法里我没看到实现帐号验证的具体逻辑呢? 没错,这里不应该有帐号验证的具体逻辑代码,因为LoginPresenterImpl类充当的是任命者或者称中介者的身份, 中介者只负责联系界面类和具体实现逻辑代码的类,如果还不能理解,就想想房地产中介吧, 他们只负责联系买房者和卖房者, 其他的事都不管(抱歉, 我没有鄙视或看不起房地产中介人员的意思, 这里只是做个举例, 在此说声对不起). 我们看到代码中, 把接收到的username和password参数传递给了一个login方法, 该方法在LoginInteractor文件中, 我们再打开LoginInteractor.java文件 public interface LoginInteractor { interface OnLoginFinishedListener { void onUsernameError(); void onPasswordError(); void onSuccess(); } void login(String username, String password, OnLoginFinishedListener listener); } 可以定义了一个login接口和一个OnLoginFinishedListener接口类, 返回LoginPresenterImpl.java文件可以很容易看到OnLoginFinishedListener接口类中接口的实现 @Override public void onUsernameError() { if (loginView != null) { loginView.setUsernameError(); loginView.hideProgress(); } } @Override public void onPasswordError() { if (loginView != null) { loginView.setPasswordError(); loginView.hideProgress(); } } @Override public void onSuccess() { if (loginView != null) { loginView.navigateToHome(); } } 在这些接口的实现中同样只是调用LoginView中的接口,并没有具体的逻辑操作代码 在该类的构造方法中我们会发现, 这里实例化了一个LoginInteractorImpl对象, 我们现在打开LoginInteractorImpl.java文件 public class LoginInteractorImpl implements LoginInteractor { @Override public void login(final String username, final String password, final OnLoginFinishedListener listener) { // Mock login. I&#39;m creating a handler to delay the answer a couple of seconds new Handler().postDelayed(new Runnable() { @Override public void run() { boolean error = false; if (TextUtils.isEmpty(username)){ listener.onUsernameError(); error = true; } if (TextUtils.isEmpty(password)){ listener.onPasswordError(); error = true; } if (!error){ listener.onSuccess(); } } }, 2000); } } 我们可以看到该类实现了LoginInteractor中的login接口, 并且在login方法中进行了具体的逻辑处理, 如果验证通过, 调用onSuccess接口 好了,整个登录流程讲完了,最后我们再来梳理一下整个流程: 在LoginActivity中,通过LoginPresenter接口类中的validateCredentials接口,把username和password传递给LoginPresenter的实现类LoginPresenterImpl LoginPresenterImpl类再通过LoginInteractor接口类中的login接口, 把username和password传递给LoginInteractor的实现类LoginInteractorImpl 在LoginInteractorImpl类中进行具体的逻辑处理, 如果验证通过,则调用LoginInteractor.OnLoginFinishedListener接口类中的onSuccess接口, 即调用了LoginPresenterImpl类中实现的onSuccess接口 LoginPresenterImpl类中实现的onSuccess接口中,调用了LoginView接口类中的navigateToHome接口,即调用了LoginActivity类中实现的navigateToHome接口 最后在navigateToHome接口中实现Activity的跳转,跳转到MainActivity 流程图如下: 总结在MVP开发模式中, Activity只负责界面的显示和跳转相关的操作, 具体的逻辑处理通过调用接口来传递给Presenter(中介者) 既不做界面显示的操作,也不做具体的逻辑处理操作, 具体的逻辑处理通过调用接口,让Interactor即交互类来完成 交互类的逻辑处理结果,通过调用Presenter中实现的接口, 再由Presenter要实现的接口中调用Activity中实现的接口来进行UI的显示或界面跳转 最后好了,安卓开发 MVP之初体验讲完了,写了那么多,希望大家能够看懂了,如果还有什么问题,可以问我Follow Me"},{"title":"【微表情心理学】耳朵的秘密","permalink":"http://zhongzilu.github.io/2016/05/10/【微表情心理学】耳朵的秘密/","text":"如果你仔细观察我们的耳朵，你会发现耳朵就像一个倒置的胎儿。他的头部朝下，臀部朝上。耳朵可以被看做事他人体的缩小版 耳朵大小某种程度上体现一个人的生命力和思想深度通常来说，一个人的耳朵越大，他就越充满激情和活力，他多半精力旺盛，但也很容易脾气暴躁，比如美国前总统比尔·克林顿。耳朵中等大小的人，多半思想冷静、理性而客观，比如法国影星苏菲·玛索。而小耳朵的人，多半具有很强的观察力，而且适应能力很强，对待事情也比较有耐心 耳朵反映一个人的性格特征大耳朵的人多半活力四射，行动力和执行力比较强，有个性，有思想 耳朵外形美观的人，内心相对平静，富有想象力，具有坚持不懈的品质和乐于竞争的精神 耳轮在起始处粗壮，而在走向中间的部位是剧烈变细的人多半比较顽固，敏感，情绪不稳定，容易消沉 耳朵外形粗糙，粗笨或过宽，过厚，此人往往比较麻木缺乏感情，思维不受控制，甚至有时还很野蛮，具有强烈的攻击性 中等大小的耳朵为正常耳朵，虽不具备丰富想象力和热情，但感情稳定，不易出现波动，而且做事更加理性，逻辑性思维很强，做事前喜欢深思熟虑，权衡再三，与人交往时不会无理争辩，而是做出让人信服的言论。总之此类人为人处世相对稳重，并且善于处理工作和生活之间的关系 小耳朵通常缺乏强烈的野心，自信心，想象力和创造性，但他们多半反应迅速，身体灵敏，并且具有极强的专注力和观察力。性情上，一般较为敏感，更容易闷闷不乐，郁郁寡欢，也常陷入悲观局面。但他们行事严谨，很少出现差错，往往也会取得令人骄傲的成绩 扯耳朵或摸耳垂在谈话中，很多人习惯做出扯耳朵或者摸耳垂的动作，通常这种动作表示他们试图打断对方说话。 摸耳垂的动作是一种自我触摸，自我安慰的行为。通常当人们对谈话内容不感兴趣而产生乏味，无趣的情绪甚至对内容反感时会出现此举动。一方面是想要打断对方的潜意识，另一方面是借此来安抚自己消除内心的浮躁和不安。 当人们紧张、内心焦虑不安、说谎、表示反对意见时也会有此举动 咬嘴唇或隐藏嘴唇出现此举通常是由于出现某种压力或紧张情绪。这是一种消极情绪 突然收拢嘴唇或嘟起嘴，如果在谈话时出现此举动，通常说明此人对所讲话的内容在心理上出现了反对意见或是不完全认可的态度，此时他正在思考怎么样转换正在谈论的话题或者是准备提出自己的不同意见 作者：zhongzilu"}]}