{"pages":[],"posts":[{"title":"Hello from zhongzilu","permalink":"http://zhongzilu.github.io/2117/01/01/Hello-from-zhongzilu/","text":"Hello from ZhongziluWelcome to BIT100.I’m zilu Zhong,an Android developer.Here is my blog website.I will post some blog articel which include technology,psychology and other notes in some time.In order to facilitating more people,I will sharing something which is be useful to everyone,because i believe that the knowledge more sharing more valuable.Sorry!My English is poor.So,Don’t be care. 欢迎来到我的网站，我是钟子路(zhongzilu)，是一个安卓开发者。这个网站是我的博客网站，我会不定时更新一些博客，博客类型包括技术博客，心理学笔记以及一些随笔，总之，是把我觉得对大家有用的东西分享出来，以便利更多人。我相信，知识越分享越有价值。 作者：zhongziluGitHub： https://github.com/zhongzilu简书: http://www.jianshu.com/users/0551ca89845b/latest_articles安卓社区: http://ask.android-studio.org/?/people/zhongzilu"},{"title":"【随笔记】- 第3记","permalink":"http://zhongzilu.github.io/2017/11/29/【随笔记】-第3记/","text":"世界那么大，生命那么短，是否存在让我停留的一隅"},{"title":"【随笔记】好久不见","permalink":"http://zhongzilu.github.io/2017/09/25/【随笔记】好久不见/","text":"【随笔记】好久不见今天走在回家的路上，前方有个姑娘，我无意间看了一眼，嗯，好像在哪儿见过。我放慢了脚步，再看第二眼，四目相对，彼此就停在相隔大约两米的距离，我脑中迅速搜寻着她的名字，大约一秒后，我听到了我的名字，一切的沉默就此打破，我从没感觉到一秒居然有那么久，就像时间停止了一样，我觉得这是我经历过的最长的一秒。 我立马回应道：“好久不见”。随后我们聊了很久，也聊了很多。真没想到，时隔多年，居然以这样的方式再次相遇，不得不说是缘分啊，我的老朋友。"},{"title":"Lady Zaynah","permalink":"http://zhongzilu.github.io/2017/06/17/美妙的一晚/","text":"今晚，我和朋友约定去戛纳湾弹吉他，我们从晚上8点一直弹到晚上10点过。起初是祝大哥一直在弹唱，后来祝大哥离开了一段时间，他回来后就准备收拾设备打算回家了，然后突然祝大哥问我英语怎么样，我说还行，能简单交流。接着他望向一位坐在路边椅子上的女士示意我，说我可以和她交流，于是我鼓起勇气去打了一声招呼，结果她也很热情地回应了我，于是我们几个就一起往家的方向走，我觉得我打开了一道新世界的大门。 在路上我们用英语交流，她说她叫Zaynah, 就是歌里的那个发音，我问她这个名字有什么含义吗，她说在她的家乡，Zaynah象征着美好的事物（Zaynah means beautiful），她说她来自伦敦，现在在这边当英语教师，大概一年左右吧。虽然我的英语不怎样，并且她也不怎么会说中文，用她的话说：I can’t speak Chinese any.但是我们确实交流了很多，我们时而借助翻译软件，时而靠意会和看对方表情和动作来试图理解对方的意思，似乎这种方式也是不错的选择。我们互相说了一些自己的基本信息，也谈到了各自的兴趣爱好，气氛十分融洽。我说我可以教她中文，她可以教我英语，她也表示Very good.从此，我想我就拥有了一个来自伦敦的外国友人，哈哈哈哈，我很兴奋，因为这是我梦寐以求的，没想到梦境实现的这么快，这么突然！简直Unbelievable。"},{"title":"旅途中的情书","permalink":"http://zhongzilu.github.io/2017/05/19/旅途中的情书/","text":"旅途中的情书今晚在刷朋友圈时，一个朋友发了一张照片，她说这是她在去西藏时，在一家旅馆里看到的，写得很深情，字也写得很好，但不知道是谁写的。如果有机会，我一定要去看看这家旅馆，带上几瓶酒，我感觉这家旅馆有故事。 原文： 如果可以，我真的想和你一直旅行，或许是某个未开发的荒凉小镇，或许是某座闻名的文化古城。我们可以沿途用镜头记录彼此的笑脸，和属于我们的风景。一起吃早餐，午餐，晚餐，或许吃得不好，可是却依旧为对方擦去嘴角油渍。风景如何，其实并不重要，重要的是你在。"},{"title":"麻将的由来","permalink":"http://zhongzilu.github.io/2017/05/19/麻将的由来/","text":"麻将的由来麻将牌又称麻雀牌，是江苏太仓的护粮牌。 在江苏太仓县曾有个皇家的大粮仓。粮食多，偷吃的麻雀就更多了。管粮仓的人为了奖励抓麻雀保护粮食的人，用竹子做了竹牌记录抓麻雀的数目，然后凭竹牌给奖金，这就是护粮牌，而这种竹牌除了记录数目跟兑奖金之外，还可以当作牌具没事就打两局。 护粮牌上刻的各种符号和数字都跟抓麻雀有关，护粮牌上筒的图案是火药枪的横截面，所以“筒”指的是枪筒，几筒就表示有几支火药枪，“索”是指用细绳串起来的麻雀，几索就是指几只鸟，所以一索就是鸟的图案，奖金是按照几只鸟来计算的，而“万”指的是奖金的单位，几万就是指奖金的数目了，“中”、“发”、“白板”，分别是“射中”、“发放奖金”和“没有打中”的意思。 麻将用到的术语跟护粮牌也是有关的。比如“碰”有枪声“砰”的感觉，成牌叫“胡”和“鹘”谐音，而“鹘”又是一种捕雀的鹰，除了这些还有“吃”、“杠”等术语也跟捕鸟有关。 这下各位看官应该知道麻将的由来了吧，据说打麻将可以预防老年痴呆，不说了，我要去学打麻将（我还很年轻，学打麻将纯粹是为了娱乐，不是预防老年痴呆，/偷笑 :）。"},{"title":"爱上一只蝴蝶","permalink":"http://zhongzilu.github.io/2017/05/16/爱上一只蝴蝶/","text":"爱上一只蝴蝶"},{"title":"噩梦","permalink":"http://zhongzilu.github.io/2017/04/29/噩梦/","text":"噩梦今天是2017年4月29日星期六早晨6点34分，我起床后的第一件事就是写下我晚上做的噩梦。首先我要说明的是，我是一个无神论者，不信教，也不相信世间有鬼怪的存在，接下来要写的事情就是和鬼怪有关的梦。 昨晚我做了一个梦，一整晚只有一个梦，最可怕的是它是一个噩梦，由于我此时此刻在写这篇博客的时候，我的意识已经很清醒了，梦境中的很多画面都很模糊了，所以，接下来呈现的只是梦境中的一些片段，一些比较深刻的片段，直到我现在回想起来都还有点头皮发麻。 片段一我梦见我来了一片荒野之地，四周全是枯草和干枯的树木，没有可恶的乌鸦和乌鸦叫声。在这个梦境中，我得知的事情是我的外婆去世了（现实是我外婆活得好好的），出殡那天即将要从这片荒野之地经过，就在我所在的这个地方，在我的右手边有一块地方是被火烧过的，呈现出木灰的黑色，没有枯草。之后不知道怎么的，我发现自己躺在一个很大的棺材旁边，我站起来往棺材里看，发现里面躺着我的奶奶，这把我吓坏了，梦境中的我第一反应就是觉得这是一个梦，这就相当于自己在梦中得知自己正在做梦，但是自己却没从梦中醒来。梦中我感觉到这是否预示着什么不好的事情，于是想打电话告诉我妈妈，让妈妈打电话提醒外婆和奶奶注意火，因为那片荒野之地有被火烧的痕迹。 正当我想着打电话给妈妈时，我就真的梦见我妈妈了，但这是片段二的内容了。 不得不说，如果你真的在梦中发现自己在做梦，那你真的是想什么就有什么，有种能操控梦的感觉。以下片段都是在我知道自己在做梦的情况下发生的 片段二片段一中说到我想打电话给我妈妈，结果我真的就梦见了我妈妈，不知道是因为她出现的时间短还是因为我的记忆模糊了，能记得的就只有一个画面而已，那就是在家中的房间里，她给我说她好像有事，就从房间里出去了，留我一个人在房间里，因为我知道自己在做梦，所以并不害怕，相反我想知道房间里有什么，然后我在房间里四处翻东西，发现房间里到处都藏着我喜欢吃的零食，柜子里，床上，枕头下等。 然后我想知道妈妈出去干什么去了，就从房间里出去了，之后就来到了片段三的场景。 片段三我来到一个很黑的胡同里，这里有一家人的门是开着的，里面透出了光。这所建筑是那种很老式的四合院那种，青砖黑瓦，有个不算很高的院式围墙，我从大门进去后发现一个很漂亮的女人，我不认识，但她感觉和我很熟，她说附近出了命案，抓住了一个嫌疑人，关在地牢里，正等着去审问，于是他带我去了地牢，地牢里很黑很黑，她指着一个方向说那就是嫌疑人，我朝着她指的方向看去，什么人都没看到，只看到一团黑雾，接着她说待会儿会有个人来审问犯人，果然有个人过来了，走近了才看清是个女人，个子不算高，但很漂亮，她好像和带我来这里的那个女人很熟，一来就互相拥抱，还亲吻了一下嘴唇(这TM都是啥！)，我就在一旁看着，然后那个女人把我推倒在地，坐在我身上，用审问犯人的语气问我是谁，但此时的她已不再是原来的那个人，身体是个女人，但脸已经看不清了，一团黑雾，然后带我到这里来的那个女人也化成一团黑雾消失了，此时的我有点被吓到了，迷迷糊糊的有点醒了的意思。 片段四我感觉自己有点清醒，但又还在梦中，我现在眼前看到的不是什么场景，我只是躺着，周围一片白色，眼前的白色好像被均匀地分成了三份，就像奔驰车的商标，是被两根布条分割的，一根布条绑在另一个布条的中间，然后向三个方向拉成奔驰车商标的图案，此时的我根本动弹不得，就像被鬼压床一样。后来慢慢地感觉到我的左手有点疼，就像被什么牙齿咬住了一样，过了一会儿右手也开始疼了，疼痛感越来越强，于是我拼命想挣脱，就用手去撕扯那几根布条，然后感觉像是听到了布条被撕裂的声音，这时我才有点可以动了，慢慢的我开始恢复意识，我感觉到我自己是双脚交叉，右手叠在左手上，并且双手都放在腹部的位置，以这样一个姿态躺着的，于是我睁开了双眼，眼前看到的是卧室的一个房角，正好三等分我的视线，回想起梦中的那布条的形状，这让我也有点毛骨悚然，觉得这有点像某种仪式或者图腾，就像电影里面要召唤鬼怪总会用什么东西摆出某种图案一样。于是我起床打开手机看时间，是早上5点12分，觉得太早就又躺下休息了一会儿，直到6点过后起床，然后打开电脑开始写这篇博客。 整个梦境都是昏暗的，随着意识的清醒，能记住的大概就这么多了。"},{"title":"游戏","permalink":"http://zhongzilu.github.io/2017/04/27/游戏/","text":"游戏今晚我正在敲着代码，突然手机响了，一看原来是燕子发来微信消息，她给我发来了一张照片，一张脚踝的照片，脚上有两朵玫瑰的图案。 她问我觉得好看吗，我说挺好看的，觉得挺性感的。后来我问她是贴纸还是纹身，她说是贴纸贴的，她和朋友买了好多不同图案的贴纸，这下我长舒了一口气，虽然我不反对纹身（只要不是满身都是纹身，左青龙右白虎的那种，我都还能接受），但我也不喜欢纹身，因为我觉得纹身是一种自残行为，是对身体的不尊重，俗话说得好：身体发肤，受之父母，不敢毁伤，孝之始也。 今晚我们聊了很多，最后还做了一个小游戏，在微信上玩儿掷色子比大小的游戏，三局两胜，胜者可以提一个要求，输了的人在微信上按照要求执行，有点像玩真心话大冒险的游戏，只不过没有大冒险环节。我借此机会向她了解了很多的事情，包括她之前的情感经历等，当然她也这么做的（^_^）。 我们玩到很晚，最后比较困了就互道晚安结束了游戏。结束后我感觉不是很开心，具体怎么我也说不清楚，这么说吧，人都是带着好奇心的动物，对未知的东西都想去弄个明白，但有些事情别看太透彻，留有一些幻想也是不错的，隔着一层薄纱看世界，你会发现世界更美好。Screenshot_1493224171811.png"},{"title":"一生所爱","permalink":"http://zhongzilu.github.io/2017/04/24/一生所爱/","text":"一生所爱今晚忙着敲代码的我，向往常一样打开网易云音乐听歌，我喜欢边听歌边敲着代码，我觉得世间没有比这两者更配的了，就像至尊宝和紫霞。 打开软件后看到网页云音乐的专栏部分，正好是大话西游的“一生所爱”，标语是：读懂一生所爱，从一万年的期限到只争朝夕。我想看过大话西游的人应该都不能拒绝这样的专栏内容，于是我就点开看看详情。 一生所爱这首歌是1993年卢冠廷和妻子唐书琛一起创作，第一次出现在《大话西游之大圣娶妻》的片尾曲出现，结尾漫天的风沙掠过沙漠，至尊宝把金箍棒扛在肩上落寞的离去，有人在城墙上说：“你看那个人,好奇怪哟,像一条狗” 文章中的一些评论吸引了我的眼球： 想要救紫霞就必须打败牛魔王，想要打败牛魔王就必须要变成孙悟空，想要变成孙悟空就必须忘掉七情六欲从此不能再有半点沾染。人生就是这样：想自由地和心爱之人在一起必须要事业有成，想要事业有成就必须要抛弃天真戴上面具，当你变得有能力给心爱之人一切时，却发现找不回最初的自己亦失去了爱的能力—— oowuwo（网易云音乐网友，下同） 这个评论让我响起了一句话：我抱起砖头就无法抱你，我放下砖头就无法养你。这两者都有着异曲同工之妙 多年以后 才知道 那个转身 有多难 —— 江丨河 俗话说的好，浪子回头金不换，回头很难，但面对自己心爱的人，转身离开更难。 白晶晶爱的是孙悟空，爱白晶晶的是至尊宝，紫霞爱的是至尊宝，爱紫霞的是孙悟空，你以为是同一个人，其实已经相隔500年 —— 路人lx 说实话，我看这部片子不少遍，每次看都有不一样的心情，从最开始的觉得剧情的搞笑，到后来慢慢的理解其中包含的深层含义。有些事情就是这样，小时候不管别人说多少遍，说得多么透彻，自己都不能理解为什么，但随着慢慢的成长，有些事就自然而然的懂了。 各位看官，珍惜眼前事，珍惜眼前人！保重。"},{"title":"【读后感】- 迷失的旅行者","permalink":"http://zhongzilu.github.io/2017/04/19/【读后感】-迷失的旅行者/","text":"迷失的旅行者 - 读后感今晚刚看完《天才在左，疯子在右》这本书中的迷失的旅行者章节，作者共用了三个小节来讲述这个故事，分别是前篇：精神传输；中篇：压缩问题；后篇：回传。看完三个小节后，有种像刚看完一部烧脑科幻大片，又像是看完一部精神病采访实录，亦或者是一部异想天开的穿越剧，总之是让人回味无穷。 故事里涉及了很多专业术语，像是物理学术报告，但同时又是个悲伤的故事，正如文章结尾说的那样： 看着窗外，我想朋友也许说的对，但是我们都很清楚，对于迷失的旅行者来说，这里并不是他的家，这里永远都是异国他乡，可他没有选择，只能生活在这个异乡。也许总有一天他会解脱，但在这之前，只能默默地承受，直到他的身体、他的记忆，最终灰飞烟灭。"},{"title":"【随笔记】- 第2记","permalink":"http://zhongzilu.github.io/2017/04/18/【随笔记】-第2记/","text":"【随笔记】- 第2记 缘起，我们相遇于人海；缘灭，我们消失于眼前。"},{"title":"还没年轻过我们就老了","permalink":"http://zhongzilu.github.io/2017/04/16/还没年轻过我们就老了/","text":"还没年轻过我们就老了今天是2017年4月16日星期天，我像往常一样去看望爸爸妈妈，回到家后就和爸爸寒暄了几句，爸爸突然说道：“今天早上你哥打来电话说你长大了，变成熟了，听声音都变得有点老气横秋了。”我调侃道：“那可不，都20多岁的人了，还不老吗？”我们都笑了笑。 可是，我心里很清楚，我只是随着时间的流逝，外貌越来越成熟，声音越来越低沉，我越来越不像小时候的自己，倒是越来越像小时候我们眼中的成年人，无论怎样，都只是外表的像而已，真正的成长是心智和外表的一同成长，而在我内心里，仍有一颗不安分的心，想要去流浪，想要去闯荡，想要去大声歌唱，想谈一场不分手的恋爱….内心的躁动终究敌不过残酷的现实问题，看着周围的朋友成双成对，自己依旧孤单一个，别人开个私家车上班、去旅游，自己却挤着地铁公交，赶着朝九晚六，光是想想就不禁内心发酸，可以说现在是一无所有，唯一还留着的，估计也就是那颗不安于现状躁动的心，以及只有自己才知道的可怜的梦想了。 时间总是无情的，谁也逃不了，还没年轻过我们就老了。现在唯一能做的，就是守护好这颗躁动的心和孤独的梦想，不要让它们随着时间而慢慢消失殆尽。"},{"title":"【随笔记】- 陪你度过漫长岁月","permalink":"http://zhongzilu.github.io/2017/04/15/【随笔记】-陪你度过漫长岁月/","text":"【随笔记】- 陪你度过漫长的岁月 我每天都会在网易云听音乐，因为不只是听音乐，还能看到一些网友的故事，或者是比较有感触的句子。其实，感动我们的并不是歌本身，而是歌背后的故事。"},{"title":"【随笔记】- 第1记","permalink":"http://zhongzilu.github.io/2017/04/15/【随笔记】-第1记/","text":"【随笔记】 - 第1记 别为了不属于你的观众，演绎你不擅长的人生，反正谢幕后的每次相逢，都有我捧着鲜花，把你拥入怀中，再见！"},{"title":"失落(续)","permalink":"http://zhongzilu.github.io/2017/04/15/失落-续/","text":"失落（续）今天是2017年4月15日星期六，昨晚失眠了，直到凌晨三四点钟都没睡着，也许是我太患得患失，亦或者是太过敏感，脑海里总是回荡着一些声音，那些声音一直吵个不停，吵个不停，吵个不停，吵得我烦死了。。。。。。。。真想用一把铁锤砸开我的头，看看里面到底发生了什么，我很讨厌现在的这种状态，脆弱、敏感、无助、情绪化、反复无常，天啊，谁能告诉我，我到底该怎么做才能摆脱这种状态。。。。。。。。。。。。 我不断地提醒自己，冷静冷静再冷静，放轻松就没事了，可越是这么做情况就越糟，就快要完全失控了，就连现在在写到这里，我都花了好长时间，大部分时间都花在了让自己冷静下来，好继续写下去。 （时间过去了30分钟。。。。。） 我一直在想我要怎么表达出我现在的那种感觉，可我知道我自己的弱项就是表达和表现自我，这是我最不擅长的，可我现在却要让自己把内心里的想法和想说的话表达出来，简直太难了，太难了，太难了，这题我不会做啊！！！ （时间又过去了10分钟。。。。） 好吧，现在好像是该说说是怎么回事了。昨天晚上我发消息给燕子，打算叫她一起去看《速度与激情8》的首映，以下是聊天内容。 昨晚我没去看首映，我不知道说什么好，也不知道当时应该怎么做，我当时真想对燕子说：“如果有人能代替你去的话，那我就不会找你了。”我希望她能明白。"},{"title":"失落","permalink":"http://zhongzilu.github.io/2017/04/15/失落/","text":"失落今天是2017年4月14日星期五，我的心情如同今天白天的太阳一样热烈，也如同今晚的天空一样晦涩朦胧，太大的心情反差差点让我难以自救。 在2017年4月10日这一天，也就是这周的星期一，…………………………. 太晚了，再加上有点累，心情有点失落，还是等心情好点的时候再补充吧，今晚就这样。。。。。"},{"title":"再次相遇","permalink":"http://zhongzilu.github.io/2017/04/14/再次相遇/","text":"再次相遇今天是2017年4月13日星期四晚上23:20分，今晚我准时去赴了约，我穿着一件纯白色的衬衫，外加上一件酒红色的T恤外套，衬衫只露出了白色的衬衣领子，我敢肯定绝对有点文艺范儿。 在去赴约的路上，燕子发消息来说她待会儿会带她闺蜜一起去，顺便认识一下，我想这再正常不过了，我当然说好啊，心里还有点窃喜，心想这是表明我和她之间的关系更进一步了吗？ 我到了约定地点后就给燕子发消息说我到了，问她在哪儿，她说她马上就到，于是我就在那儿等着。等她们到了之后就骑着摩拜单车前往目的地公园了，骑行的路上有说有笑的。 天色渐渐的变黑了，我们到了公园之后才发现，人群并没有减少，相反更多了，可能是因为今天天气太热（今天白天最高温度25摄氏度），大家都想晚上出来凉快凉快的原因吧。 我们骑着自行车穿行在人群中，由于天色暗了下来，人群又多，考虑到燕子说她的骑行技术不太好，于是我把手机的闪光灯打开来照明前行，她看见我单手骑车，她说她还不能单手骑，说完就试了一下，她差点摔倒，我赶忙叫她不要试了，免得出意外，结果她又说我乌鸦嘴，我真是哑巴吃黄连，有苦说不出啊！ 最后我们围着公园转了一圈，在一条人少路宽的道路上慢慢骑行，这时燕子和她闺蜜开始尝试单手骑车，不过都持续不了1秒，看着她们当时的样子，给我的感觉就是很纯真，就像两个十一二岁刚学骑车的小孩，那样活泼可爱。 从公园出来之后我们直接去燕子住的地方附近吃东西，先是吃烤面筋，之后再去吃的米粉，烤面筋的还是燕子的闺蜜请的（ ^_^ ），说实话，她的有些细节做的比我还好，比如：1.她叫老板烤面筋时不知不觉就把钱付了；2.她特意叮嘱老板有一串面筋少放辣，我当时以为是她不能吃辣，结果她把那串没辣椒的烤面筋给了燕子，说燕子不吃辣，这着实让我惊讶了一番；3.当我吃完了烤面筋之后，她轻轻地从我手里拿走竹签，然后扔进了垃圾桶，我当时还没反应过来。说来真是惭愧啊，我居然连个女子都不如。 吃完米粉之后，我们就散散步准备回家了，先是送燕子闺蜜到她住的小区路口，我们就挥手道别，燕子住的小区离她闺蜜的小区不远，于是我就送燕子到小区门口，我想毕竟第一次约会，送她上楼可能不太好，而且说不定还有她室友在，所以我就没提出要送她上楼，我就在小区门口找了一辆摩拜单车，和燕子再三道别之后骑车而去了。 我回到住处后又和燕子聊了一会儿，聊的过程中我问燕子，说我注意到她今晚一直都绷着嘴唇，问她是不是感到有点紧张，她回答说没事儿，习惯了。我也就没多问了，然后道了晚安就结束了谈话。 最后说点其他的吧，谈谈在这过程中给我的感觉。这次游玩总的来说是很和谐融洽的，给我了留下了深刻的印象，不过有两个地方不太好，其一，燕子说她要带闺蜜，这一点我没意见，不过从消息内容上来讲，感觉是想把她闺蜜介绍给我的意思，而且在游玩过程中，她闺蜜表现出更多的积极性，相反，燕子却不怎么积极，全程基本都没主动和我说过话，更多地都是主动和她闺蜜的谈话。另外，她还多次夸奖她的闺蜜，比如说她闺蜜比她漂亮，骑车技术比她好，方向感比她强….试问，如果你是个女生，你在面对自己喜欢的男生面前会使劲夸奖其他女性吗？所以我可以初步猜测燕子其实对我没什么感觉，但又不想直接拒绝我，所以采用委婉的方式，真是体贴啊！其二，她闺蜜在游玩过程中问我的身高问题，其实我并不忌讳这个问题，而且之后还和燕子的闺蜜对比了一下身高，这也没什么，我不明白的是，身高其实很容易看出来的，没必要对比，如果你真的很在意男女之间的身高差的话，你可以直接说出来，男生自己心里会掂量的，采用直接说出来的方式我觉得是最好的，因为这既能表明你的条件，也可以避免因对比之后可能产生的尴尬场面。其实，男生一般不怎么在意自己的身高，除非他真的有点矮。"},{"title":"相约","permalink":"http://zhongzilu.github.io/2017/04/13/相约/","text":"相约今天是2017年4月12日星期三，晚上我紧张万分地打开微信，找到昨天那个女生的微信号开始聊天（一下简称燕子），互相询问了各自的兴趣爱好，也根据这些话题聊了很多，聊到最后，我问燕子有没有晚上骑车到附近的公园逛过，她说没有，她还说她的骑行技术不太好，担心人多会出事，联想到昨天发生的事情，我想她应该是一个比较胆小的女生，并且还有点不自信。于是我说我们可以晚点，晚点的话公园的人少，就不会有什么问题，她也同意了，于是，我们就约好明天下午7点在XXXX地见面，然后一起骑摩拜单车前往附近的公园。 聊天结束后，一想到明天就要再次见面，我就有点莫名的激动，同时也有点担心，脑海里一直在想：明天我要穿什么衣服去呢？我是否要准备什么话题？将什么话题才不会尴尬呢？如果冷场了怎么办？…… 说实话，不是自夸，我觉得我是一个胆大心细的人，而且即使是在陌生的环境当中，我也能保持沉着冷静，但此时我觉得自己就像一个情窦初开的小女生，有点畏手畏脚，总担心这儿担心那儿，其实我很讨厌这种感觉，但我也说不清为什么会这样。 好吧，静静等待明天的到来，期待着我和她的第二次相遇。"},{"title":"相遇","permalink":"http://zhongzilu.github.io/2017/04/10/相遇/","text":"相遇今天是2017年4月10日星期一。根据驾校教练的安排，我和我一个老朋友（以下简称小兰）在早上十点，在约定地点上了教练的车并前往驾校学习科二的考试内容。上车时发现一同练车的一位女学员，当时也没多想什么，我就只是在玩手机。 来到驾校之后，我第一个学习考试内容，其次是小兰，我们都是初次学习，学习进展得很顺利，我和小兰都很快掌握了考试内容，接着就是坐我旁边的那个女生学习了，我这人平时很喜欢开玩笑，特别是和小兰在一起的时候，我俩总是互相嘲讽，于是，我习惯性地以开玩笑的语气对那个女生说：“开车一定要小心，我们都还坐在车里呢。”其实当时教练正坐在车的副驾驶位置，我想有教练在也不会有什么问题，毕竟我和小兰都掌握了。 过了一会，在一个下坡路时，突然车就剧烈抖动了一下，然后教练开始责备那个女生，我当时由于还在走神儿，一时间还没反应过来发生了什么，等我缓过神来后我就朝车窗外看，原来车的前轮侧边撞上了坡道的砖护栏，由于是烂砖头，所以把车轮的侧面划了一道口，车轮正在漏气，我们被迫停止练习。这时小兰就开始责怪我说我乌鸦嘴，那个女生站在一旁一言不发，像犯了错误害怕父母责怪的小孩，估计她心里一定很难受很害怕，我看当时场面也挺尬尴的，于是想缓解一下气氛就说：“都怪我，都怪我这张乌鸦嘴，早知道我就不说那句话了。” 好在练车的地方正好有个修理店，店员看见我们的车除了问题就急忙过来看怎么回事，按照店员说的，轮胎侧面划破了就只能更换轮胎，根本没法补，于是教练拿出后备箱的备胎开始更换，我趁着正在换轮胎的时间，就靠近了那个女生，想要安慰一下她，就说：“这个教练挺好的，很好说话，没事儿的，这件事他不会责怪你的，你不要害怕，这件事都怪我，怪我乌鸦嘴。”她也没说话。 事后她坐在车里也不敢再练车了，她说她很害怕再次出事，我说：“不要怕，只不过是一次小事故，后面还有科三科四的要学，难道你就不算继续学下去了吗？交了这么多钱，不学了岂不可惜了。”这时教练也说：“不要怕，我不会让你负责，毕竟我还坐在车上，教练在车上出了事算教练的责任，你放心练。”那个女生这才愿意继续练习。 中午我点了四份外卖，我们四个人一起吃饭，下午又轮流练习，练了一整个下午的时间，期间相处也挺融洽的，只不过我大部分时间都坐在后座上看我的《科幻世界》那本书。 大概下午7点过，练习结束了，教练送我们到早上上车的地方，快要下车时，那个女生主动问我的微信号，说想把中午的饭钱给我，我就笑笑说：“算了，这次算我请你们吃的，不用给我。”但她依然要，看她倔强的样子总让我想起什么来，于是我们互相加了微信就道别了。 我和小兰下了车，那个女生没有下车。正当我准备骑一辆摩拜单车时，小兰突然问我：“嘿！小子，你看那个女生怎么样啊？”我说：“还可以。”小兰：“什么还可以，看你小子加微信那么利索，比我还快一步”。（这里说明一下，其实小兰有女朋友的）我说：“那是她想把中午饭前给我，又不是我主动找她要的。”小兰：“你看她，当你女朋友怎么样啊？”我笑而不语小兰：“如果喜欢就赶紧下手，你也是该找个女朋友了。”我心里想“这事儿你比我妈还操心(～_～)||” 我回到家后确实也找那个女生聊了聊，问了问她的情感状态，她说她单身，这表明我是有机会的，我当时很高兴，高兴地有点语无伦次，今晚，我们聊得很开心，至少我是这么觉得的。 今天，在我的预想之中应该是一个很平常的一天，不知道是上天的馈赠还是命运的安排，让我的这一天有了一丝与往常不一样的色彩，一个意外，让我在我渺小的生命旅途中遇见了一个人，又一个意外，让我和那个她有了那么一丝交集。 这是我们的第一次相遇，也不知道接下来是否还有相遇。"},{"title":"【观后感】- 攻壳机动队","permalink":"http://zhongzilu.github.io/2017/04/08/【观后感】-攻壳机动队/","text":"【观后感】- 攻壳机动队"},{"title":"【评头论足】-第1次","permalink":"http://zhongzilu.github.io/2017/04/01/【评头论足】-第1次/","text":"【评头论足】-第1次 一个愤世嫉俗的程序猿，面对各方压力，依然淡定自如，看似云淡风轻，轻描淡写，实则是经历波澜之后的内心平静。他不需要向别人证明什么，只是随着他的性子做着自己喜欢的事情罢了。"},{"title":"内心里的英雄梦-英雄本能","permalink":"http://zhongzilu.github.io/2017/04/01/内心里的英雄梦-英雄本能/","text":"内心里的英雄梦 - 英勇本能每个人都渴望成功，渴望成为英雄，人类的英雄本能会利用我们不甚了解的方式保护自己，捍卫利益，具有表演型人格是一种英雄本能的投射，拥有同理心和强烈的荣誉感，也因为骨子里埋藏着深深的英雄情节，人们很容易爱上满足自己英雄情节的人，同时，人也具有要面子的天性。 每个人都渴望做西西弗斯，英雄梦是人类的本能，每个人都渴望成功，渴望能够主宰一切，就像希腊神话中的人物西西弗斯一样，西西弗斯是柯林斯的建立者和国王，他甚至一度绑架了死神，让世间没有了死亡，最后，西西弗斯触犯了众神，诸神为了惩罚西西弗斯，便要求他把一块巨石推上山顶，而由于那块巨石太重了，每每还没推上山顶就又滚到了山底，前功尽弃，于是他就不断重复，永无止尽地做这件事，诸神认为再也没有什么比这种无效无望的劳动更严厉的惩罚了，西西弗斯的生命就在这样一件无效无望的劳动当中慢慢消耗殆尽。 人类如此，鸟群也一样。春天的燕子不知从何而来，或许是刚刚成年的新燕成家立业，或是楼去巢不在的老燕乔迁新居吧，从遥远的澳大利亚或者南非飞到这里，小燕子不顾旅途劳顿，来到这片新地方就开始忙碌地盖起了新巢，它们看上了一楼厅堂的电线接头处，啄来泥土，迫不及待地动工，叽叽喳喳好热闹，看小燕子纤纤细身一张小嘴，它们的工作效率一点也不马虎，在短短两天巢就有了雏形，这应该是对它们勤劳的最好回报吧。 小燕子们欢快的在巢旁的电线上追逐嬉戏着，仿佛在庆祝它们的工作硕果初成，可是，后来的事情着实令人悲伤。有一天，鸟巢不幸坍塌了，让人深为燕子夫妇惋惜，它们却表现得相当平静，只是衔来泥土默默地修复，然而每当小巢有了一定规模之后，却总是莫名其妙的坍塌，小燕子只能再次重头开始，周而复始，一个多月过去了，尽管燕子夫妇仍在努力，但墙上仍旧是一滩泥斑，燕子是自然界最好的建筑工程师，怎么能让这种事发生呢，观察燕子夫妇垒巢的细节，我们终于找到了症结，巢穴连着那根电线，正是燕子夫妇啄来泥土后休息嬉戏之所在，而他们在电线上的奔来跳去，最终导致巢穴坍塌，这么一个简单的原因，就让可怜的燕子陷入周而复始的痛苦，而它们竟然还毫无知觉，替燕子惋惜的同时，不禁让人陷入沉思，这忙忙碌碌，却一次次无功而返的燕子不正是那希腊神话里的西西弗斯，以及我们的写照吗？在整个生命延续的时间里，西西弗斯都在与那个巨大的顽石作斗争，无数次他看见自己孤独的脚印，却永远只能承受巨石推而复坠的后果，而我们每个人又都是另一个意义上的西西弗斯，在这个喧嚣又寂寞的世界里，终日为生计奔波劳碌着，明知死神终有一天会带走我们，却又不得不忍辱负重，奔忙在这个世上，日复一日，年复一年，我们不断承受着痛苦挫折，却没有另一个幸福快乐的世界可去，只能反反复复被动的承受着，以为是在不断的上升前行，实际是没有找到正确的道路，用巧妙地最适合自己的力气，只是在做着简单的无用功，急功近利，只想获得世俗的成功，却忽视了心灵的成长，充当了世俗的英雄，却成为了自己心灵的懦夫。 或许，我们每个人都是西西弗斯，生活是痛苦的永乏，却被我们当成荒谬的快乐，以满足我们心灵深处所谓的英雄本能。"},{"title":"醉翁之意不在电影","permalink":"http://zhongzilu.github.io/2017/03/11/醉翁之意不在电影/","text":"醉翁之意不在电影有这么多人，为了看电影，而不得不与陌生的彼此，紧紧把身体靠在一起，默默的坐在黑暗中。每次心中浮现这个景象，就只想把眼睛转开，不要面对。 看电影的辛酸，很少有人揭穿。 在电影的放映史上，有过这么一群笨蛋，千辛万苦的发明了白天在室外放映电影的方法，因为他们坚持，很多人一起坐在黑暗中看电影，是不道德的事。 真够笨！！在笨蛋界的排行榜上，虽然当不了冠军，但名次也靠前面的了。 白日放映术？即使是为了打发坐在马桶上的时光，也不必想出这么无聊的事情来做吧。 他们根本搞不清楚，走进电影院去的人，有多少人是为了那个电影，然后有多少人是为了那个黑暗？ 因为黑暗的庇护，看电影的人，平常不敢放肆大笑的，放肆大笑了。平常不敢放肆大哭的，放肆大哭了。 在人生里假装矜持的，假装有品味的，假装勇敢的，假装男人气女人气的，俱都仰赖著黑暗的庇护，得到了两小时的假释。 不像在明亮的饭桌上吃晚饭时，电视新闻一但播出了饥民在排队，就必须露出不忍心的表情；一但播出了残暴的镇压，又必须露出谴责的神色；连吃一顿饭，都不能很漠然的像有四个胃的牛那样静静吃完，一切都只是为了同饭桌的亲爱家人，在明亮的灯光底下，会看见自己的脸哪。 然而，以这样的角度来看待电影院的黑暗，毕竟只能看见那个黑暗的表层罢了。 电影院的黑暗，庇护的不仅仅是我们道德上的羞耻。 电影院的黑暗，庇护的是我们人生的羞耻：我们的寂寞。电影院，与其说是放映电影的场所，不如说是献祭寂寞的神庙吧。一个人进来的，怀抱著一个人的寂寞；两个人进来的，怀抱著两个人的寂寞。 无话可说的情侣，无恋爱可谈的配偶，无法沟通想法的父子，无能教与无能学的师生，都怀抱著他们那份自己日夜呵护珍贵却又不值一文的寂寞，进来了。 像圣经与佛经里，那些一无所有的信徒，把仅存的财产放在坛前：“……这，就是我的全部了……” 而神只便因此垂怜了你，抚慰了你，两个小时。 我在人生里，遇到过一些精采的人。从来没有一个，是因为看了很多电影，而变得精采的。可能有些本来就很精采的人，刚好也看过很多电影。可是从没有一个，是因为看很多电影，而成为精采的人。没有，也不可能。 就像精采的诗人，可能刚好也喜欢嗑迷幻药，可是没有烂诗人能靠著多嗑药，而写出精采的诗来。电影院的黑暗，不是建筑物创造的黑暗，而是观众带进场的黑暗。 是人生的寂寞，与生俱来的肤色。 下次到迪士尼乐园去看立体电影，当大家都乖乖把立体镜片带上，伸出手去捕捉他们以为浮在眼前的人物的时候，你可以偷偷把眼镜拿下来，然后你也伸出手去，你就会摸到那个黑暗的看不见的，寂寞的身体。 来源: 蔡康永短篇集作者: 蔡康永"},{"title":"面试有感","permalink":"http://zhongzilu.github.io/2017/03/10/面试有感/","text":"面试有感@(标签)[面试，2017-03-10，钟子路，bit100] 今天去天府三街C7区的天软信息公司面试，刚进入到公司时给人的感觉是比较严肃和严谨，因为公司不同部门在不同的区域办公，员工都是坐的格子间，也很安静，这是我的第一印象。 我随着HR来到公司里面的技术部门的一个会议室坐下等技术面试官。在等待的时间我大致观察了一下会议室的摆设，10张凳子，1张长桌，桌上有1个投影仪，1个笔筒，笔筒里有3支马克笔和2支中性笔以及1块黑板擦，还有1个不知做什么用的设备，有点像大型的路由器，但肯定不是路由器，因为上面有很多按钮。我坐的身后的墙上有块玻璃板，其他墙面没有投影幕布。其中投影仪的串口线头指向我坐的位置，因此我猜测平时开会，要做技术讲解或演示的人就坐我正在坐的位置，用马克笔在我身后的玻璃板上写重点，投影仪投影在右侧的墙上，从黑板擦的使用程度判断开会次数较少，从凳子的摆放来看参会人数一般在5人左右。抱歉！扯远了。。。 技术面试官进来首先打了招呼，接着就开始我一些问题，比如“你印象最深的是哪个项目？”、“你最近的是哪个项目？”、“你在项目中主要负责什么？”等等，然后根据我的回答进行深挖。 从面试官后续的问题大致可以猜出他应该在公司负责底层研发的而不是Android应用层开发，后续的问题也几乎是跟底层原理有关的，比如“蓝牙是通过什么信道进行数据传输的？”、“使用过自定义协议吗？”、“拍摄视频到视频文件中间经过了哪些流程？（其实就是问视频文件的编解码问题）”等等，对于一个处在应用层面的我来说，就是一个丈二的和尚，完全摸不着头脑，我立马就感觉没戏了。 后来面试官又问我最擅长什么，我说我会的方面很多，Android、HTML5、CSS3、界面设计、Linux等等，相比较起来更擅长Android开发。接着问擅长Android的什么方面，由于我做过的项目各种类型都有，所以一时间我也不知道我最擅长做哪种类型方面的。面试官告诉我说“ 要找到你最擅长的是什么，然后做最擅长的事情，才能实现你的价值最大化 ”。 经过这次面试，我觉得前面的那些底层问题都不重要，最重要的还是最后那句话。 找到你最擅长的是什么，然后做最擅长的事情，才能实现你的价值最大化 最后说一句，面试官很不错！姓罗，暂且就称呼罗大哥吧，我还留了一个他的电话，( ^_^ )。虽然我与公司有缘无分了，不过依然期待我们下次相遇。"},{"title":"JSON数据结构优化的突发奇想","permalink":"http://zhongzilu.github.io/2017/03/06/JSON数据结构优化的突发奇想/","text":"JSON数据结构优化的突发奇想 @(标签)[数据结构，JSON，数据优化，性能优化，钟子路，zhongzilu，bit100] JSON对于做网络软件开发的人来说再熟悉不过了，大多数开发者都是把数据封装成JSON格式，然后把数据从服务端传递到客户端。 但随着人们对信息的需求越来越多，要传递的数据也越来越大，网络和设备的开销也越来越大，对于用户来说，移动设备上请求大量的网络数据会造成昂贵的流量费用，同时，解析大量的JSON数据也难免会造成移动设备出现卡顿现象，因此，优化JSON数据就是很有必要的事情。 那么，如何优化JSON数据呢？假设这里有个实体类对象 public class Person { private String name; private int age; ······ public String getName(); public void setName(String name); ······· } 以往我们在传递对象集合数据的时候，通常是这样的 { &quot;Persons&quot;:[ {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:16}, {&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:18}, {&quot;name&quot;:&quot;王二&quot;,&quot;age&quot;:17}, ··········· ] } 因为这种方式符合面向对象的设计，同时也很方便封装，由于是通过对象的构造方法实现的，我们暂且称之为对象构造数组。 其实仔细观察分析，这一串JSON数据当中，有很多数据是重复的，比如name，age，不同的只是他们的值 所以，我们其实可以这样来设计JSON格式，如下 { &quot;Persons&quot;:{ &quot;name&quot;:[&quot;张三&quot;,&quot;李四&quot;,&quot;王二&quot;,.....], &quot;age&quot;:[16,18,17,......] } } 相同属性的不同值用一个数组来保存，这样结构更加清晰，且能有效减少JSON的数据大小。 优化过后的JSON数据不仅能节省网络传输时间和网络流量费用，还能根据不同数据类型，采用不同的压缩算法，使压缩算法进行压缩时更加高效，例如GZip算法，同时，还能减少移动设备因解析数据造成的卡顿现象。 就目前看来这种方式只停留在想法阶段，还没有能够实现的解析库供使用，希望有热心人士能开发出一套高效的解析库，将想法变成现实( ^_^ )。 Thanks for watching! 作者：钟子路转载请注明出处：https://zhongzilu.github.io/2017/03/06/JSON数据结构优化的突发奇想/"},{"title":"随手拍分享","permalink":"http://zhongzilu.github.io/2017/02/16/随手拍分享/","text":"随手拍分享 昨天天气不错，就骑着自行车出去散步，然后来到了位于成都的环球中心附近，那里正在打造一个生态公园，名为【桂溪生态公园】。 我沿着一条小河走，河里的水很清澈，可惜没有鱼，这是美中不足的地方。 乘着天气好，阳光也很充足，时而吹点微风，有种春天到来的气息.河水随着微风荡漾起层层涟漪，涟漪反射着阳光，好一副和谐温暖的景象，我忍不住随手用手机拍了一张照片就揣上手机继续沿着河边走。 回来后查看手机里的相片，发现用来做壁纸还挺好看，所以就想分享给大家，下面是效果图： 点击这里下载原图:Wallpaper.zip 作者：钟子路(zhongzilu)原文地址：http://www.bit100.com/随手拍分享/"},{"title":"JS运算规则问题-下","permalink":"http://zhongzilu.github.io/2017/02/16/JS运算规则问题-下/","text":"JS运算规则问题（下） 问题：请回答下图中最后输出结果为什么是false和1？ 想知道第一个输出结果为什么是false，请看这篇文章 http://www.bit100.com/js运算规则问题上/ 二、为什么[]?1:0输出结果为1？想知道为什么输出结果为1，那么需要先弄明白JavaScript三元运算符的实现标准。别怕，抓紧我的手，我带你装逼。 三元运算符的运算规则是先判断问号?左边的表达式为true还是false，如果为true，则输出1，反之输出0。因此先把[]转换成Boolean类型，下面是标准。 很明显，由于[]是数组，类型为Object，因此直接返回true。 所以[]?1:0的输出结果当然就是1了。"},{"title":"JS运算规则问题-上","permalink":"http://zhongzilu.github.io/2017/02/05/JS运算规则问题-上/","text":"JS运算规则问题（上） 问题：请回答下图中最后输出结果为什么是false和1？ 一、为什么[] == true输出结果为false?要想知道为什么输出false，那得先知道==是怎么进行比较的。上图是JavaScript的==操作符的实现标准，意思是在比较的时候，会把左右两边的表达式使用GetValue()进行转换，然后再用两者得到的值进行比较，即图上的第5项。 然后跟踪来到11.9.3章节，内容如下 由于操作符右边的表达式为Boolean类型，所以满足上图中的第7项条件，需要先用ToNumber()方法来把布尔类型表达式转换为数字，我们都知道true转换为数字类型时，值为1。 然后左边的表达式是数组，类型为Object，因此满足第9项条件，于是再用ToPrimitive()方法转换左边的表达式。 接下来看看ToPrimitive()因为需要转换的表达式为Object类型，所以采用最后一条规则。转换的结果是通过[[DefaultValue]]获取的Object的默认值。 再来看看[[DefaultValue]]的说明由于对象Object内部的[[DefalutValue]]的hint为String，所以用toString返回值，而数组[]使用toString方法，返回值为&quot;&quot; 所以，一开始的[] == true的比较就相当于是&quot;&quot; == 1的比较，然后再回到一开始的 == 实现标准，即The Abstact Equality Comparison Algoritem章节的内容 这个时候满足条件第5项 需要把字符串&quot;&quot;转换为数字，由于是空字符串，所以转换后的值为0 最终的结果就相当于是0 == 1，我们当然知道这两者不相等，所以返回值为false 不知道各位看官看明白了吗？好了，就讲到这里，第二个请看下面这篇文章 http://www.bit100.com/js运算规则问题下/ Thanks for watching! 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/JS运算规则问题(上)/"},{"title":"一行代码将RecyclerView的指定位置置顶显示","permalink":"http://zhongzilu.github.io/2017/01/17/一行代码将RecyclerView的指定位置置顶显示/","text":"一行代码将RecyclerView的指定位置置顶显示标签 Android RecyclerView scrollToPosition zhongzilu bit100 如果你有需求是将RecyclerView的指定位置置顶，那么这里有个最简单的方法，一行代码搞定，代码如下 private void scrollToPosition(LayoutManager manager,int index){ manager.scrollToPositionWithOffset(index, (int) manager.computeScrollVectorForPosition(index).y); } 其中manager是给RecyclerView设置的布局管理器，index是指定的位置。是不是很简单？ 查看演示视频请到原文地址观看 点击下载源文件：ScrollToPositionTest.zip 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/一行代码将RecyclerView的指定位置置顶显示/"},{"title":"使用FFmpeg合成延时视频","permalink":"http://zhongzilu.github.io/2017/01/16/使用FFmpeg合成延时视频/","text":"使用FFmpeg合成延时视频 玩过延时摄影的童鞋都知道，所谓的延时摄影就是把很多张连续拍摄的照片合成一个视频文件 要怎么把多张图片合成视频文件呢？ 开源免费的FFmpeg是不二之选 使用方法也很简单，只需要在你存放照片的目录下执行以下命令 # -r 帧率，在这里取每秒 24 帧 # -s 视频分辨率，缩放比例与原照片分辨率比例一致 # -i 照片名字的编码格式，我的照片格式是 DSC*****.jpg 五位数字 # -start_number 照片的起始编号 # 最后输入视频名称，在这里是 video.mp4 $ ffmpeg -r 24 -s 1200x800 -i DSC%05d.jpg -start_number 2931 video.mp4"},{"title":"一道腾讯面试题的思考_到底谁会赢","permalink":"http://zhongzilu.github.io/2017/01/15/一道腾讯面试题的思考-到底谁会赢/","text":"一道腾讯面试题的思考_到底谁会赢 最近看到一道腾讯面试题，觉得很有意思。题干如下： 有甲乙两家伙用一个英语单词玩游戏（无聊的人还是很多的！！！）。两个人轮流进行，每个人每次从中删掉任意一个字母，如果剩余的字母序列是严格单调递增的（按字典序a &lt; b &lt; c &lt;….&lt;z，假设单词字母不区分大小写，也就是说，a与A算相等），则这个人胜利。假设两个人都足够聪明（即如果有赢的方案，都不会选输的方案 ），甲先开始，问他能赢么？ 输入： 一连串英文小写字母，长度任意（当然要在计算机能承受的范围内）,保证最开始的状态不是一个严格单增的序列。 输出：1表示甲可以赢，0表示甲不能赢。 例如: 输入 bad， 则甲可以删掉b或者a,剩余的是ad或者bd，他就赢了，输出1。 又如: 输入 aaa， 则甲只能删掉1个a，乙删掉一个a,剩余1个a，乙获胜，输出0。 下面给出我用Java实现的算法，如果大家有其他的实现方法，欢迎跟帖和探讨。语言不限。 我的基本实现思路将给定的单词分成若干个单调递增的序列。然后按每个序列中包含单词个数多少进行递减排序，也就是说，排在前面的单调递增序列中包含的字母个数最少。然后由甲开始从排在前面的递增序列中选择一个字母。直到该递增序列中的字母全部被选中。然后继续从下一个递增序列选择字母。按着这样的方法做，直到剩下最后一个单调递增序列，随最后选择了倒数第二个单调递增序列中的最后一个字母，谁就赢了。 例如，单词hela，可以分为三个单调递增序列：h、a、el。从甲开始选择。 甲：h 乙：a 由于a是倒数第二个单调递增序列的最后一个字母，所以乙赢了。 对于单词money可以分成三个单调递增序列：mo、n、ey。排序后：n、mo、ey。 甲：n 乙：m 甲：o 所以甲赢。 具体的实现算法如下： public class Test { // 实现算法的方法，in为一个给定的单词 public static int who(String in){ // 基本思路就是找到该单词中所有递增的子序列， // 然后从字符最少的子序列甲乙轮回删除字母， // 直到还剩下最后一个子序列为止 // 谁删除了最后一个字母，谁就赢了！ // in不能为null if(in == null) return 0; // 单词至少需要有一个字母 if(in.length() == 0) return 0; in = in.toLowerCase(); // 都变成小写字母 // 所有递增数列集合 java.util.List&lt;StringBuilder&gt; ascendingList = new java.util.ArrayList&lt;StringBuilder&gt;(); char lastChar = in.charAt(0); // 存储当前递增的字符列表 StringBuilder sb = new StringBuilder(); sb.append(lastChar); for(int i = 1; i &lt; in.length(); i++){ // 当前字符属于当前的递增序列 if(in.charAt(i) &gt; lastChar){ sb.append(in.charAt(i)); } // 当前字符属于下一个递增序列，所以需要存储上一个递增序列 else { ascendingList.add(sb); sb = new StringBuilder(); sb.append(in.charAt(i)); } lastChar = in.charAt(i); } if(sb.length() &gt; 0){ ascendingList.add(sb); } // 下面就开始游戏了 // 从甲开始删字母，从字符最少的递增序列开始删除第一个字母，直到之后只剩下一个递增序列为止，谁删除的最后一个之母，谁就赢了 // 这里本应该判断如果单词本身就是递增序列，那么甲就win了， // 不过既然题目说没有这种情况，所以就注释掉了 /*if(ascendingList.size() == 1){ return 1; }*/ java.util.Collections.sort(ascendingList, new java.util.Comparator&lt;StringBuilder&gt;(){ @Override public int compare(StringBuilder sb1, StringBuilder sb2){ if(sb1.length() &gt; sb2.length()){ return 1; } else if(sb1.length() == sb2.length()){ return 0; } else { return -1; } } }); int win = 0; // 1代表甲赢，0代表乙赢 while(ascendingList.size() &gt; 1){ if(win == 0) win = 1; // 甲开始 else win = 0; // 乙开始 // 删除第一个递增序列的第一个字母，如果该递增序列 ascendingList.get(0).delete(0, 1); if(ascendingList.get(0).length() == 0){ ascendingList.remove(0); } } return win; } public static void main(String[] args){ System.out.println(who(&quot;money&quot;)); } }"},{"title":"经典面试问题：Cookie被禁用了-Session还能用吗","permalink":"http://zhongzilu.github.io/2017/01/14/经典面试问题：Cookie被禁用了-Session还能用吗/","text":"面试经典问题：Cookie被禁用了，Session还能用吗？ 面试的时候经常被问到Cookie禁用了，Session还能用吗？不同的公司给出的答案也有点不同，到底Cookie禁用了，Session还能用吗？ 默认SESSION配置在默认的JSP、PHP配置中，SessionID是需要存储在Cookie中的，默认Cookie名为： PHPSESSIONID JSESSIONID 以下以PHP为例： 1. 你第一次访问网站时， 2. 服务端脚本中开启了Session`session_start();`, 3. 服务器会生成一个不重复的SESSIONID 的文件`session_id();`，比如在`/var/lib/php/session`目录 4. 并将返回(Response)如下的HTTP头 `Set-Cookie:PHPSESSIONID=xxxxxxx` 5. 客户端接收到`Set-Cookie`的头，将`PHPSESSIONID`写入cookie 6. 当你第二次访问页面时，所有Cookie会附带的请求头(Request)发送给服务器端 7. 服务器识别`PHPSESSIONID`这个cookie，然后去session目录查找对应session文件， 8. 找到这个session文件后，检查是否过期，如果没有过期，去读取Session文件中的配置；如果已经过期，清空其中的配置 如果客户端禁用了Cookie，那PHPSESSIONID都无法写入客户端，Session还能用？ 答案显而易见：不能 并且服务端因为没有得到PHPSESSIONID的cookie，会不停的生成session_id文件 取巧传递session_id但是这难不倒服务端程序，聪明的程序员想到，如果一个Cookie都没接收到，基本上可以预判客户端禁用了Cookie，那将session_id附带在每个网址后面(包括POST)，比如： GET http://www.xx.com/index.php?session_id=xxxxx POST http://www.xx.com/post.php?session_id=xxxxx 然后在每个页面的开头使用session_id($_GET[&#39;session_id&#39;])，来强制指定当前session_id 这样，答案就变成了：能 聪明的你肯定想到，那将这个网站发送给别人，那么他将会以你的身份登录并做所有的事情（目前很多订阅公众号就将openid附带在网址后面，这是同样的漏洞）。 其实不仅仅如此，cookie也可以被盗用，比如XSS注入，通过XSS漏洞获取大量的Cookie，也就是控制了大量的用户，腾讯有专门的XSS漏洞扫描机制，因为大量的QQ盗用，发广告就是因为XSS漏洞 所以Laravel等框架中，内部实现了Session的所有逻辑，并将PHPSESSIONID设置为httponly并加密，这样，前端JS就无法读取和修改这些敏感信息，降低了被盗用的风险。 Cookie在现代禁用Cookie是 IE6 那个年代的事情，现在的网站都非常的依赖Cookie，禁用Cookie会造成大量的麻烦。 在Flash还流行的年代，Flash在提交数据会经常出现用户无法找到的情况，其实是因为Flash在IE下是独立的程序，无法得到IE下的Cookie。 所以在Flash的flash_var中，一般都会指定当前的session_id，让Flash提交数据的时候，将这个session_id附带着提交过去 Chrome中使用 Flash沙箱 已经解决了cookie的问题，但是为了兼容IE，比如swfupload等flash程序都要求开发者附带一个session_id 面试者的用意面试者出此题也是为了考察你对HTTP协议和服务器会话的理解。"},{"title":"Android监听SearchView的展开和关闭事件","permalink":"http://zhongzilu.github.io/2016/12/15/Android监听SearchView的展开和关闭事件/","text":"Android监听SearchView的展开和关闭事件@(标签)[Android，SearchView，监听器，zhongzilu，bit100] 最近在做搜索功能，虽然Github上有很多搜索控件的“轮子”，但我想要简单一点，于是使用了Android的SearchView。 一般在搜索完毕之后，关闭搜索框就应该恢复搜索前的数据，于是想监听SearchView的关闭事件，在关闭的时候进行恢复之前的显示内容。 首先发现有个setOnCloseListener，认为就是它了，结果搞了半天没有反应，然后就去查找原因 1 源码里面，实现setOnCloseListener里的close()法，有一个是清空输入框，也许会和SearchView的setOnQueryTextListener接口onQueryTextSubmit(String query)冲突 2 setOnCloseListener只能在3.2下才能有效，而原生的SeachView 是 (SearchView) menuItem.getActionView(); 那就从menuItem入手，发现了一个设置监听的方法setOnActionExpandListener() 设置监听如下： if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) { menuItem.setOnActionExpandListener( new MenuItem.OnActionExpandListener() { @Override public boolean onMenuItemActionExpand(MenuItem item) { //TODO 展开事件 return true; } @Override public boolean onMenuItemActionCollapse(MenuItem item) { //TODO 关闭事件 return true; } }); } else { mSearchView.setOnCloseListener( new SearchView.OnCloseListener() { @Override public boolean onClose() { //TODO 关闭事件 return false; } }); } 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/Android监听SearchView的展开和关闭事件/"},{"title":"SwipeRefreshLayout进入页面自动刷新","permalink":"http://zhongzilu.github.io/2016/12/14/SwipeRefreshLayout进入页面自动刷新/","text":"SwipeRefreshLayout进入页面自动刷新@(标签)[SwipeRefreshLayout，下拉刷新，Android，zhongzilu，bit100] 通常在使用SwipeRefreshLayout控件的时候，是要通过下拉动作才能显示刷新动画和触发监听器SwipeRefreshLayout.OnRefreshListener的onRefresh方法。 要想一进Activity或Fragment就显示下拉刷新动画，直接调用mRefresh.setRefreshing(true)是不会有刷新动画的。 可以使用以下方法 mRefresh.post(new Runable() { @Override public void run(){ mRefresh.setRefreshing(true); } }); 要关闭刷新 mRefresh.setRefreshing(false); 不过，上面的方法是不会调用刷新监听器的onRefresh()方法的 要想一进入Activity或Fragment就显示刷新动画，并且调用刷新监听器的话，需要手动调用 OnRefreshListener listener = new OnRefreshListener(){ public void onRefresh(){ //TODO } }; SwipeRefreshLayout mRefresh = (SwipeRefreshLayout) findviewbyId(R.id.refresh); mRefresh.setOnRefreshListener(listener); 在onCreate中: mRefresh.post(new Runable(){ @Override public void run() { mRefresh.setRefreshing(true); } }); listener.onRefresh() 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/SwipeRefreshLayout进入页面自动刷新/"},{"title":"如何在Windows或Linux-Ubuntu下开启和关闭PHP的错误显示功能","permalink":"http://zhongzilu.github.io/2016/12/13/如何在Windows或Linux-Ubuntu下开启和关闭PHP的错误显示功能/","text":"如何在Windows或Linux(Ubuntu)下开启和关闭PHP的错误显示功能@(标签)[Windows，Linux，Ubuntu，PHP，zhongzilu，bit100] 写过PHP程序的人都知道，要想知道自己写的PHP代码有没有问题，只有运行的时候才知道，这对于编写代码阶段很是繁琐，而且很多时候在自己的测试环境下没问题，放到真实环境的时候就出问题了，特别是有了一定用户之后，突然某天出问题了，用户看到的就是一个错误显示页面，这样的用户体验很不好。 要想解决这样的问题，最好的方式就是打开PHP的错误和警告提示。 警告!!：最好是在开发阶段和测试环境下启用，在正式环境下关闭或者将错误记录到日志 如何在Windows环境下开起PHP的错误显示？如果你是Windows平台，你只需要找到php.ini这个文件，通常这个文件就在你安装的Apache服务器的根目录下，如果你使用的是其他服务器，你可能需要搜索该文件 1.打开php.ini，利用查找功能找到以下代码 display_errors = Off 2.将它替换成 display_errors = On 保存文件之后，重启你的Apache服务器或其他的服务器，这就完了。 ####如何在Linux(Ubuntu)环境下开起PHP的错误显示？如果你是Ubuntu或Linux用户，同样是找到php.ini文件，通常会在/etc/目录下，然后就是查找和替换，方法和在Windows下一样 最后通过命令重启服务器，比如Apache服务器： sudo service apache2 restart 如果是nginx服务器 sudo service nginx restart 这就完了！如果你依然没能解决问题，请移步到这篇文章 开启PHP错误提示 — BIT100 我是Zhongzilu，Thanks for watching!"},{"title":"开启PHP错误提示","permalink":"http://zhongzilu.github.io/2016/12/13/开启PHP错误提示/","text":"开启PHP错误提示@(标签)[PHP，错误提示，zhongzilu，bit100] 想要在代码中显示PHP的错误提示吗？这篇文章应该对你有帮助 想要开启错误报告和警告功能，只需要在PHP标签中加上以下代码： error_reporting(E_ALL^E_NOTICE); ini_set(&#39;display_errors&#39;, &#39;On&#39;); 以上代码只是显示错误和警告，并没有建议提示，要显示所有的错误，只需要去掉E_NOTICE error_reporting(E_ALL); ini_set(&#39;display_errors&#39;,&#39;On&#39;); 如果你仍然不能显示PHP的错误提示，请移步到下面这篇文章 如何在Windows或Linux(Ubuntu)下开启和关闭PHP的错误显示功能"},{"title":"CentOS升级php5.3到5.5","permalink":"http://zhongzilu.github.io/2016/12/09/CentOS升级php5-3到5-5/","text":"CentOS升级php5.3到5.5@(标签)[Linux，CentOS，PHP，5.3，5.5，zhongzilu，bit100] 比特壹佰（www.bit100.com）使用的是Wordpress博客平台搭建。最近在后台升级了一下SEO插件，结果不能用了，提示我的PHP版本过低，要求是PHP版本必须为5.4以上，于是我就开始升级PHP的操作了。 由于yum仓库中的PHP版本最新为5.3.3，所以需要使用其他的源 安装Webtatic EL6 YUM源 rpm -Uvh http://repo.webtatic.com/yum/el6/latest.rpm 在安装新版本PHP前，需要先移除原来的PHP(在移除前，请确保你知道你对PHP做过哪些特殊配置，最好先备份一下配置文件) yum remove php* 然后安装PHP5.5版本，输入命令 yum install php55w 安装好后可以查看一下版本 php -v 然后安装常用的工具 yum install php55w-pear php55w-odbc php55w-pdo php55w-gd php55w-mysql 查看自己安装了哪些PHP相关的包 rpm -qa |grep php* 到这里PHP就已经升级完了，现在最新PHP版本是PHP7，升级PHP7得小心，可能会遇到很多坑，别问我为什么。Thanks for watching。 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/CentOS升级php5.3到5.5/"},{"title":"如何更改linux超级用户密码","permalink":"http://zhongzilu.github.io/2016/12/09/如何更改linux超级用户密码/","text":"如何更改Linux超级用户密码标签 Linux 超级用户 root zhongzilu bit100 要更改Linux超级用户的密码很简单，不过这样做很危险，建议修改为较为复杂的密码或者使用su root命令来使普通用户临时拥有超级用户的权限 直接在命令行里输入 sudo passwd 然后输入你的登陆密码，之后会提示输入新的UNIX密码，你就输入你想要修改的超级用户密码 之后提示重新输入新的UNIX密码，你再重复输入刚才输入的UNIX密码 之后会提示确认UNIX密码，你再重复一遍就可以了。 例如： zhongzilu@Ubuntu:~$ sudo passwd [sudo] password for zhongzilu: 输入新的UNIX密码： 重新输入新的UNIX密码： 确认输入新的UNIX密码： passwd:已成功更新密码. zhongzilu@Ubuntu:~$ 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/如何更改Linux超级用户密码/"},{"title":"如何在Linux-Ubuntu上安装PHP-MySQL-Apache-LAMP","permalink":"http://zhongzilu.github.io/2016/12/09/如何在Linux-Ubuntu上安装PHP-MySQL-Apache-LAMP/","text":"如何在Linux/Ubuntu上安装PHP，MySQL和Apache（LAMP）标签 Linux Ubuntu PHP MySQL Apache zhongzilu bit100 如果你是Linux新手，想在Linux上安装PHP、MySQL、Apache，最简单的方法就是通过命令行安装，命令如下： 1.安装Apachesudo apt-get install apache2 启动Apachesudo /etc/init.d/apache2 start 停止Apachesudo /etc/init.d/apache2 stop 重启Apachesudo /etc/init.d/apache2 restart 2.安装PHP5sudo apt-get install php5 libapache2-mod-php5 3.安装MySQL服务端sudo apt-get install mysql-server 4.检查以上都安装完后，重启Apache服务器 sudo /etc/init.d/apache2 restart 然后打开浏览器，在地址栏输入：http://localhost，之后你应该会看到It works的字样，这就表示Apache服务器没问题 现在来检查PHP，默认情况下在命令行中输入 cd /var/www 然后将index.html文件更改为index.php mv index.html index.php (注意中间的空格) 然后编辑index.php文件，输入如下代码：(编辑的方法有多种，vi/vim/gedit等命令都可以,请自行搜索) &lt;?php echo &quot;Hello Word!&quot;; ?&gt; 最后再打开浏览器，在地址栏输入：http://localhost，之后如果看到Hello Word!字样就表示PHP安装成功了。 是不是很简单，开始你的项目吧！ 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/如何在Linux/Ubuntu上安装PHP,MySQL和Apache(LAMP)"},{"title":"如何在Linux-Ubuntu上运行.chm文件","permalink":"http://zhongzilu.github.io/2016/12/09/如何在Linux-Ubuntu上运行-chm文件/","text":"如何在Linux/Ubuntu上运行.chm文件标签 Linux Ubuntu .chm zhongzilu bit100 如果你想要在Linux或Ubuntu系统上运行.chm格式的文档文件，你可算来对地方了。很简单，你可以直接在Ubuntu的软件中心里搜索xCHM，然后安装。或者你也可以使用命令行的方式： sudo apt-get install xchm 现在你就可以打开.chm格式的文档文件了。另外，还有其他的软件也可以，比如：ChmSee、GnoCHM、CHMViewer等，安装方法都是差不多了，你现在就可以去试试了。 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/如何在Linux/Ubuntu上运行chm文件/"},{"title":"1024程序员节-向改变世界的程序员致敬","permalink":"http://zhongzilu.github.io/2016/10/24/1024程序员节-向改变世界的程序员致敬/","text":"1024程序员节，向改变世界的程序员致敬标签 1024 程序员节 程序猿 2016-10-24 zhongzilu 钟子路 写在前面正值1024程序员节日来临之际，今天心血来潮，想写篇文章来为我们这些猿猿致敬，也算了却一个心愿，让我们这些猿猿们以自己从事的职业为豪为荣。 可能我们的着装遭人吐槽，可能我们的玩笑经常别人听不出笑点，可能我们心照不宣的执着外人觉得莫名其妙，可能我们的举止身边的人觉得实在无趣，也可能我们在如今互联网火热的时候略带优越感的表象让人们越来越觉得我们是异类生物。。。 但即使是这样，我希望你们对我们猿猿的态度是：“即使你不了解我们在做什么，但你们还是爱我们”。出于这种情结，我是程序员，我要为自己和猿猿们带盐！ 1.我们的着装我们最常被吐槽的就是我们的穿着了，套头衫＋牛仔裤，最后再来个夹角拖鞋就齐活了。这是我们特立独行的标配，如果没有特别要求，请允许我们这样穿着，我们觉得会休闲自在，工作也会更有激情。 一个牛逼的程序员是根本没有时间打理自己外貌的。发型就要像爱因斯坦一样，顶着一脑袋鸡窝，凌乱蓬松美，给人随时能从头发里掏出一个鸡蛋的感觉。胡子一大把，彰显自信又从容，不近视则以，近视就要戴酒瓶底子那么厚的大眼镜，一种科研工作者的风格。 2.我们善于学习我们总是喜欢学习、尝试新事物，我们求知的欲望是相当强的。在互联网这个行业，技术的更新迭代速度很快，唯有不断学习和尝试，我们才能立于不败之地，人都是做自己原本不能胜任的事情中，才能快速成长。所以，不要让任何事情成为你不去学习的理由！，你学过的每一样东西，都会在你一生的某个时候派上用场的。 3.我们善于解决问题我们每天打交道最多的就是bug了，bug虐我千百遍，我待bug如初恋。也许是解决问题后的满足感，正是因为这样，我们解决问题的能力超乎你想象。 4.我们很单纯我们是一群单纯而又善良的猿。我们“只对技术不对人”，而且反驳对方观点，都是比较幽默的，不会“出口成脏”的。我们会不厌其烦地为客户改需求，改bug，相对于其他行业，我们少了勾心斗角，多了真诚，领导什么的也比较随和，工作氛围也比较自由。 5.我们喜欢聆听我们的大脑常常高速运转，这是好事也是坏事。好的一面是，我们可以听你讲你的问题好几个小时，坏的一面是我们常常走神，因为我们在想如何解决你的问题。但是起码，我们是喜欢聆听的。 6.我们很有创造力我们是一群富有创造力的猿，爱编程，爱晚起，偶尔也忙到深夜喜欢学习，努力工作，享受生活酷爱技术，创造出了一个又一个奇迹。大家玩地不亦乐乎的lol，改变世界交流方式的Facebook，亦或是让你足不出户就可以订餐或淘宝的软件都是出于我们的创造力，总之，我们为世界创造的价值。(猿们，感觉我越写越傲娇了) 7.我们善于分享 编程夜当午，手握小滑鼠。谁知编程辛，行行皆“心”苦；头昏不觉晓，使劲揉眼角。夜夜太辛苦，睡眠知多少； 即使这样，我们还是乐此不疲地分享我们幸幸苦苦研究的成果，各种开源社区，博客都成为我们的常驻地。技术源于分享，当然，我们也会分享生活趣事，正是因为我们的无私，社会才会进步的更快。所以，建议大家开通博客之类的写点什么吧，好记性不如烂笔头，一来可以督促自己，二来锻炼自己表达能力，三来分享给别人。 8.我们很细心编译，调试，再编译，再调试，功能跑通，SVN提交代码（地震火灾，世界末日，也一定要先提交代码再行离开），绝对不能让程序出乱子，没错，我们是一群细心的猿。 9.和我们约会的好处 优点1：我们不会骗人；没有时间去拈花惹草，当然陪你的时间会相对少点。优点2：我们很聪明，超级聪明。优点3：惹你生气还请包容。优点4：我们不会 bug 你，我们只会用一整天的时间debug代码。优点5：我们会多门语言，是不是很好厉害！优点6：当我们邀请你把玩我们的“小玩意”……你可别想歪，我就是想让你玩我儿时的小玩具，我们是一群可爱 又单纯的程序员。优点7：拥有自己的活动空间，只要给我一台电脑，我从不干涉你的生活。优点8 ：…… 10.活捉程序员的技巧 取萌妹纸饵料一只，放于程序猿经常出没的场所，待引起其注意后，掉头就跑，单纯的程序猿会紧跟着跑来，偶尔回头注意其动向，伺机将其捕获。如遇到挣扎可用亲吻麻痹之。 程序猿日常饲养比较简单，要求猿舍温暖，通风干爽，对猿舍网络状况要求较高。每日以适量萌饲喂之，注意取得程序猿的信任，培养感情，每周可适当带出门散步，程序猿对运动没有特殊要求。 不过需要特别注意的是,一次只能饲养一只程序猿,不要与其他萌妹纸一同饲养 11.值此1024程序员节，我们的愿望作为一枚用代码改变世界，用智慧颠覆未来的程序员，居然还要加班加点透支生命？NO！我们应该给自己更多的关怀 ，1024这一天，我们应当放假或者拒绝强制 无效率 加班！ 勇敢对一切和加班有关的要求说NO!拥抱女友尽情在游戏的世界里徜徉！早点休息，今天不加班！不晚睡！不熬夜！…… 特别提醒：猿猿们切记不要加班 12.附上程序员装逼指南 一.准备工作“工欲善其事必先利其器。” 1.电脑不一定要配置高，但是双屏是必须的，越大越好，能一个横屏一个竖屏更好。一个用来查资料，一个用来写代码。总之要显得信息量很大，效率很高。 2.椅子不一定要舒服，但是一定要可以半躺着。 3.大量的便签，各种的颜色的，用来记录每天要完成的事务，多多益善。沿着电脑屏幕的边框，尽量贴满，显出有很多事情的样子。 4.工具书，orelly的，机械工业，电子工业什么的都可以，能英文就英文，不行影印版的也可以，反正越厚越好，而且千万不要放在书架上，一定要堆在桌上，半打开状。 二.从进门开始 1.着装！着装！不管你是去实验室，或者去公司的大楼，在或者是小公司的民宅，或是自己创业的黑作坊；无论是春夏秋冬白天晚上刮风下雨电闪雷鸣台风 龙卷风，一个装b的程序员都要十分在意自己着装！这里只提出参考建议。初级装：衬衣+牛仔裤+休闲鞋。中级装：T恤+宽松短裤+拖鞋。高级装：背心+宽松 大花裤衩+人字拖。 2.得体的举止。在走廊以及任何形式的过道里，一定要双手插兜，走得像个痞子，至少要看起来有点反社会，如若不行，可走文弱天才型geek路线。。 3.如果有女性在你背后指指点点，小声嘀咕说这一定是一个技术男的时候，应该先低头，然后保持低头状态，缓缓回头，坏坏地蔑笑但是不要出声，然后快步前行。 4.进门后，一定不要跟任何人打招呼，笔直走向自己的位置，最多路过打一杯咖啡，千万不要有多余的动作，显示出自己的专注与心无旁骛。 三.坐下就不要再动了 1.坐下以后，姿势需要略微后仰，能翘着二郎腿最好了，然后在后仰的情况下低着头，以便看到屏幕，然后千万就不要再动了。 2.粗暴地把电脑前的大堆书推开一个口，然后摘下电脑上的一个便签，看一眼，不过3秒，可以开始coding了。 3.能不用IDE就不要用，实在装不了，无论IDE是什么，一定要调成DOS那种黑色背景的。 4.如果写前台界面，就不停地调试后台代码；如果写Java，就在里面混编C；如果写C，就在里面混编汇编。不光要coding，还要时不时的翻出一本什么英文的书翻一翻，看不懂就看看插图，然后扔到面前假装懂了继续coding。 5.什么看起来高端就用什么，不要管实用不实用。例如对C++：switch统统重构成多态；如果有指针，统统改成智能的；C++一定要自己写 template；数字是全部要替换成宏的名字能起多长就起多长；struct就不要出现了，如果出现，也一定要用attriburte修饰一 下；运算都是位操作的；操作符都是重载的；网络都是并发缓冲线程池的；int只用int32_t声明的;继承不用普通的，什么多继承虚继承 啊；helloworld也要写捕获异常的；后人一看代码，中间一堆关键字 extern,asm,auto,XXXXX_cast,volatile,explicit,register,template，让一般总在敲 int,if,else,for的小程序员顿时心生崇拜。 6.注释？算了吧。只有两个路线可以选：一，变量名起得巨长无比，看代码就和读英文文章一样顺畅，根本不需要加注释。 二，代码无比晦涩，加不加注释根本无影响。 7.千万不要用IM工具交流，千万不要问同事问题，显得自己没有水平，都是自己上网或者查书。 8.无论是同事间开玩笑或者发生任何群体性时间，不要抬头，更不要东张西望，即使地震火灾，也一定要先提交代码再行离开。 四.潇洒地离开 1.人走，主机是千万千万不能关的，至少要跑个daily build，实在不行正在svn提交也勉强算过关。 2.书应该已经又堆到屏幕前了，千万不要整理，明天再来推开。 3.不强求最后一个走，但一定要所有的非程序员，什么市场啊前台啊pm啊都走光了，才可以走。 4.走得时候一定要率性，千万不要收拾任何东西，站起来，出门，好的，就这样。 5.如果今天一定要说句话的话，找到那个最苦逼的程序员，跟他说，你进度太慢了啊，不要老让我等你。 写在最后程序员没有沮丧、受伤、挫败感的时候么？有，而且可能今天你还哼着 “倍儿爽”，明天你就突然有 “我想哭但是哭不出来” 的苦闷。所以，需要你们在我们熬夜的时候送来关怀，寂寞的时候送来问候。总之，程序员的日子从没那么精彩，却又精彩处处可见。 参考资料：《程序员装逼指南》文／wblearn（简书作者）原文链接：http://www.jianshu.com/p/292da3de5bcd/comments/5069037#本文链接：http://www.bit100.com/1024程序员节，向改变世界的程序员致敬"},{"title":"(已解决)ViewPager禁止预加载-使用Framgment的setUserVisibleHint导致的问题","permalink":"http://zhongzilu.github.io/2016/09/23/已解决-ViewPager禁止预加载-使用Framgment的setUserVisibleHint导致的问题/","text":"###(已解决)ViewPager禁用预加载，使用Fragment的setUserVisibleHint导致的问题 不久前，写了一篇博客，《ViewPager禁止预加载，滑动到那个页面再加载网络数据》，根据这篇文章的做法，确实可以解决问题，但是当时我忽略了另一种情况，那就是在Activity中重复利用那个Fragment，结果Fragment没有加载数据，显示空白的 这也是我在实际开发中遇到的，因为有个Fragment在ViewPager中显示，在另一个地方需要跳转到一个Activity，Activity显示内容和逻辑和Fragment里的一样，所以为了代码重用，就直接用Activity嵌套Fragment了，结果Activity显示空白，调试发现根本没运行到setUserVisibleHint()，在ViewPager中嵌套Fragment没有遇到这个问题。 于是我在Activity的onResume()中手动调用setUserVisibleHint(true)，结果报空指针，一查才知道，原来setUserVisibleHint()方法要优先于Fragment的onCreateView()，由于Fragment里的必要控件都还没有初始化，所以报空指针了 要解决这个问题，需要用到Fragment的onHiddenChanged()方法， @Override public void onHiddenChanged(boolean hidden) { super.onHiddenChanged(hidden); if (hidden &amp;&amp; isFirst){ //在这里加载数据 isFirst = false; } } 然后在Activity中手动调用onHiddenChanged(true)，这样就能实现和ViewPager + Fragment的方式一样的效果了，在用户看到这个Fragment的时候再加载数据 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/问题ViewPager禁用预加载使用Fragment的setUserVisibleHint导致的问题/"},{"title":"ViewPager禁止预加载-滑动到那个页面再加载网络数据","permalink":"http://zhongzilu.github.io/2016/09/19/ViewPager禁止预加载-滑动到那个页面再加载网络数据/","text":"ViewPager禁止预加载，滑动到那个页面在加载网络数据@(标签)[Android, ViewPager, 预加载, setUserVisibleHint, 2016-09-18, zhongzilu, 钟子路] 用过Android ViewPager的同学都知道，ViewPager预加载是3页，可以取消预加载，但是滑动页面会卡，不推荐。但如果不做限制，这样感觉又比较浪费资源，因为用户很可能只看了第一个，后面两个根本想不想看，结果还是加载了。更糟的是，如果你的Fragment在初始化时需要从网络加载大量的数据，这对资源消耗和用户体验都是不好的。 那么有没有什么办法可以让用户在看到哪个页面的时候再去加载页面数据呢？ 答案当时有的，在使用的ViewPager的时候，通常我是采用的ViewPager + Fragment的方式，这个时候我们可以使用Fragment中的setUserVisibleHint()方法，直接在Fragment中覆写该方法： @Override public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); if (isVisibleToUser){ //在这里加载数据 } } 这样就能在Fragment显示出来的时候再去加载数据了，但是这样有个问题，每次加载Fragment的时候都会去重新加载一次，为了避免这个问题，我们用一个boolean类型的全局变量isFirst来表示只在第一次呈现的时候才加载数据，修改过后的代码如下： private boolean isFirst = true; @Override public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); if (isVisibleToUser &amp;&amp; isFirst){ //在这里加载数据 isFirst = false; } } 这样就能满足使用ViewPager时禁用预加载的要求了！是不是很简单？ 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/viewpager禁止预加载，滑动到那个页面再加载网络数据/"},{"title":"如何看待阿里抢月饼事件","permalink":"http://zhongzilu.github.io/2016/09/13/如何看待阿里抢月饼事件/","text":"如何看待阿里抢月饼事件？@(标签)[阿里巴巴, 月饼, 中秋节, 2016-09-12, zhongzilu, 钟子路] 今天在公司正愉快的敲着代码，突然电脑的右下角企鹅图标开始频繁闪动，我掐指一算，估计有什么大事要发生了（事实证明，这是我瞎编的），点开群消息，就看到一张醒目的图片我不禁被这几行犀利的文字所吸引，看完后顿生感叹：可惜了(liao)。 Life is just like a box of moon cakes. You never know what you’re gonna get.人生就像一盒月饼，你永远不知道下一个是不是五仁馅儿的 原本只是一件小事，被大众这么一传播，就成了大事，我早说过程序猿就是个高危职业。 作为同行，我肯定不能“坐视不管”，于是在某乎上找到一篇贴：如何看待阿里巴巴安全部门的月饼事件？，在看过该篇贴之后，我想在这里仅代表个人意见发表一些看法。 不得不说，阿里这次的决定实在是有点欠妥，这件事原本只是一件小事，或者说是Geek程序猿们开的一次玩笑，像这种事情，大多说公司都是内部警告处分就完事儿了，这样对外界来说，这件事就根本没发生过；对公司来说，也免去了不少的非议，而且最重要的是，那几个因此受到责罚的同事，会从中总结经验教训，并感谢领导们的“不杀之恩”。 从另外一个角度考虑，这几个同事使用技术手段来抢月饼，说明他们还是几个比较有想法的人，至少对自己从事的技术工作抱有好奇心，敢于突破常规，在我看来，只要不犯法，那就不是问题。 但阿里选择了不一样的处理方式，现在很难说这种处理方式是对是错，不过我们可以大胆的猜测一下 猜测： 从发帖内容上看，阿里辞退这几名员工的理由应该是使用了技术手段来达到个人目的，影响了公平性，这种行为是不诚实的行为，和阿里的价值观不符，所以被开除。 我不是阿里人，所以我也不知道阿里的价值观是什么，但在我看过的阿里的相关资料里，我记得阿里在成立初期经历过一次比较严重的问题事件，好像是淘宝上的商户欺诈，用户投诉的事件，阿里当时的做法并非像其他公司一样内部追责，对外咬死不承认，而是开诚布公，向公众说明事实真相，并说明将如何处理该问题。所以我猜测阿里的价值观就是如此，对待事件，开诚布公，说明原由，公开处理方式。 有人说这次的事件是阿里的又一次成功的营销手段，因为阿里用事实证明了：阿里月饼公司专供，好吃到内部抢到开除，我觉得用四个人换阿里月饼畅销还是挺划算得，这个梗我可以玩儿一年。 好像扯远了，回到话题 其实像这次9.12事件，完全有其他的处理方式，比如这几位都说得很有道理，阿里作为一个技术型公司，在面对技术上的问题，应该更加慎重的解决，切不可鲁莽行事，这次的处理方式，还是有草率行事的嫌疑，这让有些人开始怀疑阿里的体制问题了，难道一个企业从小公司到大企业之后，都会变得这么急功近利，冷酷无情了吗？或者说，在天朝内的企业就是这样，我们出不来伟大的公司，因为我们伟大的只是领导和主义？ 最后，我希望阿里能重视这件事情，妥善处理，毕竟有很多的目光在注视着，有看热闹的，有看门道的，也有看笑话的，说不定还有挖墙角的，小心为上！ 作者：钟子路(zhongzilu)原文地址: http://www.bit100.com/如何看待阿里抢月饼事件？/"},{"title":"理想三旬","permalink":"http://zhongzilu.github.io/2016/09/12/理想三旬/","text":"理想三旬标签 浓烟下的诗歌电台 理想三旬 陈鸿宇 15平米的出租房，一张床一张桌子，角落装行李的箱子似乎原封不动堆在那里，还是几个月之前的样子，那副裱起来的肖像画似乎特别显眼。 窗外风雨交加，手机今天早上跳出来的新闻说超级台风了，这个房子老旧的似乎摇摇晃晃马上要被吹坏一样。 房东是个独居老太太，衣着干净整洁，讲一口细软的南方普通话，消瘦很精明或者是说有些刻薄和吝啬。 守了6年的唱片公司最终还是入不敷出，他是这家公司的最后一个歌手，吃散伙饭的时候快四十的男人痛声大哭，他看着老板一句话也说不出来。 他几年前卖了攒钱买下的房子，坐上火车南下回到家乡，盘了一家餐厅，亲自装修，亲自三顾茅庐找厨师，亲自去买材料，甚至在后厨刷碗，但是剩下的钱也只够租下这个小屋子。 “我真的不喜欢你们这些说搞音乐的人，真的是不想租的啦，晚上八点以后不要让我听见唱歌啊，弹琴的声音，还有宠物也不要养。” “知道了。” 他打开小冰箱，里面除了啤酒什么都没有，床头柜上有一包昨天吃剩的饼干，把剩下的塞到嘴里，只觉得浑身酸痛。 一个人干几个人的活，员工虽然有休息日，但是自己却只能够在这样自然灾害的天里面休息。 望了一眼墙角的吉他，琴箱上积了一层灰，他伸手拿够到它，然后用布把那些灰擦掉，然后想了想最终还是打开。 他今年三十岁了，古人说三十而立，这个年纪谈梦想似乎让人觉得可笑。这也是他不回家的原因，不过父母知道他开餐厅时候还是挺开心的，这是他姐姐和他说的。 学生时代一起做乐队的朋友大多都已经放弃了，极少数坚持下来的生活似乎也不怎么光鲜，至于之前工作认识的朋友似乎也因为某些原因疏远。他还比较幸运，他们说，至少曾经被人看见过，他觉得也是。看见他们因为业绩和上司闷闷不乐，他觉得自己虽然显得幼稚，但是却还是比较快乐。 音乐从指缝中流出，寂寞而美好，他也不知道怎么就弹出这首曲子。 因为这首歌他被老板看上，出了第一张也是唯一的一张唱片，红极一时，那时候走到街上似乎都是这首歌。 但是这首歌是他写给她女朋友的，那时候他们那么相爱，似乎永远都不会分开。在那个他们一起上学的北方城市，她最终嫁给了一个很平凡但是对她很好很踏实的男人，听说已经有了一个孩子。人有时候真的很善变，也很无情。喜欢的时候那么喜欢，不过忘记也似乎就只要一瞬间。 她给他画的画他还留着，二十多岁的样子和三十多岁的样子真的很不一样。这首歌现在唱和当初在舞台上唱的，似乎也不太一样。如果没有得到过，那么便不会觉得悲伤。 他突然很想抽烟，但是他已经戒烟很久了。他抱着吉他，窗外风雨更急了，路上看不见人影，满屋子的风雨呼啸声。 “笃笃笃。”突然听见敲门声。 他觉得奇怪，开门房东站在门口，手里拿着个饭桶。 “这么大的后生还怕台风啊，哭什么。” 他才发现自己竟然在留眼泪，连忙擦掉:“您怎么来了？有什么事情吗？” “平时看你都是订外卖吃的，台风天人家外卖都不送了，刚好饭做多了给你一点。”房东把饭桶塞到他手里，“和我儿子一个样子，吃外卖还有方便面身体才不好，每天半夜咳嗽我觉都睡不着了。吃完放在我门口就好了。” 他有些懵，只是点了点头。 “真的是和我儿子一个样子，谢谢也不知道说的啊？”她有些生气的样子。 他又慌忙说了一句谢谢。 “嗯。”她点了点头，“不过你弹琴还是蛮好听的，唱歌也比他好，我还是蛮喜欢的。虽然是年轻人的歌，好听的话也可以适当多唱唱。” 作者：王木木原文地址: http://gushi.li/42"},{"title":"(已解决)程序调用魅族系统裁剪之后直接闪退","permalink":"http://zhongzilu.github.io/2016/09/02/已解决-程序调用魅族系统裁剪之后直接闪退/","text":"（已解决）程序调用魅族系统裁剪之后直接闪退 说明几天前发布了一篇博客，是关于程序调用魅族系统裁剪之后直接闪退的问题，在网上找了很久之后也没有找到解决方法，于是决定去请教魅族官方的开发者，我先是在魅族社区里发帖提问，然后有幸在朋友的帮助下得到了魅族运营的联系方式，请求他帮忙联系一下魅族开发者，果然，在一周之后我得到了魅族开发者的回复，我在这里为魅族开发者点赞，感谢他们对待问题的态度，同时也为魅族客服点赞，感谢他们对用户提出的问题进行认真的回复。 好了，废话不多说，今天主要讲讲对于这个问题的解决方案。 魅族官方社区的回复截图根据回复，我们可以得知，魅族在系统层就处理了 我们经常遇到的 因裁剪图片过大可能会导致内存溢出的问题，这一点还是挺人性化的，再次为魅族系统开发者点赞。 回复中共提供了三种解决方案，通过对比，我们把这三种方案进行结合。 解决方案代码如下： /** * 对选择的图片进行裁剪 * @param uri 图片uri * @param outputX 输出图片宽度 * @param outputY 输出图片高度 * @param requestCode 请求码 */ public void cropImage(Uri uri, int outputX, int outputY, int requestCode) { Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.setDataAndType(uri, &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); intent.putExtra(&quot;aspectX&quot;, 1); intent.putExtra(&quot;aspectY&quot;, 1); intent.putExtra(&quot;outputX&quot;, outputX); intent.putExtra(&quot;outputY&quot;, outputY); intent.putExtra(&quot;noFaceDetection&quot;, true); intent.putExtra(&quot;return-data&quot;, true); //这里增加第三种方案的代码 intent.putExtra(&quot;return-path-if-too-large&quot;, true); intent.putExtra(&quot;scale&quot;, true); //这里生成裁剪过后的图片的保存路径 File file = new File( getApplicationContext().getExternalCacheDir(), UUID.randomUUID().toString()); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file)); intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString()); //输入文件格式 startActivityForResult(intent, requestCode); //把自定义的保存路径保存到全局变量中，方便其他地方调用 this.mCropImageUri = Uri.fromFile(file); } 覆写的onActivityResult代码如下： @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { switch (requestCode) { //裁剪图片之后的处理 case REQUEST_CROP_CODE: if (resultCode == RESULT_OK &amp;&amp; data != null){ Uri uri = data.getData(); if (uri != null) { this.mImageRealPath = uri.getPath(); LogUtil.d(&quot;ImageRealPath==&gt;&quot;, mImageRealPath); //更换视频封面 img_video_mask.setImageURI(uri); } else { //在其他机型上裁剪过后的图片uri会包含在data中， //通过data.getData()可以获取到裁剪过后的图片uri //但在魅族机型上，data.getData获取的uri为null //因此需要使用我们在调用裁剪时生成的保存路径 this.mImageRealPath = mCropImageUri.getPath(); LogUtil.d(TAG, &quot;onActivityResult: ImageRealPath==&gt;&quot; + mImageRealPath); img_video_mask.setImageURI(mCropImageUri); } } break; super.onActivityResult(requestCode, resultCode, data); } 作者：zhongzilu原文地址: http://www.bit100.com/（已解决）程序调用魅族系统裁剪之后直接闪退/"},{"title":"程序调用魅族系统j裁剪之后直接闪退","permalink":"http://zhongzilu.github.io/2016/08/30/程序调用魅族系统j裁剪之后直接闪退/","text":"程序调用系统裁剪之后直接闪退说明我原本是想实现更换头像的功能，程序调用系统相册选取图片，选取图片后直接进行裁剪，我在Activity里覆写了onActivityResult方法，然后在该方法里获取返回的图片数据，结果要么是根本没执行到onActivityResult方法里，要么是获取不到数据，在其他手机上没出现这个问题，唯独在魅族的手机上会有这个问题，我想请问一下魅族的开发者大佬们，这个问题该怎么解决呢？ 具体描述有两种情况，第一种没执行到onActivityResult 裁剪请求代码如下： /** * 对选择的图片进行裁剪 * @param uri 图片uri * @param outputX 输出图片宽度 * @param outputY 输出图片高度 * @param requestCode 请求码 */ public void cropImage(Uri uri, int outputX, int outputY, int requestCode) { Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.setDataAndType(uri, &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); intent.putExtra(&quot;aspectX&quot;, 1); intent.putExtra(&quot;aspectY&quot;, 1); intent.putExtra(&quot;outputX&quot;, outputX); intent.putExtra(&quot;outputY&quot;, outputY); intent.putExtra(&quot;noFaceDetection&quot;, true); intent.putExtra(&quot;return-data&quot;, true); intent.putExtra(&quot;scale&quot;, true); File file = new File( getApplicationContext().getExternalCacheDir(), UUID.randomUUID().toString() ); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file)); intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString()); startActivityForResult(intent, requestCode); } 覆写的onActivityResult代码如下： @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { switch (requestCode) { //裁剪图片之后的处理 case REQUEST_CROP_CODE: if (resultCode == RESULT_OK &amp;&amp; data != null){ Uri uri = data.getData(); if (uri != null) { this.mImageRealPath = uri.getPath(); LogUtil.d(&quot;ImageRealPath==&gt;&quot;, mImageRealPath); //更换图片 img_video_mask.setImageURI(uri); } } break; } super.onActivityResult(requestCode, resultCode, data); } 这种情况就是没法运行到onActivityResult方法里，裁剪图片之后，点击确定按钮，就直接闪退了，在debug模式下都没办法 第二种情况是能运行到onActivityResult里，但获取不了返回数据 裁剪请求代码稍微有点区别，具体如下： /** * 对选择的图片进行裁剪 * @param uri 图片uri * @param outputX 输出图片宽度 * @param outputY 输出图片高度 * @param requestCode 请求码 */ public void cropImage(Uri uri, int outputX, int outputY, int requestCode) { Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.setDataAndType(uri, &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); intent.putExtra(&quot;aspectX&quot;, 1); intent.putExtra(&quot;aspectY&quot;, 1); intent.putExtra(&quot;outputX&quot;, outputX); intent.putExtra(&quot;outputY&quot;, outputY); intent.putExtra(&quot;noFaceDetection&quot;, true); intent.putExtra(&quot;return-data&quot;, true); intent.putExtra(&quot;scale&quot;, true); // File file = new File(getApplicationContext().getExternalCacheDir(),UUID.randomUUID().toString()); // intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file)); intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString()); //输入文件格式 startActivityForResult(intent, requestCode); } 覆写的onActivityResult也稍微有点变化，具体代码如下： //裁剪图片之后的处理 case REQUEST_CROP_CODE: if (resultCode == RESULT_OK &amp;&amp; data != null){ Uri uri = data.getData(); if (uri != null) { this.mImageRealPath = uri.getPath(); LogUtil.d(&quot;ImageRealPath==&gt;&quot;, mImageRealPath); //更换图片 img_video_mask.setImageURI(uri); } else { Bundle bundle = data.getExtras(); if (bundle != null) { String filePath = bundle.getString(&quot;filePath&quot;); if (!TextUtils.isEmpty(filePath)){ img_video_mask.setImageURI( Uri.parse(filePath)); } } } } break; 之所以改成这样的写法，是因为我在网上找到一篇文章在说这个问题，并给出一个解决方案，我根据他的解决方案，依然没有解决问题。地址：http://www.cnblogs.com/over140/archive/2012/12/17/2821874.html 在Debug模式下，截图如下 通过截图可以看到uri和filePath都为null，实在没办法，所以来请教一下魅族的开发大佬们，希望能尽快收到你们的回复，小弟在此表示万分感谢！ 作者：zhongzilu原文地址： http://www.bit100.com/程序调用魅族系统裁剪之后直接闪退/"},{"title":"浓烟下的诗歌电台-陈鸿宇","permalink":"http://zhongzilu.github.io/2016/06/22/浓烟下的诗歌电台-陈鸿宇/","text":"浓烟下的诗歌电台-陈鸿宇标签 浓烟下的诗歌电台 安静 吉他 低沉 理想 行路 早春 钟子路 网易云音乐 读一本书，是与作者心灵上的沟通，听一首音乐也是。今天我给大家带来几首陈鸿宇的歌，听他的歌，什么烦恼，浮躁的心，都能烟消云散。 浓烟下的诗歌 浓烟下不过是南方三四月的梅雨时节，早春的树已按耐不住寂寞于冬末出芽，你只是经过而我却再也难忘你的容颜，理想三旬依旧年轻却忘了黑发已不再，霓虹深处灯红酒绿痴男怨女忘情歌唱，途中收到来信一封心中窃喜你还依旧，遗漏了我们一路走来心中畅想的行歌。 理想三旬 他说，理想已存在于月有三旬之前，七月融化在不经意的罅(xia)隙，十二月结成冰，被牢牢抓住在时间里，人有三旬，也不过是右手握着缄口不言的聚散，左手长出脉络骄横的命运，然后山崖无尽，热望不熄，最终死生寻常，悲喜成疾。 途中 独飞时慕侣，寡合乍孤音 行歌 负者歌于途，行者休于树 早春的树 偶然惊鸿一瞥，我心怦然而动，成为一棵早春的树。为你我愿折筋断骨，融入你每一寸生活，只盼守你年年月月，可我不过早春一棵树，只能立于门前，希冀你某天再经过我的荒芜 船子 你只是经过 她出现，又消失，一如日升日落，抑或任何转瞬即逝的事物。就像我们的生活，我们出现，然后我们又消失，我们对一些人是如此重要，但我们只是经过。 来信 窗外下起了小雨，没有你消息的夜是否继续漫长，前些天你说要寄给我一张明信片，我等邮戳漂过远方，等你慢慢变成我的习惯，心里为你留了一扇门，很难再关上，逐渐发现自己有些软弱，大概是惯性吧，像等你的日子，让我无能为力。 霓虹深处 这一刻，我来过的意义，而后恍悟，无谓再提。 浓烟下 歌声沉痛落地再轻浮地扬起，动人的永远只是半成品，和你，歌声沉痛落地再轻浮地扬起，而我能给的，恰好大都无意义。 浓烟下的影子霓虹深处的你都只是经过途中的一处风景 早春有树船有鱼群行歌吟完再读来信理想已三旬 作者：zhongzilu原文地址: http://www.bit100.com/浓烟下的诗歌电台 ——陈鸿宇/"},{"title":"Android Canvas绘制图形-拾音器之动画篇","permalink":"http://zhongzilu.github.io/2016/05/31/Android-Canvas绘制图形-拾音器之动画篇/","text":"Android Canvas绘制图形 拾音器之动画篇标签 Android Canvas View Animation ValueAnimator View动画 属性动画 前几天我写过一篇文章，叫Android Canvas 绘制图形 – 拾音器，那篇文章旨在讲解如何使用Canvas来绘制图形，并没有实现指针的偏转动画实现，那么，今天我们就来看看指针的偏转动画如何实现。 知识准备安卓上实现动画的方式分为两种，一种是View动画，包名：android.view.animation，另一种是属性动画，包名：android.animation。 View动画从字面上理解就是作用对象只能是View的派生类，其他的就只能心有余而力不足了。 属性动画的作用对象就不只是针对View的派生类了，他能操作很多属性，比如改变一个控件的宽高值；一个数值平滑过渡到另一个数值等，总之，View动画能做的他能做，View动画不能做的他也能做。对，你没看错，就是这么屌！ 简单介绍View动画，包括以下几种类型： 类型 说明 AlphaAnimation 渐变透明度 RotateAnimation 画面旋转 ScaleAnimation 尺寸缩放 TranslateAnimation 位置移动 属性动画(Property Animation)，包括以下几种类型： 类型 说明 ObjectAnimator 动画执行类，对对象进行操作 ValueAnimator 动画执行类，对数值进行操作 今天我们将使用到的是ValueAnimation类，接下来对动画进行分析，看看要实现指针偏转的动画需要用到什么方法。 指针偏转是通过旋转角度来实现的，如果我们要使偏转产生动画，就需要动态的改变旋转的角度。 旋转的角度参数类型是float，在ValueAnimator类中的ofFloat()方法正好是动态改变float数值的，所以我们要用到它。 数值每改变一次，我们都要把变化后的数值赋给rotate()方法，使指针旋转相应角度，所以这里需要对数值变化进行监听，因此会用到addUpdateListener()方法 赋值给rotate()方法后，需要对视图进行重绘，因此我们需要用到视图绘制过程中的invalidate()方法 思路这里我们用mValue表示指向数值，用变量mAngle表示通过计算后的偏转角度 通常的做法，我们都是在Activity或者Fragment里通过调用一个方法，将指针要指向的数值(mValue)数的方式传递过去，这样的话，我们就有两种思路。 一：使用ofFloat()方法动态改变指针指向的数值，即传递过来的参数mValue 二：将传递过来的参数进行计算成指针偏转的角度(mAngle)，然后使用ofFloat()方法动态改变角度数值 这两种方法都是可取的，具体情况具体分析，由于在界面上我们要动态显示指针指向的数值，如果采用第二种的话，那么我们要计算两次，一次是将指向mValue计算为mAngle，数值动态变化后还要将mAngle计算为mValue，这样比较麻烦，所以我们采用第一种思路。 因此，要实现指针的偏转动画，代码可以这么写： private int mMaxValue = 50; //分值区间的最大值 private int mMinValue = -50; //分值区间的最小值 /**输入值，通过输入值来计算指针的旋转角度，即{@mAngle}的值, * 最终在界面上呈现的效果是指针指向输入值的刻度上*/ private String mValue = &quot;- -&quot;; /**刻度盘呈现的总弧度，本案例中总弧度为180，呈半圆形*/ private float mArc = 180f; /**指针旋转角度值*/ private float mAngle = 0f; ... /** * 设置指针指向数值，并产生旋转动画 * 这里我们动态改变指向数值 * @param value 指向数值 */ public void setValue(float value){ //{@param value}为指针将要指向的数值，即界面上看到的数值 ValueAnimator startAnimator = ValueAnimator.ofFloat(0, value); startAnimator.addUpdateListener( new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { //通过getAnimatedValue()取变化后的值 float md = (float) animation.getAnimatedValue(); //计算指针当前应该偏转的角度 mAngle = md * (mArc / (float) (mMaxValue - mMinValue)); //界面上显示当前指针显示的数值 mValue = String.valueOf((int)md); //调用重绘方法 invalidate(); } }); startAnimator.setDuration(1000); startAnimator.start(); } 在setValue()方法里我们动态的改变了指针指向的数值和指针偏转的角度，并把这两个数值分别存放在全局变量mValue和mAngle，这样一来，我们只需要在onDraw()方法中，对指针进行旋转和但前指向数值的显示就可以了，代码如下： /** * 注意： * 下方的所以坐标计算和长度计算都是依据在屏幕宽度为621px情况下的 * @param canvas */ @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); ... System.out.println(&quot;mAngle ==&gt;&quot; + mAngle); canvas.rotate(mAngle, xc, yc); //画指针 /** * xc * 0.101449 = 深色刻度线条的长度 * mWidth * 0.064412 = 在屏幕宽度为621下，长度为40 * 所以下面第三个参数的值可以理解为距离深色刻度线下方有40倍数的间隙 */ canvas.drawLine(xc, yc, xc - radius + (xc * 0.101449f + mWidth * 0.064412f), yc + 3, paintCursor); ... //值 pitchValuePaint.setAntiAlias(true); pitchValuePaint.setTextSize((mWidth * 0.080515f)); pitchValuePaint.setColor(getResources().getColor(R.color.colorAccent)); canvas.drawText(mValue, xc - pitchValuePaint.measureText(mValue) / 2, yc + (xc * 0.481481f + mWidth * 0.209339f), pitchValuePaint); ... } 效果如下： 详细的代码，请移步到我的GitHub：https://github.com/zhongzilu/TunerView 我是钟子路，Thanks for watching!"},{"title":"Android Canvas绘制图形-拾音器","permalink":"http://zhongzilu.github.io/2016/05/26/Android-Canvas绘制图形-拾音器/","text":"Android Canvas 绘制图形 — 拾音器 最近在网上看到一个拾音器的设计图，看起来挺美观的，于是我就想把它实现出来，不多废话，先看图，左边是设计图，右边是实现图 除了指针不同，其他的大体上一样 Android Canvas介绍Canvas作为绘制图形的直接对象，提供了以下几个非常有用的方法 Canvas.save() Canvas.restore() Canvas.translate() Canvas.roate() Canvas.save()这个方法，从字面上理解就是保存的意思，而它的作用也正是将之前的画布保存起来，让后续的操作能像在新的画布上一样操作，这个PhotoShop的图层是一个概念Canvas.restore()这个方法，可以理解为合并图层，就是将之前保存下来的图层合并为一个图层Canvas.translate()这个方法，可以理解为移动坐标系，很多人在用时，理解为移动画布，所以在计算坐标时会出一些问题，在这里把他理解为移动坐标系更加恰当。画布的初始坐标系是左上角，如果我们调用translate(x, y)之后，则表示将原点(0, 0)移动到了(x, y)，后面的坐标计算都是在这一点上进行的Canvas.roate()可以理解为旋转坐标系，用法和Canvas.translate()相似，但多了个角度的参数，调用roate(degree, x, y)之后，则表示将以(x, y)为原点的坐标系旋转degree个角度 Paint理解为画笔，在Canvas上所有的图形，都需要这个对象，以下有几个常用方法 paint.setAntiAlias() paint.setStyle() paint.setStrokeWidth() paint.setColor() paint.setAntiAlias()是给画笔设置是否抗锯齿，参数为布尔类型paint.setStyle()是给画笔设置画笔样式paint.setStrokeWidth()给画笔设置画笔宽度paint.setColor()给画笔设置画笔颜色 实现有了上面的理论基础，现在我们可以来实现上面的效果了，先来分析一下上面效果图中有什么 刻度盘——外面的半圆刻度盘 刻度线——整数的深色粗线和其余德灰色细线 圆形底盘——共三个圆形底盘，最上面的深蓝色圆形要在指针上面 指针 新建一个类，继承View public class TunerView extends View { private int mWidth; private int mHeight; public TunerView(Context context){ super(context); //获取屏幕的宽高 WindowManager windowManager = (WindowManager) getContext().Context.WINDOW_SERVICE); mWidth = windowManager.getDefaultDisplay().getWidth(); mHeight = windowManager.getDefaultDisplay().getHeight(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); ... } } 第一步(Step 1)：画刻度盘 由于画布一开始绘制文字时，文字是垂直的，而在设计图中刻度盘是从左往右，文字是水平的，所以需要先对画布坐标系进行旋转 @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); int xc = mWidth / 2; //屏幕中心X坐标 int yc = mHeight / 2; //屏幕中心Y坐标 int radius = xc - 30; //圆半径 /** * 正常情况下，一开始写文字，都是垂直的，但我们的仪表盘 * 要求从左边开始画，文字是水平的，所以需要先对画布坐标系进行逆时针旋转90° */ canvas.rotate(-90, xc, yc); //画刻度盘 Paint paintDegree = new Paint(); paintDegree.setStrokeWidth(3); //画刻度线条 for (int i = -50; i &lt;= 50; i++){ //区别整点和非整点的线条样式 if (i % 10 == 0){ paintDegree.setStrokeWidth(5); paintDegree.setTextSize(30); paintDegree.setAntiAlias(true); paintDegree.setColor(getResources().getColor(R.color.colorAccent)); //这里画线的坐标计算，需要自行去理解，这里我就不多加解释了 canvas.drawLine(xc, yc - radius, xc, yc - radius + 40, paintDegree); String degree = String.valueOf(i); canvas.drawText(degree, //这里使用了Paint对象的measureText()方法, //该方法是传入一个String类型的参数，经过计算之后返回该String对象中 //文字所占用的宽度 xc - paintDegree.measureText(degree) / 2, yc - radius + 70, paintDegree); /** * 由于本案中两个整点之间只被分为了5分，所以每份的间隔就是2 */ } else if (i % 2 == 0){ paintDegree.setStrokeWidth(3); paintDegree.setTextSize(15); paintDegree.setAntiAlias(true); paintDegree.setColor(getResources().getColor(R.color.grey)); canvas.drawLine(xc, yc - radius + 10, xc, yc - radius + 30, paintDegree); } //每画完一条刻度线条，就需要对画布坐标系进行旋转，通过旋转简化坐标运算 //旋转角度为：总度数 / 总份数 //本案例中，总度数为180°, 分值区间为(-50 ~ 50),所以总份数为100份 canvas.rotate((float)(180 / 100), xc, yc); } //画圆形底盘 ... } 运行效果： 第二步(Step 2)：画园形底盘 画实心圆形底盘，通过调用paint.setColor()来设置颜色，调用paint.drawCircle()方法来画出圆形 //画大圆盘 Paint bigCircle = new Paint(); bigCircle.setColor(getResources().getColor(R.color.colorPrimary)); bigCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, xc - 180, bigCircle); //画中等圆盘 Paint midCircle = new Paint(); midCircle.setColor(getResources().getColor(R.color.colorPrimaryDark)); midCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, xc - 280, midCircle); //画小圆盘 Paint smallCircle = new Paint(); smallCircle.setColor(getResources().getColor(R.color.colorAccent)); smallCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, xc - 320, smallCircle); drawCircle()方法有四个参数， cx：圆心的x坐标，float类型 cy：圆心的y坐标，float类型 radius：圆形的半径，float类型 paint：画笔对象，Paint类型 运行效果： 第三步(Step 3)：画指针画指针其实和画线是一个道理，所以我们直接调用drawLine()方法就可以了 //画指针 Paint paintCursor = new Paint(); paintCursor.setStrokeWidth(3); paintCursor.setAntiAlias(true); paintCursor.setColor(getResources().getColor(R.color.colorAccent)); canvas.drawLine(xc, yc, xc - radius + 80, yc + 10, paintCursor); drawLine()方法有5个参数 startX：线条的起始点x坐标，类型float startY：线条的起始点y坐标，类型float stopX：线条的结束点x坐标，类型float stopY：线条的结束点y坐标，类型float paint：画笔对象，Paint类型 运行效果： 这里注意一下，由于我们的指针使用的颜色和最小的那个圆形的颜色是一样的，所以运行效果里看不出问题，如果换一个颜色，就会发现，指针在最小的圆形上面，而设计图上的指针是在最小的圆形下面，那么这要怎么解决呢？不要方，只需要把绘制最小那个圆的canvas.drawCircle()方法放到绘制指针的drawLine()方法之后就可以了 第四步(Step 4)：画正下方的文字 画正下方的文字，只需要调用canvas.drawText()方法就可以了 Paint pitchPaint = new Paint(); pitchPaint.setAntiAlias(true); //设置抗锯齿 pitchPaint.setTextSize(40); pitchPaint.setColor(getResources().getColor(R.color.colorAccent)); String pitch = &quot;Pitch&quot;; canvas.drawText(pitch, xc - pitchPaint.measureText(pitch) / 2, //这里加上180，是因为要加上最外面那个大的圆形的半径 //再加上80，是为了让文字和最大的那个圆产生间隙 yc + 180 + 80, pitchPaint); 运行效果： 可以看到文字的方向不对，为什么文字的方向不对呢？这是因为我们在绘制刻度盘的时候，我们对画布坐标系进行了旋转，画完刻度盘之后，坐标系被旋转了180°，但由于在绘制刻度盘之前，我们对整个画布坐标系进行逆时针旋转了90°，所以实际上只旋转了90°，因此，我们看到绘制的文字不是在正下方，而是在左边，被旋转了90°，那么这要怎么解决呢？最简单的方法当然是在绘制文字之前，把画布坐标系旋转回来。所以需要添加一行代码： canvas.rotate(-90, xc, yc); 运行效果 最后由于上面的案例代码里用到了很多写死的数字代码(Hard Code)，这不利于代码的灵活性，而且，既然有指针，就应该让指针根据一个提供的输入值，来让指针指向对应的数值位置，所以，我对代码进行了改良，代码如下： /** * Created by zhongzilu on 2016/5/25 0025. */ public class DialView extends View { private float mWidth; private float mHeight; private float mAngle = 0; //指针旋转角度，值为0时指针垂直显示 private static int mMaxValue = 50; //分值区间的最大值 private static int mMinValue = -50; //分值区间的最小值 /**输入值，通过输入值来计算指针的旋转角度，即{@mAngle}的值, * 最终在界面上呈现的效果是指针指向输入值的刻度上*/ private float mValue = 0; /**刻度盘呈现的总弧度，本案例中总弧度为180，呈半圆形*/ private float mArc = 180; public DialView(Context context, AttributeSet attrs) { super(context, attrs); //获取屏幕的宽高 WindowManager windowManager = (WindowManager) getContext().getSystemService( Context.WINDOW_SERVICE); mWidth = windowManager.getDefaultDisplay().getWidth(); mHeight = windowManager.getDefaultDisplay().getHeight(); } /** * 注意： * 下方的所以坐标计算和长度计算都是依据在屏幕宽度为621px情况下的 * @param canvas */ @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); float xc = mWidth / 2; //圆中心X坐标 float yc = mHeight / 2; //圆中心Y坐标 float radius = (float)(xc - xc * 0.05314); //圆半径 //画刻度盘 Paint paintDegree = new Paint(); /** * 正常情况下，一开始画线或写文字，都是垂直的，但我们的仪表盘 * 要求从左边开始画，文字是水平的，所以需要先进行画布旋转90° */ canvas.rotate((-mArc / 2), xc, yc); System.out.println(&quot;before rotate==&gt;&quot; + (-mArc / 2)); /** * 本案例中，设置的分值区间为（-50 ~ 50) */ for (int i = mMinValue; i &lt;= mMaxValue; i++){ //区别整点和非整点 if (i % 10 == 0){ //在屏幕宽度为621下，大小为5 paintDegree.setStrokeWidth((float)(mWidth * 0.008051)); //刻度字体大小是依据是：在屏幕宽度为621的分辨率下，刚好为30 paintDegree.setTextSize((float)(mWidth * 0.048309)); paintDegree.setAntiAlias(true); paintDegree.setColor(getResources().getColor(R.color.colorAccent)); canvas.drawLine(xc, yc - radius, xc, (float)(yc - radius + xc * 0.101449), paintDegree); String degree = String.valueOf(i); canvas.drawText(degree, //这里使用了Paint对象的measureText()方法, //该方法是传入一个String类型的参数，经过计算之后返回该String对象中 //文字所占用的宽度 xc - paintDegree.measureText(degree) / 2, //下方mWidth * 0.048309 = 在屏幕宽度为621下，长度为30 yc - radius + (float)(xc * 0.101449 + mWidth * 0.048309), paintDegree); /** * 由于两个整点之间只被分为了5分，所以每份的间隔就是2 */ } else if (i % 2 == 0){ paintDegree.setStrokeWidth((float)(mWidth * 0.004830)); //在屏幕宽度为621下，字体大小为15 paintDegree.setTextSize((float)(mWidth * 0.024154)); paintDegree.setAntiAlias(true); paintDegree.setColor(getResources().getColor(R.color.grey)); /** * 画灰色短横线，坐标计算依据是灰色短横向长度为深色长横线的一半， * 并且，两种刻度线的中点在同一个圆的圆弧上 * 由于深色刻度线的长度 = 正中深色小圆的半径 = 屏幕宽度一半的0.101449倍 */ canvas.drawLine(xc, (float)(yc - radius + xc * 0.101449 / 4), xc, (float)(yc - radius + xc * 0.101449 / 4 * 3), paintDegree); } //通过旋转画布简化坐标运算 canvas.rotate(mArc / (float)(mMaxValue - mMinValue), xc, yc); } /** * 三个圆盘的半径和屏幕宽度的一半的比例为 * 屏幕宽度一半 ：大圆 ：中圆 ：小圆 = * 1 ：0.481481 ：0.201288 ：0.101449 */ //画大圆盘 Paint bigCircle = new Paint(); bigCircle.setColor(getResources().getColor(R.color.colorPrimary)); bigCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, (float)(xc * 0.481481), bigCircle); //画中等圆盘 Paint midCircle = new Paint(); midCircle.setColor(getResources().getColor(R.color.colorPrimaryDark)); midCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, (float)(xc * 0.201288), midCircle); //画小圆盘 Paint smallCircle = new Paint(); smallCircle.setColor(getResources().getColor(R.color.colorAccent)); smallCircle.setAntiAlias(true); canvas.drawCircle(xc, yc, (float)(xc * 0.101449), smallCircle); canvas.save(); //画指针 Paint paintCursor = new Paint(); //在屏幕宽度为621下，大小为3 paintCursor.setStrokeWidth((float)(mWidth * 0.004830)); paintCursor.setAntiAlias(true); paintCursor.setColor(getResources().getColor(R.color.colorAccent)); /** * 思路：要想让指针以圆心为中心旋转一定角度，要么旋转画布，要么根据坐标来画， * 由于旋转角度比根据坐标更简单，所以就用旋转角度的方式来实现 * * 指针具体旋转多少度，得根据算法来计算 * * 算法：角度 = 输入值 * （ 总弧度 / 分值总数） * * 举例：本案例中给出的分值区间为（-50 ~ 50）,所以分值总数为100 * 假设现在输入值为30，那么角度就为54° */ mAngle = mValue * (mArc / (float) (mMaxValue - mMinValue)); System.out.println(&quot;mAngle ==&gt;&quot; + mAngle); canvas.rotate(mAngle, xc, yc); /** * xc * 0.101449 = 深色刻度线条的长度 * mWidth * 0.064412 = 在屏幕宽度为621下，长度为40 * 所以下面第三个参数的值可以理解为距离深色刻度线下方有40倍数的间隙 */ canvas.drawLine(xc, yc, xc - radius + (float)(xc * 0.101449 + mWidth * 0.064412), yc + 3, paintCursor); //覆盖在指针上的圆 /** * 由于之前的坐标系已经发生了旋转，所以要在正下方写上文字，就需要旋转回来 * 当然也可以通过去计算坐标来显示在正下方，但旋转画布的方式更加简单和更容易理解 */ canvas.rotate(-(mAngle + mArc / 2), xc, yc); Paint pitchPaint = new Paint(); pitchPaint.setAntiAlias(true); //在屏幕宽度为621下，字体大小为40 pitchPaint.setTextSize((float)(mWidth * 0.048309)); pitchPaint.setColor(getResources().getColor(R.color.colorAccent)); String pitch = &quot;Pitch&quot;; canvas.drawText(pitch, xc - pitchPaint.measureText(pitch) / 2, //这里加上180，是因为要加上最外面那个大的圆形的半径 //再加上(mWidth * 0.123188)，是为了让文字和最大的那个圆产生间隙 //在屏幕宽度为621下，间隙为80 yc + (float)(xc * 0.481481 + mWidth * 0.123188), pitchPaint); //值 Paint pitchValuePaint = new Paint(); pitchValuePaint.setAntiAlias(true); pitchValuePaint.setTextSize((float)(mWidth * 0.080515)); pitchValuePaint.setColor(getResources().getColor(R.color.colorAccent)); String value = &quot;- -&quot;; canvas.drawText(value, xc - pitchValuePaint.measureText(value) / 2, yc + (float)(xc * 0.481481 + mWidth * 0.209339), pitchValuePaint); canvas.restore(); } } 经过修改过后，只需要修改全局变量mValue的值，就可以使指针指向界面上对应的值了，比如mValue = 30，运行效果 总结总的来说，没什么难度，关键点在于绘图时的坐标计算，以及对旋转画布的理解，旋转画布是旋转的画布坐标系。在本案例中，我没有对指针的旋转做动画处理，是因为本文重在讲解Canvas画图，各位也可以自行加上指针旋转动画代码。好了，以上就是今天的内容，各位可以发挥自己的想象力，绘制出更多更有趣的图形。我是钟子路，Thanks for watching! 作者：zhongzilu源码：https://github.com/zhongzilu/TunerView"},{"title":"【安卓热修复】当你准备开发一个热修复框架需要了解的一切","permalink":"http://zhongzilu.github.io/2016/05/24/【安卓热修复】当你准备开发一个热修复框架需要了解的一切/","text":"【安卓热修复】当你准备开发一个热修复框架的时候，你需要了解的一切很长一段时间前，在我用应用市场软件对我移动设备上的应用更新时，发现每次应用市场提示我更新应用的大小，都有一个节省多少兆大小的醒目文字。当时我很奇怪，难道是对应用安装包进行了压缩吗？过了一段时间后，在我浏览其他人博客时，无意间发现有篇写安卓应用安装包热补丁修复的文章，我仔细看了一遍，一时之间也没看懂，再加上那时也没太多精力，也就搁置起来了，没有进一步了解。 今天工作之余，又在我浏览博客时，再次发现了一篇关于热修复的文章，我看了一下，讲得挺有条理的，特此推荐给大家 原文博客链接：当你准备开发一个热修复框架的时候，你需要了解的一切"},{"title":"SEO如何提高百度权重","permalink":"http://zhongzilu.github.io/2016/05/20/SEO如何提高百度权重/","text":"SEO如何提高百度权重 大家好，我是钟子路，最近在负责公司的网站SEO，我也不是太会，就去查看很多的资料和博客，当然，其中很多方法都是差不多的，所以我在这里就不重复了， 今天就讲讲我无意间发现的，关于如何提高百度权重的方法，由于该方法还没得到验证，所以这里只是提供一种思路，如果可行，请分享给其他有需要的人。 科普时间百度权重是站长工具推出的针对网站优化关键词排名预计给网站带来流量，划分出0-9十个等级的第三方网站欢迎度评估数据。 百度官方目前只公开了竞价推广用户提供0-10不同分值关键词质量度的评级。 权重数值越大，说明网站自然流量越大，自然流量大，那么相应的关键词排名就相对靠前，权重，流量，关键词排名三者之间是相辅相成的。 网站关键词的数量越多，积累的权重也会越高，不过，这还要看关键词的流量，如果关键词的流量非常的低，即便排名很靠前，权重也不会积累到很多，不过可以积少成多。 百度权重的规则： 权重1 百度预计流量1~99权重2 百度预计流量100~499权重3 百度预计流量500~999权重4 百度预计流量1000~4999权重5 百度预计流量5000~9999权重6 百度预计流量10000~49999权重7 百度预计流量50000~199999权重8 百度预计流量200000~999999权重9 百度预计流量1000000以上 站长们要查看自己网站的权重，通常是通过站长工具进行查询的，我也不例外，直接在百度上搜索“站长工具”就可以了，百度权重查询地址http://rank.chinaz.com/，输入自己网站的网址就可以查询到当前的百度权重了。如下图： 思路既然关键字的流量和权重有直接关系，那么我们就可以在自己网站关键字里加入一些高频次、高流量的搜索关键词，这样可以让自己的网站更容易出现在搜索结果里，如果点击了你的网站，就会给自己网站增加一部分流量，而流量的大小决定网站的权重。 那么如何获得高频次、高流量的搜索关键词呢？ 这里就需要通过百度指数来进行查找了，百度指数地址http://index.baidu.com/ 输入要查询的关键字就可以查询到关键字的搜索指数以及历史趋势记录 点击上部【需求图谱】选项卡，可以挖掘指定关键字相近关键字的分布指数 这里的数据挺直观详细的，我就不多赘述了，祝愿各位站长们找到自己满意的关键字，Good luck!"},{"title":"如何在Android Studio中创建File Templates","permalink":"http://zhongzilu.github.io/2016/05/10/如何在Android-Studio中创建File-Templates/","text":"如何在Android Studio中创建File Templates标签： File Template Android Studio 我发现一个可以让写程序变得简单的方法，那就是自定义文件模板(Custom File Templates).那么什么是File Templates呢？说白了，就是一个已经包含一部分代码的源文件 如何创建File Templates首先，找到创建File Template的位置，依次打开File ==&gt; Setting ==&gt; Editor ==&gt; File and Code Templates 之后点击 +号添加一个File Template，这里需要填写 File Template的名称和代码。在本次案例中，我们将创建一个实现了部分方法的RecyclerViewAdapter的File Template。因此就取名叫RecyclerViewAdapter 之后你就可以在下方的代码区域粘贴或者编写你的模板代码了。这里有几个预置的变量可以使用，当文件被创建的时候，这些预置的变量将会被 将会被对应的值替代，变量如下： ${NAME} 选择的文件的文件名 ${PACKAGE_NAME}包名 ${DATE} 系统当前的时间当然，你也可以自定义变量，在本案例中，我们需要提供ViewHolder类和集合List的类型，所以自定义变量分别为${VIEWHOLDER_CLASS}和${ITEM_CLASS} 那么现在就来编写用于创建模板的代码，代码如下： #if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME};#end import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import java.util.List; #parse(&quot;File Header.java&quot;) public class ${NAME} extends RecyclerView.Adapter&lt;${VIEWHOLDER_CLASS}&gt; { private final Context context; private List&lt;${ITEM_CLASS}&gt; items; public ${NAME}(List&lt;${ITEM_CLASS}&gt; items, Context context) { this.items = items; this.context = context; } @Override public ${VIEWHOLDER_CLASS} onCreateViewHolder(ViewGroup parent, int viewType) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.${LAYOUT_RES_ID}, parent, false); return new ${VIEWHOLDER_CLASS}(v); } @Override public void onBindViewHolder(${VIEWHOLDER_CLASS} holder, int position){ ${ITEM_CLASS} item = items.get(position); //TODO Fill in your logic for binding the view. } @Override public int getItemCount() { if (items == null){ return 0; } return items.size(); } } 当你想要使用这个文件模板时，会提示你提供相关变量的值，比如${VIEWHOLDER_CLASS}和${ITEM_CLASS},填写的值会自动替换对应的变量，非常的方便。 要使用已经定义好的File Template，只需要选中要创建位置的文件夹，然后点击鼠标右键，再点“New”，你就可以在列表中看到刚创建的File Template的名字 点击RecyclerViewAdapter后填写相关变量的值 填写完后点击”OK”，之后你就可以看到自动生成的代码了 这样，今后我要实现一个RecyclerView的Adapter时，就不用再去写那么多代码了 如果你有一些比较好的代码模板，也可以分享给我哦 ^_^"},{"title":"如何在Android Studio(IntelliJ)中创建Live Templates","permalink":"http://zhongzilu.github.io/2016/05/10/如何在Android-Studio-IntelliJ-中创建Live-Templates/","text":"如何在Android Studio/IntelliJ中创建Live Templates标签： Android Studio IntelliJ Live Template 何为Live Templates? frequently-used or custom code constructs that you can insert into your source code file quickly, efficiently and accurately.快速，高效，准确的将常用或自定义构造代码插入到你的源代码文件中 通俗的讲，就是像快捷键一样，只需要输入几个简写的英文字母就可以快速自动插入一行或多行代码。 在Android Studio/IntelliJ编辑器中，默认使用Ctrl + J快捷键可以调出Live Templates，可以自动补全所设置的模板的代码，善用它能够很大程度上减少开发时间。 举个例子，输入psfi，然后按回车键，编辑器将会自动生成代码public static final int，这就节省了19个要输入的字母。 Android Studio/IntelliJ编辑器中预置了一些常用的Live Templates，大家可以自行去查看，查看位置File ==&gt; Settings ==&gt; Editor ==&gt; Live Templates 如何创建自定义的Live Templates？ 找到Live Templates的位置，然后点击右上角的+号，再选择Template Group，写上一个名称 接着再点击+号，选择Live Template，之后填写相关的内容 举例我用一个快速插入RecyclerView控件代码的例子来举例，设置如下图： 填写相关内容完毕之后 ，注意下方的一行红字，此时定义的Live Template还没生效，需要点击Define，然后选择该Live Template要应用到什么样的场景中。因为这里我定义的是安卓的控件代码，所以就归类为XML 点击OK按钮生效。注意勾选右下角的Reformat according to style选项 要想使用刚才定义的Live Template，只需要在android的XML布局文件中输入rcv，然后按回车键就可以了，如下图所示： 以上就是如何在Android Studio/IntelliJ编辑器中创建Live Template的方法，相信富有创意的各位能够创建出更多的更方便的Live Template，这对于今后的代码编写大有裨益 另外，我在这里推荐一篇博客：http://blog.csdn.net/DesmondJ/article/details/47017205"},{"title":"Wordpress自定义栏目的使用","permalink":"http://zhongzilu.github.io/2016/05/10/Wordpress自定义栏目的使用/","text":"WordPress自定义栏目的使用 前言 最近有个任务，要实现在公司官网上点击某个商品的购买按钮，就跳转到对应的淘宝店页面去。由于公司官网用的WordPress平台，我之前只是听说过，并没有实质性使用过，所以一开始就是一头雾水，再加上网站原本是由外包公司做的，交接时没有任何文档，因此我根本不知如何下手，但最后还是硬着头皮去做了。 我思考着要完成这个任务我需要怎么做，由于网站上的内容都是动态从数据库中取的，所以如果我要实现点击购买按钮就跳转到对应网店的功能，就不可能在代码中把跳转的店铺地址写死了，必须要从数据库中去读取，并且还要和商品关联起来才行。 这其中肯定涉及到把链接地址写入数据库，WordPress提供了一个管理后台，通过管理后台可以把数据写入数据库。 打开后台，找到文章编辑页面，在右上方有个显示选项，展开后可以显示和隐藏模块。勾选自定义栏目 在页面下方可以看到这个模块，在这里可以新增自定义的数据字段，并给它赋值。 拿我的任务来举例，我点击购买按钮之后跳转到对应的商品淘宝店，所以商品淘宝店的地址就需要写入数据库，所以现在新增一个自定义字段，点击输入新栏目 输入自定义名称和值，输入完成后点击添加自定义栏目 添加完之后就是如下图所示 自定义栏目添加成功了，那么问题来了，我们如何取到自定义栏目的值并显示在页面上呢？ 在WordPress中有个get_post_meta()的函数，官方的解释是： This function returns the values of the custom fields with the specified key from the specified post. 翻译过来大概的意思是：该函数用于取出用户设置的自定义字段的值。 用途 该函数的用处很多，很多主题用来设置文章相应图片的设置，这与将远程图像设置为缩略图有异曲同工之妙，当然自定义字段还可以用于存储许多我们觉得更有用的东西，例如统计信息，等等。 用法 &lt;?php $meta_values = get_post_meta($post_id, $key, $single); ?&gt; 参数解释 $post_id文章的ID（如果在循环中，你可以用 get_the_ID()来设置）,$key自定义字段的名称（键值）,$single是否以字符串形式返回，false会返回数组形式。 缺省用法 &lt;?php $value = get_post_meta(76, &#39;key&#39;); ?&gt; 实例 if (have_posts()) ://如果有文章 while (have_posts()) : the_post(); //开启主循环 $value = get_post_meta(get_the_ID(),&#39;custom_meta&#39;,true); endwhile; endif; 上面介绍完get_post_meta()函数，现在我们就来实现我的这个任务。在项目源代码中找到使用的主题的文件夹，我的文件夹位置为：htdocs/wp-content/themes/jitatheme/再找到function.php文件并打开，在这里我们将封装成一个获取地址的函数，代码如下： /** *获取淘宝店铺商品的地址 */ function getTB_Url($postID){ $key = &#39;direct_to_tb&#39;; $url = get_post_meta($postID, $key, true); return $url; } 然后找到我们要修改的页面，用一个&lt;a&gt;标签来实现点击跳转。我们在&lt;a&gt;标签的href属性中来调用刚才封装的函数，代码如下： &lt;a class=&quot;btn&quot; href=&quot;&lt;?php echo getTB_Url(get_the_ID()); ?&gt;&quot; target=&quot;_blank&quot;&gt;点击购买&lt;/a&gt; 最后在页面上点击测试一下，跳转正确，任务完毕。 总结 了解了如何在WordPress后台管理界面添加自定义栏目 了解了如何获取自定义栏目的值和get_post_meta()函数的使用"},{"title":"MVC&MVP模式有何不同","permalink":"http://zhongzilu.github.io/2016/05/10/MVC-MVP模式有何不同/","text":"MVC &amp; MVP模式有何不同标签 : MVP MVC 本文是翻译国外的一篇文章,英语水平有限,翻译有误的地方希望提出来,以方便修改,谢谢 原文传送门: http://www.infragistics.com/community/blogs/todd_snyder/archive/2007/10/17/mvc-or-mvp-pattern-whats-the-difference.aspx Over the years I have mentored many developers on using design patterns and best practices.多年来我有辅导过很多开发者使用设计模式和最佳实践 One question that keeps coming up over and over again is:What are the differences between the Model View Controller (MVC) and Model View Presenter (MVP) patterns?一遍又一遍出现的一个问题是: 模型 视图 控制器(MVC模式)和模型 视图 主持人(MVP模式)之间有哪些不同? Surprisingly the answer is more complex than what you would suspect.令人惊讶的是答案比你想象中的更复杂 Part of reasons I think many developers shy away from using either pattern is the confusion over the differences.我认为一部分原因是因为许多开发者回避使用两种模式带来的混乱 Before we dig into the differences let’s examine how the patterns work and the key benefits to using either one.在我们深入研究两种模式如何工作和使用其中一种带来的关键利益之前 Both (MVC &amp; MVP) patterns have been use for several years and address a key OO principal namely separation of concerns between the UI and the business layers.这两种模式(MVC &amp; MVP)已经使用了好几年,并且处理面向对象的关键就是分离界面UI层和业务层. There are a number of frameworks is use today that based on these patterns including: JAVA Struts, ROR, Microsoft Smart Client Software Factory (CAB), Microsoft Web Client Software Factory, and the recently announced ASP.Net MVC framework.这里有一些如今正在被使用的,基于这些模式的框架,包括:Java Struts, ROR, Microsoft Smart Client Software Factory (CAB), Microsoft Web Client Software Factory,还有最近发布的ASP.Net MVC框架 Model View Controller (MVC) Pattern The MVC pattern is a UI presentation pattern that focuses on separating the UI (View) from its business layer (Model).MVC模式是一个着重于从业务层(Model)分离UI(View)的UI表示模型 The pattern separates responsibilities across three components: the view is responsible for rending UI elements, the controller is responsible for responding to UI actions, and the model is responsible for business behaviors and state management.模型分离的重任横跨三个组件: 视图层负责渲染UI元素, 控制器负责响应UI操作, 模型层负责业务逻辑和状态管理. In most implementation all three components can directly interact with each other and in some implementations the controller is responsible for determining which view to display (Front Controller Pattern),多数的实现方法，可以使这三个组件互相直接作用影响，有一些实现的方法里，控制器负责确定哪些试图的显示（Front Controller Pattern) Model View Presenter (MVP) Pattern The MVP pattern is a UI presentation pattern based on the concepts of the MVC pattern.MVP模型是基于MVC模型的UI表示模型。 The pattern separates responsibilities across four components: the view is responsible for rending UI elements, the view interface is used to loosely couple the presenter from its view, the presenter is responsible for interacting between the view/model, and the model is responsible for business behaviors and state management.模型分离的重任横跨四个组件:视图层负责渲染UI元素， 视图层接口被用于把中介者（Presenter)从视图中解耦，中介者负责视图（View)和模型(Model)之间的交互,模型层负责业务逻辑和状态管理. In some implementations the presenter interacts with a service (controller) layer to retrieve/persist the model.在某些实现方法中，中介者会和服务层/控制器层交互来获取或持有model。 The view interface and service layer are commonly used to make writing unit tests for the presenter and the model easier.视图接口和服务层通常被用来编写中介者和模型之间的单元测试。 关键优势 Before using any pattern a developers needs to consider the pros and cons of using it.在使用任何开发模式之前，开发人员需要考虑使用它的优点和缺点。 There are a number of key benefits to using either the MVC or MVP pattern (See list below).这里有一些使用MVC和MVP模型的关键好处（请看下面的列表）。 But, there also a few drawbacks to consider. The biggest drawbacks are additional complexity and learning curve.但是，这里也有一些缺点需要考虑。最大的缺点就是它的复杂性和需要付出额外的学习成本。 While the patterns may not be appropriate for simple solutions; advance solutions can greatly benefit from using the pattern.这种模型可能不太适合一般的解决方案；好的解决方案可以从中获得更大的利益。 I’m my experience a have seen a few solutions eliminate a large amount of complexity but being re-factored to use either pattern.在我的经历中，我见过使用这些模式来重构项目，解决了不少的复杂的问题。 Loose coupling – The presenter/controller are an intermediary between the UI code and the model. This allows the view and the model to evolve independently of each other.松散耦合 - presenter或控制器在UI代码和模型之间充当着中间媒介的角色，这就使得视图和控制器之间互相独立。 Clear separation of concerns/responsibility清晰分离关注点和职责（关于concerns的翻译请自行有道）– UI (Form or Page) – Responsible for rending UI elementsUI(表单或页面） - 负责渲染UI元素 – Presenter/controller – Responsible for reacting to UI events and interacts with the model中介者/控制器 - 负责对UI事件与模型进行交互 – Model – Responsible for business behaviors and state management模型 - 负责业务逻辑和状态管理. Test Driven – By isolating each major component (UI, Presenter/controller, and model) it is easier to write unit tests. This is especially true when using the MVP pattern which only interacts with the view using an interface.测试驱动 - 通过分离每个主要组件（UI,Presenter/controller, model)更容易编写单元测试，当使用MVP模型且只通过接口来和视图层交互时，就更应该这样做。 Code Reuse – By using a separation of concerns/responsible design approach you will increase code reuse. This is especially true when using a full blown domain model and keeping all the business/state management logic where it belongs.代码复用 - 通过使用分离关注点和职责的设计可以增加你的代码复用。在使用全面的域模型和保持所属业务和状态管理的逻辑时，就更应该这样做。 Hide Data Access – Using these patterns forces you to put the data access code where it belongs in a data access layer. There a number of other patterns that typical works with the MVP/MVC pattern for data access. Two of the most common ones are repository and unit of work. (See Martin Fowler – Patterns of Enterprise Application Architecture for more details)隐藏数据访问 - 使用这种模式会强迫你使用数据接入层中的数据接入代码。这里有一些其他典型的使用MVP/MVC模型来进行数据访问的模型，最常见的两个就是库和工作单元。（想看更多细节请看Martin Fowler的企业应用架构模式【Martin Fowler - Patterns of Enterprise Application Architecture】) Flexibility/Adaptable – By isolating most of your code into the presenter/controller and model components your code base is more adaptable to change. For example consider how much UI and data access technologies have changed over the years and the number of choices we have available today. A properly design solution using MVC or MVP can support multi UI and data access technologies at the same time.灵活/适用 - 通过分离Presenter/controller和model组件可以使你的代码更灵活适用.举个例子,这些年来有许多UI技术和数据接入技术都有所改变,如今我们有许多的选择.恰当的使用MVC或者MVP模式来设计解决方案,可以同时支持多种UI技术和数据接入技术. 关键区别 So what really are the differences between the MVC and MVP pattern.Actually there are not a whole lot of differences between them.因此,MVC和MVP模式之间真正的区别.其实是没有太多区别. Both patterns focus on separating responsibility across multi components and promote loosely coupling the UI (View) from the business layer (Model).这两者都是专注跨组件分离职责,促进UI层从业务层中解耦. The major differences are how the pattern is implemented and in some advanced scenarios you need both presenters and controllers.主要的区别在于如何实现,在某些高级的应用场景中需要同时有Presenter和Controler Here are the key differences between the patterns:这里有些这两种模式之间的关键区别: MVP模式– View is more loosely coupled to the model. The presenter is responsible for binding the model to the view.视图和模型之间耦合更加松散.中介者负责把model绑定到视图层.– Easier to unit test because interaction with the view is through an interface更加容易编写单元测试,因为都是通过接口和视图交互的.– Usually view to presenter map one to one. Complex views may have multi presenters.通常情况下,视图和中介者是一一对应的.复杂的视图可能会有多个中介者. MVC模式– Controller are based on behaviors and can be shared across views控制器是建立在行为上的,并且可以跨视图共享– Can be responsible for determining which view to display能够负责决定要显示哪个视图 Hopefully you found this post interesting and it helped clarify the differences between the MVC and MVP pattern.希望你会觉得这篇文章是有趣的,这篇文章会帮助你理清MVC和MVP模式之间的区别. If not, do not be discouraged patterns are powerful tools that can be hard to use sometimes.如果没理清,请不要泄气,模型是一个强大的工具,以至于有时在使用时会觉得很困难 One thing to remember is that a pattern is a blue print and not an out of the box solutions.你只需要记住,模型只是一个蓝图,并不是快速的解决方案. Developers should use them as a guide and modify the implementation according to their problem domain.开发者应该把它们作为指导手册,并根据遇到的问题修正实现方案. 作者 :zhongzilu"},{"title":"Android开发之MVP初体验","permalink":"http://zhongzilu.github.io/2016/05/10/Android开发之MVP初体验/","text":"Android开发 MVP之初体验标签 ：Android MVP MVC 熟悉安卓开发的童鞋应该都熟悉MVC架构模式, MVC开发模式即: Model(模型) – View(视图) – Control(控制器) 逻辑图如下: 而这种开发模式有个缺点,就是在项目越来越大时,文件会越来越多,查找起来很不方便,而且Activity或者Fragment里面的代码会越来越臃肿,看起来很凌乱,要修改更是让人头疼,于是就提出了一种MVP的开发模式,MVP开发模式即: Model(模型) – View(视图) – Presente(任命者/中介) 逻辑图如下: 网上有很多讲解MVP的文章和教程,我这里就不详细介绍了,但还有很多人看过教程之后依然不知如何实现MVP,今天主要通过实际代码的方式来体验MVP开发 本次使用的代码为Github上的一个开源项目,名为androidmvp 传送门 https://github.com/antoniolg/androidmvp 先看看界面界面很简单,就是一个登录界面和一个ListView填充的主界面,登录之后跳转到主界面,主界面上显示一个列表 第一步用Android Studio打开项目之后可以看到如下的项目结构 通过截图可以看出,该项目是根据界面来分类的,Login文件夹下放的是所有与登录界面有关的文件,main文件夹下放的是所有与主界面有关的文件 其中, Login文件夹下共有6个文件, 3个类文件, 3个接口文件 类文件: LoginActivity LoginInteratorImpl LoginPresenterImpl 接口文件: LoginView LoginInteractor LoginPresenter 第二步打开LoginActivity.java文件 public class LoginActivity extends Activity implements LoginView, View.OnClickListener { private ProgressBar progressBar; private EditText username; private EditText password; private LoginPresenter presenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); //实例化控件 ... presenter = new LoginPresenterImpl(this); } ... 从上面代码可以看出,该Activity实现了LoginView的接口和View的点击事件, 并且实例化了一个LoginPresenterImpl对象 现在打开LoginView.java public interface LoginView { void showProgress(); void hideProgress(); void setUsernameError(); void setPasswordError(); void navigateToHome(); } 可以看到LoginView文件中定义了几个接口, 通过名称可以很容易知道每个接口是用来干什么的返回LoginActivity也很容易发现是如何实现这几个接口的,如下: Override public void showProgress() { progressBar.setVisibility(View.VISIBLE); } Override public void hideProgress() { progressBar.setVisibility(View.GONE); } Override public void setUsernameError() { username.setError(getString(R.string.username_error)); } Override public void setPasswordError() { password.setError(getString(R.string.password_error)); } @Override public void navigateToHome() { startActivity(new Intent(this, MainActivity.class)); finish(); } 打开LoginPresenter.java public interface LoginPresenter { void validateCredentials(String username, String password); void onDestroy(); } 可以看到定义了两个接口,其中validateCredentials接口是用来验证用户名和密码是否通过验证的在LoginActivity中也有实现 @Override public void onClick(View v) { presenter.validateCredentials(username.getText().toString(), password.getText().toString()); } 看到这里, 我们可以总结出LoginActivity没有做任何逻辑相关的事情,而是在做界面显示相关和界面跳转的事情, 就连验证帐号的逻辑都是交给LoginPresenterImpl类的 那么现在顺藤摸瓜,打开LoginPresenterImpl.java文件 public class LoginPresenterImpl implements LoginPresenter, LoginInteractor.OnLoginFinishedListener { private LoginView loginView; private LoginInteractor loginInteractor; public LoginPresenterImpl(LoginView loginView) { this.loginView = loginView; this.loginInteractor = new LoginInteractorImpl(); } //其他方法的实现 ... } 我们可以看到该类实现了LoginPresenter和LoginInteractor.OnLoginFinishedListener的接口, 并且在构造方法的参数为LoginView, 那么问题来了, 为什么要传递LoginView类型的参数呢? 我们刚才也看到了,在LoginView中定义了几个接口, 而在LoginActivity中有对这几个接口的实现, 所以传递这个参数, 是有利于LoginPresenterImpl类调用LoginActivity的实现方法, 用于界面上的显示, 这就达到了逻辑代码和显示代码的分离 好了,现在来看看是怎么实现LoginPresenter中的validateCredentials接口的吧 @Override public void validateCredentials(String username, String password) { if (loginView != null) { loginView.showProgress(); } loginInteractor.login(username, password, this); } 看到这里,有同学该有疑问了,为什么在这个方法里我没看到实现帐号验证的具体逻辑呢? 没错,这里不应该有帐号验证的具体逻辑代码,因为LoginPresenterImpl类充当的是任命者或者称中介者的身份, 中介者只负责联系界面类和具体实现逻辑代码的类,如果还不能理解,就想想房地产中介吧, 他们只负责联系买房者和卖房者, 其他的事都不管(抱歉, 我没有鄙视或看不起房地产中介人员的意思, 这里只是做个举例, 在此说声对不起). 我们看到代码中, 把接收到的username和password参数传递给了一个login方法, 该方法在LoginInteractor文件中, 我们再打开LoginInteractor.java文件 public interface LoginInteractor { interface OnLoginFinishedListener { void onUsernameError(); void onPasswordError(); void onSuccess(); } void login(String username, String password, OnLoginFinishedListener listener); } 可以定义了一个login接口和一个OnLoginFinishedListener接口类, 返回LoginPresenterImpl.java文件可以很容易看到OnLoginFinishedListener接口类中接口的实现 @Override public void onUsernameError() { if (loginView != null) { loginView.setUsernameError(); loginView.hideProgress(); } } @Override public void onPasswordError() { if (loginView != null) { loginView.setPasswordError(); loginView.hideProgress(); } } @Override public void onSuccess() { if (loginView != null) { loginView.navigateToHome(); } } 在这些接口的实现中同样只是调用LoginView中的接口,并没有具体的逻辑操作代码 在该类的构造方法中我们会发现, 这里实例化了一个LoginInteractorImpl对象, 我们现在打开LoginInteractorImpl.java文件 public class LoginInteractorImpl implements LoginInteractor { @Override public void login(final String username, final String password, final OnLoginFinishedListener listener) { // Mock login. I&#39;m creating a handler to delay the answer a couple of seconds new Handler().postDelayed(new Runnable() { @Override public void run() { boolean error = false; if (TextUtils.isEmpty(username)){ listener.onUsernameError(); error = true; } if (TextUtils.isEmpty(password)){ listener.onPasswordError(); error = true; } if (!error){ listener.onSuccess(); } } }, 2000); } } 我们可以看到该类实现了LoginInteractor中的login接口, 并且在login方法中进行了具体的逻辑处理, 如果验证通过, 调用onSuccess接口 好了,整个登录流程讲完了,最后我们再来梳理一下整个流程: 在LoginActivity中,通过LoginPresenter接口类中的validateCredentials接口,把username和password传递给LoginPresenter的实现类LoginPresenterImpl LoginPresenterImpl类再通过LoginInteractor接口类中的login接口, 把username和password传递给LoginInteractor的实现类LoginInteractorImpl 在LoginInteractorImpl类中进行具体的逻辑处理, 如果验证通过,则调用LoginInteractor.OnLoginFinishedListener接口类中的onSuccess接口, 即调用了LoginPresenterImpl类中实现的onSuccess接口 LoginPresenterImpl类中实现的onSuccess接口中,调用了LoginView接口类中的navigateToHome接口,即调用了LoginActivity类中实现的navigateToHome接口 最后在navigateToHome接口中实现Activity的跳转,跳转到MainActivity 流程图如下: 总结在MVP开发模式中, Activity只负责界面的显示和跳转相关的操作, 具体的逻辑处理通过调用接口来传递给Presenter(中介者) 既不做界面显示的操作,也不做具体的逻辑处理操作, 具体的逻辑处理通过调用接口,让Interactor即交互类来完成 交互类的逻辑处理结果,通过调用Presenter中实现的接口, 再由Presenter要实现的接口中调用Activity中实现的接口来进行UI的显示或界面跳转 最后好了,安卓开发 MVP之初体验讲完了,写了那么多,希望大家能够看懂了,如果还有什么问题,可以问我Follow Me"},{"title":"【微表情心理学】耳朵的秘密","permalink":"http://zhongzilu.github.io/2016/05/10/【微表情心理学】耳朵的秘密/","text":"如果你仔细观察我们的耳朵，你会发现耳朵就像一个倒置的胎儿。他的头部朝下，臀部朝上。耳朵可以被看做事他人体的缩小版 耳朵大小某种程度上体现一个人的生命力和思想深度通常来说，一个人的耳朵越大，他就越充满激情和活力，他多半精力旺盛，但也很容易脾气暴躁，比如美国前总统比尔·克林顿。耳朵中等大小的人，多半思想冷静、理性而客观，比如法国影星苏菲·玛索。而小耳朵的人，多半具有很强的观察力，而且适应能力很强，对待事情也比较有耐心 耳朵反映一个人的性格特征大耳朵的人多半活力四射，行动力和执行力比较强，有个性，有思想 耳朵外形美观的人，内心相对平静，富有想象力，具有坚持不懈的品质和乐于竞争的精神 耳轮在起始处粗壮，而在走向中间的部位是剧烈变细的人多半比较顽固，敏感，情绪不稳定，容易消沉 耳朵外形粗糙，粗笨或过宽，过厚，此人往往比较麻木缺乏感情，思维不受控制，甚至有时还很野蛮，具有强烈的攻击性 中等大小的耳朵为正常耳朵，虽不具备丰富想象力和热情，但感情稳定，不易出现波动，而且做事更加理性，逻辑性思维很强，做事前喜欢深思熟虑，权衡再三，与人交往时不会无理争辩，而是做出让人信服的言论。总之此类人为人处世相对稳重，并且善于处理工作和生活之间的关系 小耳朵通常缺乏强烈的野心，自信心，想象力和创造性，但他们多半反应迅速，身体灵敏，并且具有极强的专注力和观察力。性情上，一般较为敏感，更容易闷闷不乐，郁郁寡欢，也常陷入悲观局面。但他们行事严谨，很少出现差错，往往也会取得令人骄傲的成绩 扯耳朵或摸耳垂在谈话中，很多人习惯做出扯耳朵或者摸耳垂的动作，通常这种动作表示他们试图打断对方说话。 摸耳垂的动作是一种自我触摸，自我安慰的行为。通常当人们对谈话内容不感兴趣而产生乏味，无趣的情绪甚至对内容反感时会出现此举动。一方面是想要打断对方的潜意识，另一方面是借此来安抚自己消除内心的浮躁和不安。 当人们紧张、内心焦虑不安、说谎、表示反对意见时也会有此举动 咬嘴唇或隐藏嘴唇出现此举通常是由于出现某种压力或紧张情绪。这是一种消极情绪 突然收拢嘴唇或嘟起嘴，如果在谈话时出现此举动，通常说明此人对所讲话的内容在心理上出现了反对意见或是不完全认可的态度，此时他正在思考怎么样转换正在谈论的话题或者是准备提出自己的不同意见 作者：zhongzilu"}]}