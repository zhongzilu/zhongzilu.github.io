<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Hello from zhongzilu]]></title>
      <url>http://zhongzilu.github.io/2017/02/20/Hello-from-zhongzilu/</url>
      <content type="html"><![CDATA[<h2 id="Hello-from-Zhongzilu"><a href="#Hello-from-Zhongzilu" class="headerlink" title="Hello from Zhongzilu"></a>Hello from Zhongzilu</h2><p>Welcome to BIT100.I’m zilu Zhong,an Android developer.Here is my blog website.I will post some blog articel which include technology,psychology and other notes in some time.In order to facilitating more people,I will sharing something which is be useful to everyone,because i believe that the knowledge more sharing more valuable.Sorry!My English is poor.So,Don’t be care.</p>
<p>欢迎来到我的网站，我是钟子路(zhongzilu)，是一个安卓开发者。这个网站是我的博客网站，我会不定时更新一些博客，博客类型包括技术博客，心理学笔记以及一些随笔，总之，是把我觉得对大家有用的东西分享出来，以便利更多人。我相信，知识越分享越有价值。</p>
<p><strong>作者</strong>：zhongzilu<br><strong>GitHub</strong>： <a href="https://github.com/zhongzilu" target="_blank" rel="external">https://github.com/zhongzilu</a><br><strong>简书</strong>: <a href="http://www.jianshu.com/users/0551ca89845b/latest_articles" target="_blank" rel="external">http://www.jianshu.com/users/0551ca89845b/latest_articles</a><br><strong>安卓社区</strong>: <a href="http://ask.android-studio.org/?/people/zhongzilu" target="_blank" rel="external">http://ask.android-studio.org/?/people/zhongzilu</a><br><strong>网易云音乐</strong> <a href="http://music.163.com/#/user/home?id=28448237" target="_blank" rel="external">http://music.163.com/#/user/home?id=28448237</a><br><strong>微博</strong> <a href="http://weibo.com/2719197280/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" rel="external">http://weibo.com/2719197280/profile?topnav=1&amp;wvr=6&amp;is_all=1</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://zhongzilu.github.io/2017/02/20/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在Android Studio(IntelliJ)中创建Live Templates]]></title>
      <url>http://zhongzilu.github.io/2016/05/10/%E5%A6%82%E4%BD%95%E5%9C%A8Android-Studio-IntelliJ-%E4%B8%AD%E5%88%9B%E5%BB%BALive-Templates/</url>
      <content type="html"><![CDATA[<h2 id="如何在Android-Studio-IntelliJ中创建Live-Templates"><a href="#如何在Android-Studio-IntelliJ中创建Live-Templates" class="headerlink" title="如何在Android Studio/IntelliJ中创建Live Templates"></a>如何在Android Studio/IntelliJ中创建Live Templates</h2><p>标签： <code>Android Studio</code> <code>IntelliJ Live</code> <code>Template</code> </p>
<h3 id="何为Live-Templates"><a href="#何为Live-Templates" class="headerlink" title="何为Live Templates?"></a>何为Live Templates?</h3><blockquote>
<p>frequently-used or custom code constructs that you can insert into your source code file quickly, efficiently and accurately.<br>快速，高效，准确的将常用或自定义构造代码插入到你的源代码文件中</p>
</blockquote>
<p>通俗的讲，就是像快捷键一样，只需要输入几个简写的英文字母就可以快速自动插入一行或多行代码。</p>
<p>在Android Studio/IntelliJ编辑器中，默认使用<code>Ctrl + J</code>快捷键可以调出Live Templates，可以自动补全所设置的模板的代码，善用它能够很大程度上减少开发时间。</p>
<p>举个例子，输入<code>psfi</code>，然后按回车键，编辑器将会自动生成代码<code>public static final int</code>，这就节省了19个要输入的字母。</p>
<p>Android Studio/IntelliJ编辑器中预置了一些常用的Live Templates，大家可以自行去查看，查看位置<code>File ==&gt; Settings ==&gt; Editor ==&gt; Live Templates</code><br><img src="http://www.bit100.com/.zhongzilu/image/1462599293525.png" alt="Live Templates"></p>
<h3 id="如何创建自定义的Live-Templates？"><a href="#如何创建自定义的Live-Templates？" class="headerlink" title="如何创建自定义的Live Templates？"></a>如何创建自定义的Live Templates？</h3><ul>
<li><p>找到Live Templates的位置，然后点击右上角的<code>+</code>号，再选择<code>Template Group</code>，写上一个名称<br><img src="http://www.bit100.com/.zhongzilu/image/1462602208553.png" alt="Template Group"><br><img src="http://www.bit100.com/.zhongzilu/image/1462602471454.png" alt="Custom Template Group"></p>
</li>
<li><p>接着再点击<code>+</code>号，选择<code>Live Template</code>，之后填写相关的内容<br><img src="http://www.bit100.com/.zhongzilu/image/1462602753037.png" alt=""></p>
</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>我用一个快速插入RecyclerView控件代码的例子来举例，设置如下图：<br><img src="http://www.bit100.com/.zhongzilu/image/1462603188209.png" alt="RecyclerView Live Template"></p>
<p>填写相关内容完毕之后 ，注意下方的一行红字，此时定义的Live Template还没生效，需要点击<code>Define</code>，然后选择该Live Template要应用到什么样的场景中。因为这里我定义的是安卓的控件代码，所以就归类为XML</p>
<p><img src="http://www.bit100.com/.zhongzilu/image/1462604207098.png" alt="Define Live Template"></p>
<p>点击<code>OK</code>按钮生效。注意勾选右下角的<code>Reformat according to style</code>选项</p>
<p>要想使用刚才定义的Live Template，只需要在android的XML布局文件中输入rcv，然后按回车键就可以了，如下图所示：<br><img src="http://www.bit100.com/.zhongzilu/image/recyclerviewtemplate.gif" alt="Use Live Template"></p>
<p><strong>以上就是如何在Android Studio/IntelliJ编辑器中创建Live Template的方法，相信富有创意的各位能够创建出更多的更方便的Live Template，这对于今后的代码编写大有裨益</strong></p>
<p>另外，我在这里推荐一篇博客：<a href="http://blog.csdn.net/DesmondJ/article/details/47017205" target="_blank" rel="external">http://blog.csdn.net/DesmondJ/article/details/47017205</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Wordpress自定义栏目的使用]]></title>
      <url>http://zhongzilu.github.io/2016/05/10/Wordpress%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%8F%E7%9B%AE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="WordPress自定义栏目的使用"><a href="#WordPress自定义栏目的使用" class="headerlink" title="WordPress自定义栏目的使用"></a>WordPress自定义栏目的使用</h2><blockquote>
<p><strong>前言</strong></p>
<p>最近有个任务，要实现在公司官网上点击某个商品的购买按钮，就跳转到对应的淘宝店页面去。由于公司官网用的WordPress平台，我之前只是听说过，并没有实质性使用过，所以一开始就是一头雾水，再加上网站原本是由外包公司做的，交接时没有任何文档，因此我根本不知如何下手，但最后还是硬着头皮去做了。</p>
</blockquote>
<p>我思考着要完成这个任务我需要怎么做，由于网站上的内容都是动态从数据库中取的，所以如果我要实现点击购买按钮就跳转到对应网店的功能，就不可能在代码中把跳转的店铺地址写死了，必须要从数据库中去读取，并且还要和商品关联起来才行。</p>
<p>这其中肯定涉及到把链接地址写入数据库，WordPress提供了一个管理后台，通过管理后台可以把数据写入数据库。</p>
<p>打开后台，找到文章编辑页面，在右上方有个<code>显示选项</code>，展开后可以显示和隐藏模块。勾选<code>自定义栏目</code><br><img src="http://www.bit100.com/.zhongzilu/image/1460715829974.png" alt="显示选项"></p>
<p>在页面下方可以看到这个模块，在这里可以新增自定义的数据字段，并给它赋值。<br><img src="http://www.bit100.com/.zhongzilu/image/1460715932310.png" alt="自定义栏目"></p>
<p>拿我的任务来举例，我点击购买按钮之后跳转到对应的商品淘宝店，所以商品淘宝店的地址就需要写入数据库，所以现在新增一个自定义字段，点击<code>输入新栏目</code><br><img src="http://www.bit100.com/.zhongzilu/image/1460716205273.png" alt="添加自定义栏目"></p>
<p>输入自定义名称和值，输入完成后点击<code>添加自定义栏目</code><br><img src="http://www.bit100.com/.zhongzilu/image/1460716383075.png" alt="添加自定义栏目"></p>
<p>添加完之后就是如下图所示<br><img src="http://www.bit100.com/.zhongzilu/image/1460773373270.png" alt="添加自定义栏目成功"></p>
<p><strong>自定义栏目添加成功了，那么问题来了，我们如何取到自定义栏目的值并显示在页面上呢？</strong></p>
<p>在WordPress中有个<code>get_post_meta()</code>的函数，官方的解释是：</p>
<blockquote>
<p>This function returns the values of the custom fields with the specified key from the specified post.</p>
</blockquote>
<p>翻译过来大概的意思是：该函数用于取出用户设置的自定义字段的值。</p>
<p><strong>用途</strong></p>
<p>该函数的用处很多，很多主题用来设置文章相应图片的设置，这与将远程图像设置为缩略图有异曲同工之妙，当然自定义字段还可以用于存储许多我们觉得更有用的东西，例如统计信息，等等。</p>
<p><strong>用法</strong></p>
<blockquote>
<p><code>&lt;?php $meta_values = get_post_meta($post_id, $key, $single); ?&gt;</code></p>
</blockquote>
<p><strong>参数解释</strong></p>
<blockquote>
<p><code>$post_id</code>文章的ID（如果在循环中，你可以用 get_the_ID()来设置）,<br><code>$key</code>自定义字段的名称（键值）,<br><code>$single</code>是否以字符串形式返回，false会返回数组形式。</p>
</blockquote>
<p><strong>缺省用法</strong></p>
<blockquote>
<p><code>&lt;?php $value = get_post_meta(76, &#39;key&#39;); ?&gt;</code></p>
</blockquote>
<p><strong>实例</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (have_posts()) :<span class="comment">//如果有文章</span></div><div class="line"> <span class="keyword">while</span> (have_posts()) : the_post(); <span class="comment">//开启主循环</span></div><div class="line">   $value  = get_post_meta(get_the_ID(),<span class="string">'custom_meta'</span>,<span class="keyword">true</span>);</div><div class="line"> <span class="keyword">endwhile</span>; </div><div class="line"> <span class="keyword">endif</span>;</div></pre></td></tr></table></figure></p>
<p>上面介绍完<code>get_post_meta()</code>函数，现在我们就来实现我的这个任务。<br>在项目源代码中找到使用的主题的文件夹，我的文件夹位置为：<code>htdocs/wp-content/themes/jitatheme/</code><br>再找到<code>function.php</code>文件并打开，在这里我们将封装成一个获取地址的函数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*获取淘宝店铺商品的地址</div><div class="line">*/</div><div class="line">function getTB_Url($postID)&#123;</div><div class="line">  $key = &apos;direct_to_tb&apos;;</div><div class="line">  $url = get_post_meta($postID, $key, true);</div><div class="line">  return $url;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后找到我们要修改的页面，用一个<code>&lt;a&gt;</code>标签来实现点击跳转。我们在<code>&lt;a&gt;</code>标签的href属性中来调用刚才封装的函数，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a class=&quot;btn&quot; href=&quot;&lt;?php echo getTB_Url(get_the_ID()); ?&gt;&quot; target=&quot;_blank&quot;&gt;点击购买&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<p>最后在页面上点击测试一下，跳转正确，任务完毕。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ul>
<li>了解了如何在WordPress后台管理界面添加自定义栏目</li>
<li>了解了如何获取自定义栏目的值和<code>get_post_meta()</code>函数的使用</li>
</ul>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[MVC&MVP模式有何不同]]></title>
      <url>http://zhongzilu.github.io/2016/05/10/MVC-MVP%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/</url>
      <content type="html"><![CDATA[<h1 id="MVC-amp-MVP模式有何不同"><a href="#MVC-amp-MVP模式有何不同" class="headerlink" title="MVC &amp; MVP模式有何不同"></a>MVC &amp; MVP模式有何不同</h1><p>标签 :  MVP MVC</p>
<hr>
<p><strong>本文是翻译国外的一篇文章,英语水平有限,翻译有误的地方希望提出来,以方便修改,谢谢</strong></p>
<blockquote>
<p>原文传送门: <a href="http://www.infragistics.com/community/blogs/todd_snyder/archive/2007/10/17/mvc-or-mvp-pattern-whats-the-difference.aspx" target="_blank" rel="external">http://www.infragistics.com/community/blogs/todd_snyder/archive/2007/10/17/mvc-or-mvp-pattern-whats-the-difference.aspx</a></p>
</blockquote>
<hr>
<blockquote>
<p>Over the years I have mentored many developers on using design patterns and best practices.<br>多年来我有辅导过很多开发者使用设计模式和最佳实践</p>
<p>One question that keeps coming up over and over again is:What are the differences between the Model View Controller (MVC) and Model View Presenter (MVP) patterns?<br>一遍又一遍出现的一个问题是: 模型 视图 控制器(MVC模式)和模型 视图 主持人(MVP模式)之间有哪些不同?</p>
<p>Surprisingly the answer is more complex than what you would suspect.<br>令人惊讶的是答案比你想象中的更复杂</p>
<p>Part of reasons I think many developers shy away from using either pattern is the confusion over the differences.<br>我认为一部分原因是因为许多开发者回避使用两种模式带来的混乱</p>
<p>Before we dig into the differences let’s examine how the patterns work and the key benefits to using either one.<br>在我们深入研究两种模式如何工作和使用其中一种带来的关键利益之前</p>
<p>Both (MVC &amp; MVP) patterns have been use for several years and address a key OO principal namely separation of concerns between the UI and the business layers.<br>这两种模式(MVC &amp; MVP)已经使用了好几年,并且处理面向对象的关键就是分离界面UI层和业务层.</p>
<p>There are a number of frameworks is use today that based on these patterns including: JAVA Struts, ROR, Microsoft Smart Client Software Factory (CAB), Microsoft Web Client Software Factory, and the recently announced ASP.Net MVC framework.<br>这里有一些如今正在被使用的,基于这些模式的框架,包括:Java Struts, ROR, Microsoft Smart Client Software Factory (CAB), Microsoft Web Client Software Factory,还有最近发布的ASP.Net MVC框架</p>
<p><strong>Model View Controller (MVC) Pattern</strong><br><img src="http://www.bit100.com/.zhongzilu/image/MVC_View.jpg" alt="MVC"></p>
<p>The MVC pattern is a UI presentation pattern that focuses on separating the UI (View) from its business layer (Model).<br>MVC模式是一个着重于从业务层(Model)分离UI(View)的UI表示模型</p>
<p>The pattern separates responsibilities across three components: the view is responsible for rending UI elements, the controller is responsible for responding to UI actions, and the model is responsible for business behaviors and state management.<br>模型分离的重任横跨三个组件: 视图层负责渲染UI元素, 控制器负责响应UI操作, 模型层负责业务逻辑和状态管理.</p>
<p>In most implementation all three components can directly interact with each other and in some implementations the controller is responsible for determining which view to display (<a href="https://msdn.microsoft.com/en-us/library/ms978723.aspx" target="_blank" rel="external">Front Controller Pattern</a>),<br>多数的实现方法，可以使这三个组件互相直接作用影响，有一些实现的方法里，控制器负责确定哪些试图的显示（<a href="https://msdn.microsoft.com/en-us/library/ms978723.aspx" target="_blank" rel="external">Front Controller Pattern</a>)</p>
<p><strong>Model View Presenter (MVP) Pattern</strong><br><img src="http://www.bit100.com/.zhongzilu/image/MVP_View.jpg" alt="MVP"></p>
<p>The MVP pattern is a UI presentation pattern based on the concepts of the MVC pattern.<br>MVP模型是基于MVC模型的UI表示模型。</p>
<p>The pattern separates responsibilities across four components: the view is responsible for rending UI elements, the view interface is used to loosely couple the presenter from its view, the presenter is responsible for interacting between the view/model, and the model is responsible for business behaviors and state management.<br>模型分离的重任横跨四个组件:视图层负责渲染UI元素， 视图层接口被用于把中介者（Presenter)从视图中解耦，中介者负责视图（View)和模型(Model)之间的交互,模型层负责业务逻辑和状态管理.</p>
<p>In some implementations the presenter interacts with a service (controller) layer to retrieve/persist the model.<br>在某些实现方法中，中介者会和服务层/控制器层交互来获取或持有model。</p>
<p>The view interface and service layer are commonly used to make writing unit tests for the presenter and the model easier.<br>视图接口和服务层通常被用来编写中介者和模型之间的单元测试。</p>
</blockquote>
<h2 id="关键优势"><a href="#关键优势" class="headerlink" title="关键优势"></a>关键优势</h2><blockquote>
<p>Before using any pattern a developers needs to consider the pros and cons of using it.<br>在使用任何开发模式之前，开发人员需要考虑使用它的优点和缺点。</p>
<p>There are a number of key benefits to using either the MVC or MVP pattern (See list below).<br>这里有一些使用MVC和MVP模型的关键好处（请看下面的列表）。</p>
<p>But, there also a few drawbacks to consider. The biggest drawbacks are additional complexity and learning curve.<br>但是，这里也有一些缺点需要考虑。最大的缺点就是它的复杂性和需要付出额外的学习成本。</p>
<p>While the patterns may not be appropriate for simple solutions; advance solutions can greatly benefit from using the pattern.<br>这种模型可能不太适合一般的解决方案；好的解决方案可以从中获得更大的利益。</p>
<p>I’m my experience a have seen a few solutions eliminate a large amount of complexity but being re-factored to use either pattern.<br>在我的经历中，我见过使用这些模式来重构项目，解决了不少的复杂的问题。</p>
<ul>
<li><p>Loose coupling – The presenter/controller are an intermediary between the UI code and the model. This allows the view and the model to evolve independently of each other.<br>松散耦合 - presenter或控制器在UI代码和模型之间充当着中间媒介的角色，这就使得视图和控制器之间互相独立。</p>
</li>
<li><p>Clear separation of concerns/responsibility<br>清晰分离关注点和职责（关于concerns的翻译请自行有道）<br>– UI (Form or Page) – Responsible for rending UI elements<br>UI(表单或页面） - 负责渲染UI元素<br> – Presenter/controller – Responsible for reacting to UI events and interacts with the model<br>中介者/控制器 - 负责对UI事件与模型进行交互<br> – Model – Responsible for business behaviors and state management<br>模型 - 负责业务逻辑和状态管理.</p>
</li>
<li><p>Test Driven – By isolating each major component (UI, Presenter/controller, and model) it is easier to write unit tests. This is especially true when using the MVP pattern which only interacts with the view using an interface.<br>测试驱动 - 通过分离每个主要组件（UI,Presenter/controller, model)更容易编写单元测试，当使用MVP模型且只通过接口来和视图层交互时，就更应该这样做。</p>
</li>
<li><p>Code Reuse – By using a separation of concerns/responsible design approach you will increase code reuse. This is especially true when using a full blown domain model and keeping all the business/state management logic where it belongs.<br>代码复用 - 通过使用分离关注点和职责的设计可以增加你的代码复用。在使用全面的域模型和保持所属业务和状态管理的逻辑时，就更应该这样做。</p>
</li>
<li><p>Hide Data Access – Using these patterns forces you to put the data access code where it belongs in a data access layer. There a number of other patterns that typical works with the MVP/MVC pattern for data access. Two of the most common ones are repository and unit of work. (See Martin Fowler – Patterns of Enterprise Application Architecture for more details)<br>隐藏数据访问 - 使用这种模式会强迫你使用数据接入层中的数据接入代码。这里有一些其他典型的使用MVP/MVC模型来进行数据访问的模型，最常见的两个就是库和工作单元。（想看更多细节请看Martin Fowler的企业应用架构模式【Martin Fowler - Patterns of Enterprise Application Architecture】)</p>
</li>
<li><p>Flexibility/Adaptable – By isolating most of your code into the presenter/controller and model components your code base is more adaptable to change. For example consider how much UI and data access technologies have changed over the years and the number of choices we have available today. A properly design solution using MVC or MVP can support multi UI and data access technologies at the same time.<br>灵活/适用 - 通过分离Presenter/controller和model组件可以使你的代码更灵活适用.举个例子,这些年来有许多UI技术和数据接入技术都有所改变,如今我们有许多的选择.恰当的使用MVC或者MVP模式来设计解决方案,可以同时支持多种UI技术和数据接入技术.</p>
</li>
</ul>
</blockquote>
<h2 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h2><blockquote>
<p>So what really are the differences between the MVC and MVP pattern.<br>Actually there are not a whole lot of differences between them.<br>因此,MVC和MVP模式之间真正的区别.其实是没有太多区别.</p>
<p>Both patterns focus on separating responsibility across multi components and promote loosely coupling the UI (View) from the business layer (Model).<br>这两者都是专注跨组件分离职责,促进UI层从业务层中解耦.</p>
<p>The major differences are how the pattern is implemented and in some advanced scenarios you need both presenters and controllers.<br>主要的区别在于如何实现,在某些高级的应用场景中需要同时有Presenter和Controler</p>
<p>Here are the key differences between the patterns:<br>这里有些这两种模式之间的关键区别:</p>
<ul>
<li><p>MVP模式<br>– View is more loosely coupled to the model. The presenter is responsible for binding the model to the view.<br>视图和模型之间耦合更加松散.中介者负责把model绑定到视图层.<br>– Easier to unit test because interaction with the view is through an interface<br>更加容易编写单元测试,因为都是通过接口和视图交互的.<br>– Usually view to presenter map one to one. Complex views may have multi presenters.<br>通常情况下,视图和中介者是一一对应的.复杂的视图可能会有多个中介者.</p>
</li>
<li><p>MVC模式<br>– Controller are based on behaviors and can be shared across views<br>控制器是建立在行为上的,并且可以跨视图共享<br>– Can be responsible for determining which view to display<br>能够负责决定要显示哪个视图</p>
</li>
</ul>
<p>Hopefully you found this post interesting and it helped clarify the differences between the MVC and MVP pattern.<br>希望你会觉得这篇文章是有趣的,这篇文章会帮助你理清MVC和MVP模式之间的区别.</p>
<p>If not, do not be discouraged patterns are powerful tools that can be hard to use sometimes.<br>如果没理清,请不要泄气,模型是一个强大的工具,以至于有时在使用时会觉得很困难</p>
<p>One thing to remember is that a pattern is a blue print and not an out of the box solutions.<br>你只需要记住,模型只是一个蓝图,并不是快速的解决方案.</p>
<p>Developers should use them as a guide and modify the implementation according to their problem domain.<br>开发者应该把它们作为指导手册,并根据遇到的问题修正实现方案.</p>
</blockquote>
<hr>
<blockquote>
<p><strong>作者</strong> :<a href="http://www.bit100.com" target="_blank" rel="external">zhongzilu</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Android开发之MVP初体验]]></title>
      <url>http://zhongzilu.github.io/2016/05/10/Android%E5%BC%80%E5%8F%91%E4%B9%8BMVP%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="Android开发-MVP之初体验"><a href="#Android开发-MVP之初体验" class="headerlink" title="Android开发 MVP之初体验"></a>Android开发 MVP之初体验</h1><p>标签 ：Android MVP MVC</p>
<hr>
<p>熟悉安卓开发的童鞋应该都熟悉MVC架构模式, MVC开发模式即:</p>
<blockquote>
<p>Model(模型) – View(视图) – Control(控制器)</p>
</blockquote>
<p>逻辑图如下:<br><img src="http://www.bit100.com/.zhongzilu/image/MVC.png" alt="MVC"></p>
<p>而这种开发模式有个缺点,就是在项目越来越大时,文件会越来越多,查找起来很不方便,而且Activity或者Fragment里面的代码会越来越臃肿,看起来很凌乱,要修改更是让人头疼,于是就提出了一种MVP的开发模式,MVP开发模式即:</p>
<blockquote>
<p>Model(模型) – View(视图) – Presente(任命者/中介)</p>
</blockquote>
<p>逻辑图如下:<br><img src="http://www.bit100.com/.zhongzilu/image/mvp.png" alt="MVP"></p>
<p>网上有很多讲解MVP的文章和教程,我这里就不详细介绍了,但还有很多人看过教程之后依然不知如何实现MVP,今天主要通过实际代码的方式来体验MVP开发</p>
<p>本次使用的代码为Github上的一个开源项目,名为<a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="external">androidmvp</a></p>
<blockquote>
<p>传送门 <a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="external">https://github.com/antoniolg/androidmvp</a></p>
</blockquote>
<h2 id="先看看界面"><a href="#先看看界面" class="headerlink" title="先看看界面"></a>先看看界面</h2><p>界面很简单,就是一个登录界面和一个ListView填充的主界面,登录之后跳转到主界面,主界面上显示一个列表<br><img src="http://www.bit100.com/.zhongzilu/image/loginScreenShot.png" alt="登录界面"><img src="http://www.bit100.com/.zhongzilu/image/mainScreenShot.png" alt="主界面"></p>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>用Android Studio打开项目之后可以看到如下的项目结构<br><img src="http://www.bit100.com/.zhongzilu/image/structure.png" alt="项目结构"></p>
<p>通过截图可以看出,该项目是根据<strong>界面来分类的</strong>,Login文件夹下放的是所有与登录界面有关的文件,main文件夹下放的是所有与主界面有关的文件</p>
<p>其中, Login文件夹下共有6个文件, 3个类文件, 3个接口文件</p>
<p>类文件:</p>
<blockquote>
<ul>
<li>LoginActivity</li>
<li>LoginInteratorImpl</li>
<li>LoginPresenterImpl</li>
</ul>
</blockquote>
<p>接口文件:</p>
<blockquote>
<ul>
<li>LoginView</li>
<li>LoginInteractor</li>
<li>LoginPresenter</li>
</ul>
</blockquote>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>打开<strong>LoginActivity.java</strong>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class LoginActivity extends Activity implements LoginView, View.OnClickListener &#123;</div><div class="line"></div><div class="line">    private ProgressBar progressBar;</div><div class="line">    private EditText username;</div><div class="line">    private EditText password;</div><div class="line">    private LoginPresenter presenter;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_login);</div><div class="line"></div><div class="line">        //实例化控件</div><div class="line">        ...</div><div class="line"></div><div class="line">        presenter = new LoginPresenterImpl(this);</div><div class="line">    &#125;</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>从上面代码可以看出,该Activity实现了LoginView的接口和View的点击事件, 并且实例化了一个LoginPresenterImpl对象</p>
<p>现在打开<strong>LoginView.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface LoginView &#123;</div><div class="line">    void showProgress();</div><div class="line"></div><div class="line">    void hideProgress();</div><div class="line"></div><div class="line">    void setUsernameError();</div><div class="line"></div><div class="line">    void setPasswordError();</div><div class="line"></div><div class="line">    void navigateToHome();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到LoginView文件中定义了几个接口, 通过名称可以很容易知道每个接口是用来干什么的<br>返回LoginActivity也很容易发现是如何实现这几个接口的,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showProgress</span><span class="params">()</span> </span>&#123;</div><div class="line">    progressBar.setVisibility(View.VISIBLE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hideProgress</span><span class="params">()</span> </span>&#123;</div><div class="line">    progressBar.setVisibility(View.GONE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsernameError</span><span class="params">()</span> </span>&#123;</div><div class="line">    username.setError(getString(R.string.username_error));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPasswordError</span><span class="params">()</span> </span>&#123;</div><div class="line">    password.setError(getString(R.string.password_error));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">navigateToHome</span><span class="params">()</span> </span>&#123;</div><div class="line">    startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainActivity.class));</div><div class="line">    finish();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打开<strong>LoginPresenter.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginPresenter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">validateCredentials</span><span class="params">(String username, String password)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到定义了两个接口,其中validateCredentials接口是用来验证用户名和密码是否通过验证的<br>在LoginActivity中也有实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override public void onClick(View v) &#123;</div><div class="line">    presenter.validateCredentials(username.getText().toString(), </div><div class="line">        password.getText().toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>看到这里, 我们可以总结出LoginActivity没有做任何逻辑相关的事情,而是在做界面显示相关和界面跳转的事情, 就连验证帐号的逻辑都是交给LoginPresenterImpl类的</strong></p>
<p>那么现在顺藤摸瓜,打开LoginPresenterImpl.java文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class LoginPresenterImpl implements LoginPresenter, </div><div class="line">        LoginInteractor.OnLoginFinishedListener &#123;</div><div class="line"></div><div class="line">    private LoginView loginView;</div><div class="line">    private LoginInteractor loginInteractor;</div><div class="line"></div><div class="line">    public LoginPresenterImpl(LoginView loginView) &#123;</div><div class="line">        this.loginView = loginView;</div><div class="line">        this.loginInteractor = new LoginInteractorImpl();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //其他方法的实现</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到该类实现了LoginPresenter和LoginInteractor.OnLoginFinishedListener的接口,  并且在构造方法的参数为LoginView, 那么问题来了, <strong>为什么要传递LoginView类型的参数呢?</strong></p>
<p>我们刚才也看到了,在LoginView中定义了几个接口, 而在LoginActivity中有对这几个接口的实现, 所以传递这个参数, 是有利于LoginPresenterImpl类调用LoginActivity的实现方法, 用于界面上的显示, 这就达到了逻辑代码和显示代码的分离</p>
<p>好了,现在来看看是怎么实现LoginPresenter中的validateCredentials接口的吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override public void validateCredentials(String username, String password) &#123;</div><div class="line"></div><div class="line">    if (loginView != null) &#123;</div><div class="line">        loginView.showProgress();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    loginInteractor.login(username, password, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到这里,有同学该有疑问了,<strong>为什么在这个方法里我没看到实现帐号验证的具体逻辑呢?</strong></p>
<p>没错,这里不应该有帐号验证的具体逻辑代码,因为LoginPresenterImpl类充当的是任命者或者称中介者的身份, 中介者只负责联系<strong>界面类</strong>和<strong>具体实现逻辑代码的类</strong>,如果还不能理解,就想想房地产中介吧, 他们只负责联系买房者和卖房者, 其他的事都不管(抱歉, 我没有鄙视或看不起房地产中介人员的意思, 这里只是做个举例, 在此说声对不起).</p>
<p>我们看到代码中, 把接收到的username和password参数传递给了一个login方法, 该方法在LoginInteractor文件中, 我们再打开<strong>LoginInteractor.java</strong>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface LoginInteractor &#123;</div><div class="line"></div><div class="line">    interface OnLoginFinishedListener &#123;</div><div class="line">        void onUsernameError();</div><div class="line"></div><div class="line">        void onPasswordError();</div><div class="line"></div><div class="line">        void onSuccess();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void login(String username, String password, OnLoginFinishedListener listener);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以定义了一个login接口和一个OnLoginFinishedListener接口类, 返回LoginPresenterImpl.java文件可以很容易看到OnLoginFinishedListener接口类中接口的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override public void onUsernameError() &#123;</div><div class="line">    if (loginView != null) &#123;</div><div class="line">        loginView.setUsernameError();</div><div class="line">        loginView.hideProgress();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override public void onPasswordError() &#123;</div><div class="line">    if (loginView != null) &#123;</div><div class="line">        loginView.setPasswordError();</div><div class="line">        loginView.hideProgress();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override public void onSuccess() &#123;</div><div class="line">    if (loginView != null) &#123;</div><div class="line">        loginView.navigateToHome();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这些接口的实现中同样只是调用LoginView中的接口,并没有具体的逻辑操作代码</p>
<p>在该类的构造方法中我们会发现, 这里实例化了一个<strong>LoginInteractorImpl</strong>对象, 我们现在打开LoginInteractorImpl.java文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class LoginInteractorImpl implements LoginInteractor &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void login(final String username, final String password, final OnLoginFinishedListener listener) &#123;</div><div class="line">    </div><div class="line">        // Mock login. I&apos;m creating a handler to delay the answer a couple of seconds</div><div class="line">        new Handler().postDelayed(new Runnable() &#123;</div><div class="line">        </div><div class="line">            @Override public void run() &#123;</div><div class="line">            </div><div class="line">                boolean error = false;</div><div class="line">                if (TextUtils.isEmpty(username))&#123;</div><div class="line">                    listener.onUsernameError();</div><div class="line">                    error = true;</div><div class="line">                &#125;</div><div class="line">                if (TextUtils.isEmpty(password))&#123;</div><div class="line">                    listener.onPasswordError();</div><div class="line">                    error = true;</div><div class="line">                &#125;</div><div class="line">                if (!error)&#123;</div><div class="line">                    listener.onSuccess();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, 2000);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到该类实现了LoginInteractor中的login接口, 并且在login方法中进行了具体的逻辑处理, 如果验证通过, 调用onSuccess接口</p>
<p><strong>好了,整个登录流程讲完了,最后我们再来梳理一下整个流程:</strong></p>
<blockquote>
<ol>
<li>在LoginActivity中,通过LoginPresenter接口类中的validateCredentials接口,把username和password传递给LoginPresenter的实现类LoginPresenterImpl</li>
<li>LoginPresenterImpl类再通过LoginInteractor接口类中的login接口, 把username和password传递给LoginInteractor的实现类LoginInteractorImpl</li>
<li>在LoginInteractorImpl类中进行具体的逻辑处理, 如果验证通过,则调用LoginInteractor.OnLoginFinishedListener接口类中的onSuccess接口, 即调用了LoginPresenterImpl类中实现的onSuccess接口</li>
<li>LoginPresenterImpl类中实现的onSuccess接口中,调用了LoginView接口类中的navigateToHome接口,即调用了LoginActivity类中实现的navigateToHome接口</li>
<li>最后在navigateToHome接口中实现Activity的跳转,跳转到MainActivity</li>
</ol>
</blockquote>
<p><strong>流程图如下:</strong><br><img src="http://www.bit100.com/.zhongzilu/image/flow_chart.png" alt="Alt text"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在MVP开发模式中, Activity只负责界面的显示和跳转相关的操作, 具体的逻辑处理通过调用接口来传递给Presenter(中介者) 既不做界面显示的操作,也不做具体的逻辑处理操作, 具体的逻辑处理通过调用接口,让Interactor即交互类来完成</p>
<p>交互类的逻辑处理结果,通过调用Presenter中实现的接口, 再由Presenter要实现的接口中调用Activity中实现的接口来进行UI的显示或界面跳转</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>好了,<code>安卓开发 MVP之初体验</code>讲完了,写了那么多,希望大家能够看懂了,如果还有什么问题,可以问我<a href="http://ask.android-studio.org/?/people/zhongzilu" target="_blank" rel="external">Follow Me</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【微表情心理学】耳朵的秘密]]></title>
      <url>http://zhongzilu.github.io/2016/05/10/%E3%80%90%E5%BE%AE%E8%A1%A8%E6%83%85%E5%BF%83%E7%90%86%E5%AD%A6%E3%80%91%E8%80%B3%E6%9C%B5%E7%9A%84%E7%A7%98%E5%AF%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>如果你仔细观察我们的耳朵，你会发现耳朵就像一个倒置的胎儿。他的头部朝下，臀部朝上。耳朵可以被看做事他人体的缩小版</p>
</blockquote>
<h3 id="耳朵大小某种程度上体现一个人的生命力和思想深度"><a href="#耳朵大小某种程度上体现一个人的生命力和思想深度" class="headerlink" title="耳朵大小某种程度上体现一个人的生命力和思想深度"></a>耳朵大小某种程度上体现一个人的生命力和思想深度</h3><p>通常来说，一个人的耳朵越大，他就越充满激情和活力，他多半精力旺盛，但也很容易脾气暴躁，比如美国前总统比尔·克林顿。耳朵中等大小的人，多半思想冷静、理性而客观，比如法国影星苏菲·玛索。而小耳朵的人，多半具有很强的观察力，而且适应能力很强，对待事情也比较有耐心</p>
<h3 id="耳朵反映一个人的性格特征"><a href="#耳朵反映一个人的性格特征" class="headerlink" title="耳朵反映一个人的性格特征"></a>耳朵反映一个人的性格特征</h3><p>大耳朵的人多半活力四射，行动力和执行力比较强，有个性，有思想</p>
<p>耳朵外形美观的人，内心相对平静，富有想象力，具有坚持不懈的品质和乐于竞争的精神</p>
<p>耳轮在起始处粗壮，而在走向中间的部位是剧烈变细的人多半比较顽固，敏感，情绪不稳定，容易消沉</p>
<p>耳朵外形粗糙，粗笨或过宽，过厚，此人往往比较麻木缺乏感情，思维不受控制，甚至有时还很野蛮，具有强烈的攻击性</p>
<p>中等大小的耳朵为正常耳朵，虽不具备丰富想象力和热情，但感情稳定，不易出现波动，而且做事更加理性，逻辑性思维很强，做事前喜欢深思熟虑，权衡再三，与人交往时不会无理争辩，而是做出让人信服的言论。总之此类人为人处世相对稳重，并且善于处理工作和生活之间的关系</p>
<p>小耳朵通常缺乏强烈的野心，自信心，想象力和创造性，但他们多半反应迅速，身体灵敏，并且具有极强的专注力和观察力。性情上，一般较为敏感，更容易闷闷不乐，郁郁寡欢，也常陷入悲观局面。但他们行事严谨，很少出现差错，往往也会取得令人骄傲的成绩</p>
<h3 id="扯耳朵或摸耳垂"><a href="#扯耳朵或摸耳垂" class="headerlink" title="扯耳朵或摸耳垂"></a>扯耳朵或摸耳垂</h3><p>在谈话中，很多人习惯做出扯耳朵或者摸耳垂的动作，通常这种动作表示他们试图打断对方说话。</p>
<p>摸耳垂的动作是一种自我触摸，自我安慰的行为。通常当人们对谈话内容不感兴趣而产生乏味，无趣的情绪甚至对内容反感时会出现此举动。一方面是想要打断对方的潜意识，另一方面是借此来安抚自己消除内心的浮躁和不安。</p>
<p>当人们紧张、内心焦虑不安、说谎、表示反对意见时也会有此举动</p>
<h3 id="咬嘴唇或隐藏嘴唇"><a href="#咬嘴唇或隐藏嘴唇" class="headerlink" title="咬嘴唇或隐藏嘴唇"></a>咬嘴唇或隐藏嘴唇</h3><p>出现此举通常是由于出现某种压力或紧张情绪。这是一种消极情绪</p>
<p>突然收拢嘴唇或嘟起嘴，如果在谈话时出现此举动，通常说明此人对所讲话的内容在心理上出现了反对意见或是不完全认可的态度，此时他正在思考怎么样转换正在谈论的话题或者是准备提出自己的不同意见</p>
<blockquote>
<p>作者：zhongzilu</p>
</blockquote>
]]></content>
      
        
    </entry>
    
  
  
</search>
