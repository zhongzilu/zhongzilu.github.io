<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Hello from zhongzilu]]></title>
      <url>http://zhongzilu.github.io/2017/02/20/Hello-from-zhongzilu/</url>
      <content type="html"><![CDATA[<h2 id="Hello-from-Zhongzilu"><a href="#Hello-from-Zhongzilu" class="headerlink" title="Hello from Zhongzilu"></a>Hello from Zhongzilu</h2><p>Welcome to BIT100.I’m zilu Zhong,an Android developer.Here is my blog website.I will post some blog articel which include technology,psychology and other notes in some time.In order to facilitating more people,I will sharing something which is be useful to everyone,because i believe that the knowledge more sharing more valuable.Sorry!My English is poor.So,Don’t be care.</p>
<p>欢迎来到我的网站，我是钟子路(zhongzilu)，是一个安卓开发者。这个网站是我的博客网站，我会不定时更新一些博客，博客类型包括技术博客，心理学笔记以及一些随笔，总之，是把我觉得对大家有用的东西分享出来，以便利更多人。我相信，知识越分享越有价值。</p>
<p><strong>作者</strong>：zhongzilu<br><strong>GitHub</strong>： <a href="https://github.com/zhongzilu" target="_blank" rel="external">https://github.com/zhongzilu</a><br><strong>简书</strong>: <a href="http://www.jianshu.com/users/0551ca89845b/latest_articles" target="_blank" rel="external">http://www.jianshu.com/users/0551ca89845b/latest_articles</a><br><strong>安卓社区</strong>: <a href="http://ask.android-studio.org/?/people/zhongzilu" target="_blank" rel="external">http://ask.android-studio.org/?/people/zhongzilu</a><br><strong>网易云音乐</strong> <a href="http://music.163.com/#/user/home?id=28448237" target="_blank" rel="external">http://music.163.com/#/user/home?id=28448237</a><br><strong>微博</strong> <a href="http://weibo.com/2719197280/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" rel="external">http://weibo.com/2719197280/profile?topnav=1&amp;wvr=6&amp;is_all=1</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://zhongzilu.github.io/2017/02/20/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[理想三旬]]></title>
      <url>http://zhongzilu.github.io/2016/09/12/%E7%90%86%E6%83%B3%E4%B8%89%E6%97%AC/</url>
      <content type="html"><![CDATA[<h2 id="理想三旬"><a href="#理想三旬" class="headerlink" title="理想三旬"></a>理想三旬</h2><p>标签 <code>浓烟下的诗歌电台</code> <code>理想三旬</code> <code>陈鸿宇</code></p>
<p>15平米的出租房，一张床一张桌子，角落装行李的箱子似乎原封不动堆在那里，还是几个月之前的样子，那副裱起来的肖像画似乎特别显眼。</p>
<p>窗外风雨交加，手机今天早上跳出来的新闻说超级台风了，这个房子老旧的似乎摇摇晃晃马上要被吹坏一样。</p>
<p>房东是个独居老太太，衣着干净整洁，讲一口细软的南方普通话，消瘦很精明或者是说有些刻薄和吝啬。</p>
<p>守了6年的唱片公司最终还是入不敷出，他是这家公司的最后一个歌手，吃散伙饭的时候快四十的男人痛声大哭，他看着老板一句话也说不出来。</p>
<p>他几年前卖了攒钱买下的房子，坐上火车南下回到家乡，盘了一家餐厅，亲自装修，亲自三顾茅庐找厨师，亲自去买材料，甚至在后厨刷碗，但是剩下的钱也只够租下这个小屋子。</p>
<p>“我真的不喜欢你们这些说搞音乐的人，真的是不想租的啦，晚上八点以后不要让我听见唱歌啊，弹琴的声音，还有宠物也不要养。”</p>
<p>“知道了。”</p>
<p>他打开小冰箱，里面除了啤酒什么都没有，床头柜上有一包昨天吃剩的饼干，把剩下的塞到嘴里，只觉得浑身酸痛。</p>
<p>一个人干几个人的活，员工虽然有休息日，但是自己却只能够在这样自然灾害的天里面休息。</p>
<p>望了一眼墙角的吉他，琴箱上积了一层灰，他伸手拿够到它，然后用布把那些灰擦掉，然后想了想最终还是打开。</p>
<p>他今年三十岁了，古人说三十而立，这个年纪谈梦想似乎让人觉得可笑。这也是他不回家的原因，不过父母知道他开餐厅时候还是挺开心的，这是他姐姐和他说的。</p>
<p>学生时代一起做乐队的朋友大多都已经放弃了，极少数坚持下来的生活似乎也不怎么光鲜，至于之前工作认识的朋友似乎也因为某些原因疏远。他还比较幸运，他们说，至少曾经被人看见过，他觉得也是。看见他们因为业绩和上司闷闷不乐，他觉得自己虽然显得幼稚，但是却还是比较快乐。</p>
<p>音乐从指缝中流出，寂寞而美好，他也不知道怎么就弹出这首曲子。</p>
<p>因为这首歌他被老板看上，出了第一张也是唯一的一张唱片，红极一时，那时候走到街上似乎都是这首歌。</p>
<p>但是这首歌是他写给她女朋友的，那时候他们那么相爱，似乎永远都不会分开。在那个他们一起上学的北方城市，她最终嫁给了一个很平凡但是对她很好很踏实的男人，听说已经有了一个孩子。人有时候真的很善变，也很无情。喜欢的时候那么喜欢，不过忘记也似乎就只要一瞬间。</p>
<p>她给他画的画他还留着，二十多岁的样子和三十多岁的样子真的很不一样。这首歌现在唱和当初在舞台上唱的，似乎也不太一样。如果没有得到过，那么便不会觉得悲伤。</p>
<p>他突然很想抽烟，但是他已经戒烟很久了。他抱着吉他，窗外风雨更急了，路上看不见人影，满屋子的风雨呼啸声。</p>
<p>“笃笃笃。”突然听见敲门声。</p>
<p>他觉得奇怪，开门房东站在门口，手里拿着个饭桶。</p>
<p>“这么大的后生还怕台风啊，哭什么。”</p>
<p>他才发现自己竟然在留眼泪，连忙擦掉:“您怎么来了？有什么事情吗？”</p>
<p>“平时看你都是订外卖吃的，台风天人家外卖都不送了，刚好饭做多了给你一点。”房东把饭桶塞到他手里，“和我儿子一个样子，吃外卖还有方便面身体才不好，每天半夜咳嗽我觉都睡不着了。吃完放在我门口就好了。”</p>
<p>他有些懵，只是点了点头。</p>
<p>“真的是和我儿子一个样子，谢谢也不知道说的啊？”她有些生气的样子。</p>
<p>他又慌忙说了一句谢谢。</p>
<p>“嗯。”她点了点头，“不过你弹琴还是蛮好听的，唱歌也比他好，我还是蛮喜欢的。虽然是年轻人的歌，好听的话也可以适当多唱唱。”</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=31445772&auto=1&height=66"></iframe>

<blockquote>
<p><strong>作者</strong>：王木木<br><strong>原文地址</strong>: <a href="http://gushi.li/42" target="_blank" rel="external">http://gushi.li/42</a> </p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[(已解决)程序调用魅族系统裁剪之后直接闪退]]></title>
      <url>http://zhongzilu.github.io/2016/09/02/%E5%B7%B2%E8%A7%A3%E5%86%B3-%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E9%AD%85%E6%97%8F%E7%B3%BB%E7%BB%9F%E8%A3%81%E5%89%AA%E4%B9%8B%E5%90%8E%E7%9B%B4%E6%8E%A5%E9%97%AA%E9%80%80/</url>
      <content type="html"><![CDATA[<h2 id="（已解决）程序调用魅族系统裁剪之后直接闪退"><a href="#（已解决）程序调用魅族系统裁剪之后直接闪退" class="headerlink" title="（已解决）程序调用魅族系统裁剪之后直接闪退"></a>（已解决）程序调用魅族系统裁剪之后直接闪退</h2><hr>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>几天前发布了一篇博客，是关于<strong><a href="http://www.bit100.com/%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E9%AD%85%E6%97%8F%E7%B3%BB%E7%BB%9F%E8%A3%81%E5%89%AA%E4%B9%8B%E5%90%8E%E7%9B%B4%E6%8E%A5%E9%97%AA%E9%80%80/" target="_blank" rel="external">程序调用魅族系统裁剪之后直接闪退</a></strong>的问题，在网上找了很久之后也没有找到解决方法，于是决定去请教魅族官方的开发者，我先是在魅族社区里发帖提问，然后有幸在朋友的帮助下得到了魅族运营的联系方式，请求他帮忙联系一下魅族开发者，果然，在一周之后我得到了魅族开发者的回复，我在这里为魅族开发者<strong>点赞</strong>，感谢他们对待问题的态度，同时也为魅族客服<strong>点赞</strong>，感谢他们对用户提出的问题进行认真的回复。</p>
<p>好了，废话不多说，今天主要讲讲对于这个问题的解决方案。</p>
<h3 id="魅族官方社区的回复截图"><a href="#魅族官方社区的回复截图" class="headerlink" title="魅族官方社区的回复截图"></a>魅族官方社区的回复截图</h3><p><img src="http://www.bit100.com/.zhongzilu/image/meizu_Bug_solution_Screenshot.png" alt="Bug solution screenshot"><br>根据回复，我们可以得知，魅族在系统层就处理了 我们经常遇到的 因裁剪图片过大可能会导致内存溢出的问题，这一点还是挺人性化的，再次为魅族系统开发者点赞。</p>
<p>回复中共提供了三种解决方案，通过对比，我们把这三种方案进行结合。</p>
<p>解决方案代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 对选择的图片进行裁剪</div><div class="line"> * <span class="doctag">@param</span> uri 图片uri</div><div class="line"> * <span class="doctag">@param</span> outputX 输出图片宽度</div><div class="line"> * <span class="doctag">@param</span> outputY 输出图片高度</div><div class="line"> * <span class="doctag">@param</span> requestCode 请求码</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cropImage</span><span class="params">(Uri uri, <span class="keyword">int</span> outputX, <span class="keyword">int</span> outputY, <span class="keyword">int</span> requestCode)</span> </span>&#123;</div><div class="line">    Intent intent = </div><div class="line">	    <span class="keyword">new</span> Intent(<span class="string">"com.android.camera.action.CROP"</span>);</div><div class="line">    intent.setDataAndType(uri, <span class="string">"image/*"</span>);</div><div class="line">    intent.putExtra(<span class="string">"crop"</span>, <span class="string">"true"</span>);</div><div class="line">    intent.putExtra(<span class="string">"aspectX"</span>, <span class="number">1</span>);</div><div class="line">    intent.putExtra(<span class="string">"aspectY"</span>, <span class="number">1</span>);</div><div class="line">    intent.putExtra(<span class="string">"outputX"</span>, outputX);</div><div class="line">    intent.putExtra(<span class="string">"outputY"</span>, outputY);</div><div class="line">    intent.putExtra(<span class="string">"noFaceDetection"</span>, <span class="keyword">true</span>);</div><div class="line">    intent.putExtra(<span class="string">"return-data"</span>, <span class="keyword">true</span>);</div><div class="line">    <span class="comment">//这里增加第三种方案的代码</span></div><div class="line">    intent.putExtra(<span class="string">"return-path-if-too-large"</span>, <span class="keyword">true</span>);</div><div class="line">    intent.putExtra(<span class="string">"scale"</span>, <span class="keyword">true</span>);</div><div class="line">    <span class="comment">//这里生成裁剪过后的图片的保存路径</span></div><div class="line">	File file = <span class="keyword">new</span> File(</div><div class="line">		getApplicationContext().getExternalCacheDir(),</div><div class="line">		UUID.randomUUID().toString());</div><div class="line">		</div><div class="line">	intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));</div><div class="line">    intent.putExtra(<span class="string">"outputFormat"</span>, </div><div class="line">	    Bitmap.CompressFormat.JPEG.toString()); <span class="comment">//输入文件格式</span></div><div class="line">    startActivityForResult(intent, requestCode);</div><div class="line">    </div><div class="line">    <span class="comment">//把自定义的保存路径保存到全局变量中，方便其他地方调用</span></div><div class="line">	<span class="keyword">this</span>.mCropImageUri = Uri.fromFile(file);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>覆写的onActivityResult代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (requestCode) &#123;</div><div class="line">    </div><div class="line">	    <span class="comment">//裁剪图片之后的处理</span></div><div class="line">        <span class="keyword">case</span> REQUEST_CROP_CODE:</div><div class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK &amp;&amp; data != <span class="keyword">null</span>)&#123;</div><div class="line">                Uri uri = data.getData();</div><div class="line">                <span class="keyword">if</span> (uri != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">this</span>.mImageRealPath = uri.getPath();</div><div class="line">                    LogUtil.d(<span class="string">"ImageRealPath==&gt;"</span>, mImageRealPath);</div><div class="line">                    <span class="comment">//更换视频封面</span></div><div class="line">                    img_video_mask.setImageURI(uri);</div><div class="line"></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">	                <span class="comment">//在其他机型上裁剪过后的图片uri会包含在data中，</span></div><div class="line">	                <span class="comment">//通过data.getData()可以获取到裁剪过后的图片uri</span></div><div class="line">	                <span class="comment">//但在魅族机型上，data.getData获取的uri为null</span></div><div class="line">	                <span class="comment">//因此需要使用我们在调用裁剪时生成的保存路径</span></div><div class="line">                    <span class="keyword">this</span>.mImageRealPath = </div><div class="line">	                    mCropImageUri.getPath();</div><div class="line">                    LogUtil.d(TAG, </div><div class="line">	                    <span class="string">"onActivityResult: ImageRealPath==&gt;"</span> </div><div class="line">	                    + mImageRealPath);</div><div class="line"></div><div class="line">                    img_video_mask.setImageURI(mCropImageUri);</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">     </div><div class="line">     <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><strong>作者</strong>：zhongzilu<br><strong>原文地址</strong>: <a href="http://www.bit100.com/%EF%BC%88%E5%B7%B2%E8%A7%A3%E5%86%B3%EF%BC%89%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E9%AD%85%E6%97%8F%E7%B3%BB%E7%BB%9F%E8%A3%81%E5%89%AA%E4%B9%8B%E5%90%8E%E7%9B%B4%E6%8E%A5%E9%97%AA%E9%80%80/" target="_blank" rel="external">http://www.bit100.com/（已解决）程序调用魅族系统裁剪之后直接闪退/</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[程序调用魅族系统j裁剪之后直接闪退]]></title>
      <url>http://zhongzilu.github.io/2016/08/30/%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E9%AD%85%E6%97%8F%E7%B3%BB%E7%BB%9Fj%E8%A3%81%E5%89%AA%E4%B9%8B%E5%90%8E%E7%9B%B4%E6%8E%A5%E9%97%AA%E9%80%80/</url>
      <content type="html"><![CDATA[<h2 id="程序调用系统裁剪之后直接闪退"><a href="#程序调用系统裁剪之后直接闪退" class="headerlink" title="程序调用系统裁剪之后直接闪退"></a>程序调用系统裁剪之后直接闪退</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>我原本是想实现更换头像的功能，程序调用系统相册选取图片，选取图片后直接进行裁剪，我在<code>Activity</code>里覆写了<code>onActivityResult</code>方法，然后在该方法里获取返回的图片数据，结果要么是根本没执行到<code>onActivityResult</code>方法里，要么是获取不到数据，在其他手机上没出现这个问题，唯独在魅族的手机上会有这个问题，我想请问一下魅族的开发者大佬们，这个问题该怎么解决呢？</p>
<h3 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h3><p>有两种情况，第一种没执行到<code>onActivityResult</code></p>
<p>裁剪请求代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 对选择的图片进行裁剪</div><div class="line">  * <span class="doctag">@param</span> uri 图片uri</div><div class="line">  * <span class="doctag">@param</span> outputX 输出图片宽度</div><div class="line">  * <span class="doctag">@param</span> outputY 输出图片高度</div><div class="line">  * <span class="doctag">@param</span> requestCode 请求码</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cropImage</span><span class="params">(Uri uri, <span class="keyword">int</span> outputX, <span class="keyword">int</span> outputY,</span></span></div><div class="line">  <span class="keyword">int</span> requestCode) &#123;</div><div class="line">     Intent intent = </div><div class="line">         <span class="keyword">new</span> Intent(<span class="string">"com.android.camera.action.CROP"</span>);</div><div class="line">     intent.setDataAndType(uri, <span class="string">"image/*"</span>);</div><div class="line">     intent.putExtra(<span class="string">"crop"</span>, <span class="string">"true"</span>);</div><div class="line">     intent.putExtra(<span class="string">"aspectX"</span>, <span class="number">1</span>);</div><div class="line">     intent.putExtra(<span class="string">"aspectY"</span>, <span class="number">1</span>);</div><div class="line">     intent.putExtra(<span class="string">"outputX"</span>, outputX);</div><div class="line">     intent.putExtra(<span class="string">"outputY"</span>, outputY);</div><div class="line">     intent.putExtra(<span class="string">"noFaceDetection"</span>, <span class="keyword">true</span>);</div><div class="line">     intent.putExtra(<span class="string">"return-data"</span>, <span class="keyword">true</span>);</div><div class="line">     intent.putExtra(<span class="string">"scale"</span>, <span class="keyword">true</span>);</div><div class="line">     </div><div class="line">	 File file = <span class="keyword">new</span> File(</div><div class="line">			 getApplicationContext().getExternalCacheDir(),</div><div class="line">			 UUID.randomUUID().toString()</div><div class="line">	 );</div><div class="line">	 </div><div class="line">	 intent.putExtra(MediaStore.EXTRA_OUTPUT, </div><div class="line">		 Uri.fromFile(file));</div><div class="line">     intent.putExtra(<span class="string">"outputFormat"</span>, </div><div class="line">	     Bitmap.CompressFormat.JPEG.toString()); </div><div class="line">     startActivityForResult(intent, requestCode);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>覆写的onActivityResult代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (requestCode) &#123;</div><div class="line">    </div><div class="line">	     <span class="comment">//裁剪图片之后的处理</span></div><div class="line">        <span class="keyword">case</span> REQUEST_CROP_CODE:</div><div class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK &amp;&amp; data != <span class="keyword">null</span>)&#123;</div><div class="line">                Uri uri = data.getData();</div><div class="line">                <span class="keyword">if</span> (uri != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">this</span>.mImageRealPath = uri.getPath();</div><div class="line">                    LogUtil.d(<span class="string">"ImageRealPath==&gt;"</span>, mImageRealPath);</div><div class="line">                    <span class="comment">//更换图片</span></div><div class="line">                    img_video_mask.setImageURI(uri);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这种情况就是没法运行到<code>onActivityResult</code>方法里，裁剪图片之后，点击确定按钮，就直接闪退了，在debug模式下都没办法</p>
</blockquote>
<p>第二种情况是能运行到<code>onActivityResult</code>里，但获取不了返回数据</p>
<p>裁剪请求代码稍微有点区别，具体如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 对选择的图片进行裁剪</div><div class="line"> * <span class="doctag">@param</span> uri 图片uri</div><div class="line"> * <span class="doctag">@param</span> outputX 输出图片宽度</div><div class="line"> * <span class="doctag">@param</span> outputY 输出图片高度</div><div class="line"> * <span class="doctag">@param</span> requestCode 请求码</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cropImage</span><span class="params">(Uri uri, <span class="keyword">int</span> outputX, <span class="keyword">int</span> outputY, <span class="keyword">int</span> requestCode)</span> </span>&#123;</div><div class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.android.camera.action.CROP"</span>);</div><div class="line">    intent.setDataAndType(uri, <span class="string">"image/*"</span>);</div><div class="line">    intent.putExtra(<span class="string">"crop"</span>, <span class="string">"true"</span>);</div><div class="line">    intent.putExtra(<span class="string">"aspectX"</span>, <span class="number">1</span>);</div><div class="line">    intent.putExtra(<span class="string">"aspectY"</span>, <span class="number">1</span>);</div><div class="line">    intent.putExtra(<span class="string">"outputX"</span>, outputX);</div><div class="line">    intent.putExtra(<span class="string">"outputY"</span>, outputY);</div><div class="line">    intent.putExtra(<span class="string">"noFaceDetection"</span>, <span class="keyword">true</span>);</div><div class="line">    intent.putExtra(<span class="string">"return-data"</span>, <span class="keyword">true</span>);</div><div class="line">    intent.putExtra(<span class="string">"scale"</span>, <span class="keyword">true</span>);</div><div class="line"><span class="comment">// File file = new File(getApplicationContext().getExternalCacheDir(),UUID.randomUUID().toString());</span></div><div class="line"><span class="comment">// intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));</span></div><div class="line">    intent.putExtra(<span class="string">"outputFormat"</span>, Bitmap.CompressFormat.JPEG.toString()); <span class="comment">//输入文件格式</span></div><div class="line">    startActivityForResult(intent, requestCode);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>覆写的<code>onActivityResult</code>也稍微有点变化，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//裁剪图片之后的处理</span></div><div class="line"><span class="keyword">case</span> REQUEST_CROP_CODE:</div><div class="line">   <span class="keyword">if</span> (resultCode == RESULT_OK &amp;&amp; data != <span class="keyword">null</span>)&#123;</div><div class="line">       Uri uri = data.getData();</div><div class="line">       <span class="keyword">if</span> (uri != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">this</span>.mImageRealPath = uri.getPath();</div><div class="line">           LogUtil.d(<span class="string">"ImageRealPath==&gt;"</span>, mImageRealPath);</div><div class="line">           <span class="comment">//更换图片</span></div><div class="line">           img_video_mask.setImageURI(uri);</div><div class="line"></div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           Bundle bundle = data.getExtras();</div><div class="line">           <span class="keyword">if</span> (bundle != <span class="keyword">null</span>) &#123;</div><div class="line">               String filePath = bundle.getString(<span class="string">"filePath"</span>);</div><div class="line">               <span class="keyword">if</span> (!TextUtils.isEmpty(filePath))&#123;</div><div class="line">                   img_video_mask.setImageURI(</div><div class="line">	                   Uri.parse(filePath));</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p><code>之所以改成这样的写法，是因为我在网上找到一篇文章在说这个问题，并给出一个解决方案，我根据他的解决方案，依然没有解决问题。地址：http://www.cnblogs.com/over140/archive/2012/12/17/2821874.html</code></p>
<p>在Debug模式下，截图如下<br><img src="http://www.bit100.com/wp-content/uploads/2016/08/Debug-Screenshot.png" alt="Debug Screenshot"></p>
<p>通过截图可以看到<code>uri</code>和<code>filePath</code>都为<code>null</code>，实在没办法，所以来请教一下魅族的开发大佬们，希望能尽快收到你们的回复，小弟在此表示万分感谢！</p>
<p><strong>作者</strong>：zhongzilu<br><strong>原文地址</strong>： <a href="http://www.bit100.com/%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E9%AD%85%E6%97%8F%E7%B3%BB%E7%BB%9F%E8%A3%81%E5%89%AA%E4%B9%8B%E5%90%8E%E7%9B%B4%E6%8E%A5%E9%97%AA%E9%80%80/" target="_blank" rel="external">http://www.bit100.com/程序调用魅族系统裁剪之后直接闪退/</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[浓烟下的诗歌电台-陈鸿宇]]></title>
      <url>http://zhongzilu.github.io/2016/06/22/%E6%B5%93%E7%83%9F%E4%B8%8B%E7%9A%84%E8%AF%97%E6%AD%8C%E7%94%B5%E5%8F%B0-%E9%99%88%E9%B8%BF%E5%AE%87/</url>
      <content type="html"><![CDATA[<h2 id="浓烟下的诗歌电台-陈鸿宇"><a href="#浓烟下的诗歌电台-陈鸿宇" class="headerlink" title="浓烟下的诗歌电台-陈鸿宇"></a>浓烟下的诗歌电台-陈鸿宇</h2><p>标签 <code>浓烟下的诗歌电台</code> <code>安静</code> <code>吉他</code> <code>低沉</code> <code>理想</code> <code>行路</code> <code>早春</code> <code>钟子路</code> <code>网易云音乐</code></p>
<p>读一本书，是与作者心灵上的沟通，听一首音乐也是。今天我给大家带来几首陈鸿宇的歌，听他的歌，什么烦恼，浮躁的心，都能烟消云散。</p>
<blockquote>
<p><strong>浓烟下的诗歌</strong></p>
<p>浓烟下不过是南方三四月的梅雨时节，<br>早春的树已按耐不住寂寞于冬末出芽，<br>你只是经过而我却再也难忘你的容颜，<br>理想三旬依旧年轻却忘了黑发已不再，<br>霓虹深处灯红酒绿痴男怨女忘情歌唱，<br>途中收到来信一封心中窃喜你还依旧，<br>遗漏了我们一路走来心中畅想的行歌。</p>
</blockquote>
<h3 id="理想三旬"><a href="#理想三旬" class="headerlink" title="理想三旬"></a>理想三旬</h3><blockquote>
<p>他说，理想已存在于月有三旬之前，七月融化在不经意的罅(xia)隙，十二月结成冰，被牢牢抓住在时间里，人有三旬，也不过是右手握着缄口不言的聚散，左手长出脉络骄横的命运，然后山崖无尽，热望不熄，最终死生寻常，悲喜成疾。</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=31445772&auto=1&height=66"></iframe>

<h3 id="途中"><a href="#途中" class="headerlink" title="途中"></a>途中</h3><blockquote>
<p>独飞时慕侣，寡合乍孤音</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=34380395&auto=0&height=66"></iframe>

<h3 id="行歌"><a href="#行歌" class="headerlink" title="行歌"></a>行歌</h3><blockquote>
<p>负者歌于途，行者休于树</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=31445771&auto=0&height=66"></iframe>

<h3 id="早春的树"><a href="#早春的树" class="headerlink" title="早春的树"></a>早春的树</h3><blockquote>
<p>偶然惊鸿一瞥，我心怦然而动，成为一棵早春的树。为你我愿折筋断骨，融入你每一寸生活，只盼守你年年月月，可我不过早春一棵树，只能立于门前，希冀你某天再经过我的荒芜</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=35476188&auto=0&height=66"></iframe>

<h3 id="船子"><a href="#船子" class="headerlink" title="船子"></a>船子</h3><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=415793152&auto=0&height=66"></iframe>

<h3 id="你只是经过"><a href="#你只是经过" class="headerlink" title="你只是经过"></a>你只是经过</h3><blockquote>
<p>她出现，又消失，一如日升日落，抑或任何转瞬即逝的事物。就像我们的生活，我们出现，然后我们又消失，我们对一些人是如此重要，但我们只是经过。</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=36080207&auto=0&height=66"></iframe>

<h3 id="来信"><a href="#来信" class="headerlink" title="来信"></a>来信</h3><blockquote>
<p>窗外下起了小雨，没有你消息的夜是否继续漫长，前些天你说要寄给我一张明信片，我等邮戳漂过远方，等你慢慢变成我的习惯，心里为你留了一扇门，很难再关上，逐渐发现自己有些软弱，大概是惯性吧，像等你的日子，让我无能为力。</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=399340140&auto=0&height=66"></iframe>

<h3 id="霓虹深处"><a href="#霓虹深处" class="headerlink" title="霓虹深处"></a>霓虹深处</h3><blockquote>
<p>这一刻，我来过的意义，而后恍悟，无谓再提。</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=41642352&auto=0&height=66"></iframe>

<h3 id="浓烟下"><a href="#浓烟下" class="headerlink" title="浓烟下"></a>浓烟下</h3><blockquote>
<p>歌声沉痛落地再轻浮地扬起，动人的永远只是半成品，和你，歌声沉痛落地再轻浮地扬起，而我能给的，恰好大都无意义。</p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=41655197&auto=0&height=66"></iframe>

<blockquote>
<p>浓烟下的影子<br>霓虹深处的你<br>都只是经过<br>途中的一处风景</p>
<p>早春有树<br>船有鱼群<br>行歌吟完<br>再读来信<br>理想已三旬</p>
</blockquote>
<hr>
<blockquote>
<p>作者：zhongzilu<br>原文地址: <a href="http://www.bit100.com/浓烟下的诗歌电台" target="_blank" rel="external">http://www.bit100.com/浓烟下的诗歌电台</a> ——陈鸿宇/</p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Canvas绘制图形-拾音器之动画篇]]></title>
      <url>http://zhongzilu.github.io/2016/05/31/Android-Canvas%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2-%E6%8B%BE%E9%9F%B3%E5%99%A8%E4%B9%8B%E5%8A%A8%E7%94%BB%E7%AF%87/</url>
      <content type="html"><![CDATA[<h2 id="Android-Canvas绘制图形-拾音器之动画篇"><a href="#Android-Canvas绘制图形-拾音器之动画篇" class="headerlink" title="Android Canvas绘制图形 拾音器之动画篇"></a>Android Canvas绘制图形 拾音器之动画篇</h2><p>标签 <code>Android Canvas</code> <code>View Animation</code> <code>ValueAnimator</code> <code>View动画</code> <code>属性动画</code></p>
<p>前几天我写过一篇文章，叫<a href="">Android Canvas 绘制图形 – 拾音器</a>，那篇文章旨在讲解如何使用Canvas来绘制图形，并没有实现指针的偏转动画实现，那么，今天我们就来看看指针的偏转动画如何实现。</p>
<h3 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h3><p>安卓上实现动画的方式分为两种，一种是View动画，包名：<code>android.view.animation</code>，另一种是属性动画，包名：<code>android.animation</code>。</p>
<p>View动画从字面上理解就是作用对象只能是View的派生类，其他的就只能心有余而力不足了。</p>
<p>属性动画的作用对象就不只是针对View的派生类了，他能操作很多属性，比如改变一个控件的宽高值；一个数值平滑过渡到另一个数值等，总之，View动画能做的他能做，View动画不能做的他也能做。对，你没看错，就是这么屌！</p>
<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>View动画，包括以下几种类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AlphaAnimation</td>
<td style="text-align:center">渐变透明度</td>
</tr>
<tr>
<td style="text-align:center">RotateAnimation</td>
<td style="text-align:center">画面旋转</td>
</tr>
<tr>
<td style="text-align:center">ScaleAnimation</td>
<td style="text-align:center">尺寸缩放</td>
</tr>
<tr>
<td style="text-align:center">TranslateAnimation</td>
<td style="text-align:center">位置移动</td>
</tr>
</tbody>
</table>
<p>属性动画(Property Animation)，包括以下几种类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ObjectAnimator</td>
<td style="text-align:center">动画执行类，对对象进行操作</td>
</tr>
<tr>
<td style="text-align:center">ValueAnimator</td>
<td style="text-align:center">动画执行类，对数值进行操作</td>
</tr>
</tbody>
</table>
<p>今天我们将使用到的是<code>ValueAnimation</code>类，接下来对动画进行分析，看看要实现指针偏转的动画需要用到什么方法。</p>
<ol>
<li>指针偏转是通过旋转角度来实现的，如果我们要使偏转产生动画，就需要动态的改变旋转的角度。</li>
<li>旋转的角度参数类型是float，在ValueAnimator类中的ofFloat()方法正好是动态改变float数值的，所以我们要用到它。</li>
<li>数值每改变一次，我们都要把变化后的数值赋给rotate()方法，使指针旋转相应角度，所以这里需要对数值变化进行监听，因此会用到addUpdateListener()方法</li>
<li>赋值给rotate()方法后，需要对视图进行重绘，因此我们需要用到视图绘制过程中的invalidate()方法</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里我们用<code>mValue</code>表示指向数值，用变量<code>mAngle</code>表示通过计算后的偏转角度</p>
<p>通常的做法，我们都是在Activity或者Fragment里通过调用一个方法，将指针要指向的数值(<code>mValue</code>)数的方式传递过去，这样的话，我们就有两种思路。</p>
<p>一：使用<code>ofFloat()</code>方法动态改变指针指向的数值，即传递过来的参数mValue</p>
<p>二：将传递过来的参数进行计算成指针偏转的角度(<code>mAngle</code>)，然后使用<code>ofFloat()</code>方法动态改变角度数值</p>
<p>这两种方法都是可取的，具体情况具体分析，由于在界面上我们要动态显示指针指向的数值，如果采用第二种的话，那么我们要计算两次，一次是将指向mValue计算为mAngle，数值动态变化后还要将mAngle计算为mValue，这样比较麻烦，所以我们采用第一种思路。</p>
<p>因此，要实现指针的偏转动画，代码可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">private int mMaxValue = 50;  //分值区间的最大值</div><div class="line">private int mMinValue = -50; //分值区间的最小值</div><div class="line">/**输入值，通过输入值来计算指针的旋转角度，即&#123;@mAngle&#125;的值,</div><div class="line"> * 最终在界面上呈现的效果是指针指向输入值的刻度上*/</div><div class="line">private String mValue = &quot;- -&quot;;</div><div class="line">/**刻度盘呈现的总弧度，本案例中总弧度为180，呈半圆形*/</div><div class="line">private float mArc = 180f;</div><div class="line">/**指针旋转角度值*/</div><div class="line">private float mAngle = 0f;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">/**</div><div class="line"> * 设置指针指向数值，并产生旋转动画</div><div class="line"> * 这里我们动态改变指向数值</div><div class="line"> * @param value 指向数值</div><div class="line"> */</div><div class="line">public void setValue(float value)&#123;</div><div class="line">    //&#123;@param value&#125;为指针将要指向的数值，即界面上看到的数值</div><div class="line">    ValueAnimator startAnimator = ValueAnimator.ofFloat(0, value);</div><div class="line"></div><div class="line">    startAnimator.addUpdateListener(</div><div class="line">       new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">            //通过getAnimatedValue()取变化后的值</div><div class="line">            float md = (float) animation.getAnimatedValue();</div><div class="line">            //计算指针当前应该偏转的角度</div><div class="line">            mAngle = md * (mArc / (float) (mMaxValue - mMinValue));</div><div class="line">            //界面上显示当前指针显示的数值</div><div class="line">            mValue = String.valueOf((int)md);</div><div class="line">            //调用重绘方法</div><div class="line">            invalidate();</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    startAnimator.setDuration(1000);</div><div class="line">    startAnimator.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>setValue()</code>方法里我们动态的改变了指针指向的数值和指针偏转的角度，并把这两个数值分别存放在全局变量<code>mValue</code>和<code>mAngle</code>，这样一来，我们只需要在<code>onDraw()</code>方法中，对指针进行旋转和但前指向数值的显示就可以了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 注意：</div><div class="line"> * 下方的所以坐标计算和长度计算都是依据在屏幕宽度为621px情况下的</div><div class="line"> * @param canvas</div><div class="line"> */</div><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    System.out.println(&quot;mAngle ==&gt;&quot; + mAngle);</div><div class="line">    canvas.rotate(mAngle, xc, yc);</div><div class="line"></div><div class="line">    //画指针</div><div class="line">    /**</div><div class="line">     * xc * 0.101449 = 深色刻度线条的长度</div><div class="line">     * mWidth * 0.064412 = 在屏幕宽度为621下，长度为40</div><div class="line">     * 所以下面第三个参数的值可以理解为距离深色刻度线下方有40倍数的间隙</div><div class="line">     */</div><div class="line">    canvas.drawLine(xc, yc,</div><div class="line">            xc - radius + (xc * 0.101449f + mWidth * 0.064412f),</div><div class="line">            yc + 3, paintCursor);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    //值</div><div class="line">    pitchValuePaint.setAntiAlias(true);</div><div class="line">    pitchValuePaint.setTextSize((mWidth * 0.080515f));</div><div class="line">    pitchValuePaint.setColor(getResources().getColor(R.color.colorAccent));</div><div class="line"></div><div class="line">    canvas.drawText(mValue,</div><div class="line">            xc - pitchValuePaint.measureText(mValue) / 2,</div><div class="line">            yc + (xc * 0.481481f + mWidth * 0.209339f),</div><div class="line">            pitchValuePaint);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果如下：</p>
<p><img src="http://www.bit100.com/.zhongzilu/image/TunerView.gif" alt=""></p>
<p>详细的代码，请移步到我的GitHub：<a href="https://github.com/zhongzilu/TunerView" target="_blank" rel="external">https://github.com/zhongzilu/TunerView</a></p>
<p>我是钟子路，Thanks for watching!</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Canvas绘制图形-拾音器]]></title>
      <url>http://zhongzilu.github.io/2016/05/26/Android-Canvas%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2-%E6%8B%BE%E9%9F%B3%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="Android-Canvas-绘制图形-—-拾音器"><a href="#Android-Canvas-绘制图形-—-拾音器" class="headerlink" title="Android Canvas 绘制图形 — 拾音器"></a>Android Canvas 绘制图形 — 拾音器</h2><blockquote>
<p>最近在网上看到一个拾音器的设计图，看起来挺美观的，于是我就想把它实现出来，不多废话，先看图，左边是设计图，右边是实现图<br><img src="http://www.bit100.com/.zhongzilu/image/TunerView_design.png" alt="设计图"><img src="http://www.bit100.com/.zhongzilu/image/TunerView_preview.png" alt="实现效果图"></p>
</blockquote>
<p>除了指针不同，其他的大体上一样</p>
<h3 id="Android-Canvas介绍"><a href="#Android-Canvas介绍" class="headerlink" title="Android Canvas介绍"></a>Android Canvas介绍</h3><p>Canvas作为绘制图形的直接对象，提供了以下几个非常有用的方法</p>
<blockquote>
<ul>
<li>Canvas.save()</li>
<li>Canvas.restore()</li>
<li>Canvas.translate()</li>
<li>Canvas.roate()</li>
</ul>
</blockquote>
<p><code>Canvas.save()</code>这个方法，从字面上理解就是保存的意思，而它的作用也正是将之前的画布保存起来，让后续的操作能像在新的画布上一样操作，这个PhotoShop的图层是一个概念<br><code>Canvas.restore()</code>这个方法，可以理解为合并图层，就是将之前保存下来的图层合并为一个图层<br><code>Canvas.translate()</code>这个方法，可以理解为移动坐标系，很多人在用时，理解为移动画布，所以在计算坐标时会出一些问题，在这里把他理解为移动坐标系更加恰当。画布的初始坐标系是左上角，如果我们调用translate(x, y)之后，则表示将原点(0, 0)移动到了(x, y)，后面的坐标计算都是在这一点上进行的<br><code>Canvas.roate()</code>可以理解为旋转坐标系，用法和Canvas.translate()相似，但多了个角度的参数，调用roate(degree, x, y)之后，则表示将以(x, y)为原点的坐标系旋转degree个角度</p>
<hr>
<blockquote>
<p>Paint理解为画笔，在Canvas上所有的图形，都需要这个对象，以下有几个常用方法</p>
<ul>
<li>paint.setAntiAlias()</li>
<li>paint.setStyle()</li>
<li>paint.setStrokeWidth()</li>
<li>paint.setColor()</li>
</ul>
</blockquote>
<p><code>paint.setAntiAlias()</code>是给画笔设置是否抗锯齿，参数为布尔类型<br><code>paint.setStyle()</code>是给画笔设置画笔样式<br><code>paint.setStrokeWidth()</code>给画笔设置画笔宽度<br><code>paint.setColor()</code>给画笔设置画笔颜色</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>有了上面的理论基础，现在我们可以来实现上面的效果了，先来分析一下上面效果图中有什么</p>
<blockquote>
<ol>
<li>刻度盘——外面的半圆刻度盘</li>
<li>刻度线——整数的深色粗线和其余德灰色细线</li>
<li>圆形底盘——共三个圆形底盘，最上面的深蓝色圆形要在指针上面</li>
<li>指针</li>
</ol>
</blockquote>
<p>新建一个类，继承View<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class TunerView extends View &#123;</div><div class="line">    private int mWidth;</div><div class="line">    private int mHeight;</div><div class="line"></div><div class="line">    public TunerView(Context context)&#123;</div><div class="line">        super(context);</div><div class="line">        //获取屏幕的宽高</div><div class="line">        WindowManager windowManager = </div><div class="line">            (WindowManager) getContext().Context.WINDOW_SERVICE);</div><div class="line"></div><div class="line">        mWidth = windowManager.getDefaultDisplay().getWidth();</div><div class="line">        mHeight = windowManager.getDefaultDisplay().getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>第一步(Step 1)：画刻度盘</strong></p>
<p>由于画布一开始绘制文字时，文字是垂直的，而在设计图中刻度盘是从左往右，文字是水平的，所以需要先对画布坐标系进行旋转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">    int xc = mWidth / 2;    //屏幕中心X坐标</div><div class="line">    int yc = mHeight / 2;   //屏幕中心Y坐标</div><div class="line">    int radius = xc - 30;   //圆半径</div><div class="line">    /**</div><div class="line">     * 正常情况下，一开始写文字，都是垂直的，但我们的仪表盘</div><div class="line">     * 要求从左边开始画，文字是水平的，所以需要先对画布坐标系进行逆时针旋转90°</div><div class="line">     */</div><div class="line">    canvas.rotate(-90, xc, yc);</div><div class="line"></div><div class="line">    //画刻度盘</div><div class="line">    Paint paintDegree = new Paint();</div><div class="line">    paintDegree.setStrokeWidth(3);</div><div class="line">    //画刻度线条</div><div class="line">    for (int i = -50; i &lt;= 50; i++)&#123;</div><div class="line">        //区别整点和非整点的线条样式</div><div class="line">        if (i % 10 == 0)&#123;</div><div class="line">            paintDegree.setStrokeWidth(5);</div><div class="line">            paintDegree.setTextSize(30);</div><div class="line">            paintDegree.setAntiAlias(true);</div><div class="line">            paintDegree.setColor(getResources().getColor(R.color.colorAccent));</div><div class="line">            //这里画线的坐标计算，需要自行去理解，这里我就不多加解释了</div><div class="line">            canvas.drawLine(xc, yc - radius, xc, yc - radius + 40, paintDegree);</div><div class="line">            String degree = String.valueOf(i);</div><div class="line">            canvas.drawText(degree,</div><div class="line">                    //这里使用了Paint对象的measureText()方法,</div><div class="line">                    //该方法是传入一个String类型的参数，经过计算之后返回该String对象中</div><div class="line">                    //文字所占用的宽度</div><div class="line">                    xc - paintDegree.measureText(degree) / 2,</div><div class="line">                    yc - radius + 70,</div><div class="line">                    paintDegree);</div><div class="line">            /**</div><div class="line">             * 由于本案中两个整点之间只被分为了5分，所以每份的间隔就是2</div><div class="line">             */</div><div class="line">        &#125; else if (i % 2 == 0)&#123;</div><div class="line">            paintDegree.setStrokeWidth(3);</div><div class="line">            paintDegree.setTextSize(15);</div><div class="line">            paintDegree.setAntiAlias(true);</div><div class="line">            paintDegree.setColor(getResources().getColor(R.color.grey));</div><div class="line">            canvas.drawLine(xc, yc - radius + 10, xc, yc - radius + 30, paintDegree);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //每画完一条刻度线条，就需要对画布坐标系进行旋转，通过旋转简化坐标运算</div><div class="line">        //旋转角度为：总度数 / 总份数</div><div class="line">        //本案例中，总度数为180°, 分值区间为(-50 ~ 50),所以总份数为100份</div><div class="line">        canvas.rotate((float)(180 / 100), xc, yc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //画圆形底盘</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行效果：<br><img src="http://www.bit100.com/.zhongzilu/image/TunerView_step_1.png" alt="完成刻度盘"></p>
<p><strong>第二步(Step 2)：画园形底盘</strong></p>
<p>画实心圆形底盘，通过调用<code>paint.setColor()</code>来设置颜色，调用<code>paint.drawCircle()</code>方法来画出圆形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//画大圆盘</div><div class="line">Paint bigCircle = new Paint();</div><div class="line">bigCircle.setColor(getResources().getColor(R.color.colorPrimary));</div><div class="line">bigCircle.setAntiAlias(true);</div><div class="line">canvas.drawCircle(xc, yc, xc - 180, bigCircle);</div><div class="line">//画中等圆盘</div><div class="line">Paint midCircle = new Paint();</div><div class="line">midCircle.setColor(getResources().getColor(R.color.colorPrimaryDark));</div><div class="line">midCircle.setAntiAlias(true);</div><div class="line">canvas.drawCircle(xc, yc, xc - 280, midCircle);</div><div class="line">//画小圆盘</div><div class="line">Paint smallCircle = new Paint();</div><div class="line">smallCircle.setColor(getResources().getColor(R.color.colorAccent));</div><div class="line">smallCircle.setAntiAlias(true);</div><div class="line">canvas.drawCircle(xc, yc, xc - 320, smallCircle);</div></pre></td></tr></table></figure></p>
<p><code>drawCircle()</code>方法有四个参数，</p>
<ul>
<li>cx：圆心的x坐标，float类型</li>
<li>cy：圆心的y坐标，float类型</li>
<li>radius：圆形的半径，float类型</li>
<li>paint：画笔对象，Paint类型</li>
</ul>
<p>运行效果：<br><img src="http://www.bit100.com/.zhongzilu/image/TunerView_step_2.png" alt="画三个圆形底盘"></p>
<p><strong>第三步(Step 3)：画指针</strong><br>画指针其实和画线是一个道理，所以我们直接调用<code>drawLine()</code>方法就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//画指针</div><div class="line">Paint paintCursor = new Paint();</div><div class="line">paintCursor.setStrokeWidth(3);</div><div class="line">paintCursor.setAntiAlias(true);</div><div class="line">paintCursor.setColor(getResources().getColor(R.color.colorAccent));</div><div class="line">canvas.drawLine(xc, yc, xc - radius + 80, yc + 10, paintCursor);</div></pre></td></tr></table></figure></p>
<p><code>drawLine()</code>方法有5个参数</p>
<ul>
<li>startX：线条的起始点x坐标，类型float</li>
<li>startY：线条的起始点y坐标，类型float</li>
<li>stopX：线条的结束点x坐标，类型float</li>
<li>stopY：线条的结束点y坐标，类型float</li>
<li>paint：画笔对象，Paint类型</li>
</ul>
<p>运行效果：<br><img src="http://www.bit100.com/.zhongzilu/image/TunerView_step_3.png" alt="指针绘制"></p>
<p><strong>这里注意一下，由于我们的指针使用的颜色和最小的那个圆形的颜色是一样的，所以运行效果里看不出问题，如果换一个颜色，就会发现，指针在最小的圆形上面，而设计图上的指针是在最小的圆形下面，那么这要怎么解决呢？不要方，只需要把绘制最小那个圆的<code>canvas.drawCircle()</code>方法放到绘制指针的<code>drawLine()</code>方法之后就可以了</strong></p>
<p><strong>第四步(Step 4)：画正下方的文字</strong></p>
<p>画正下方的文字，只需要调用<code>canvas.drawText()</code>方法就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Paint pitchPaint = new Paint();</div><div class="line">pitchPaint.setAntiAlias(true);  //设置抗锯齿</div><div class="line">pitchPaint.setTextSize(40); </div><div class="line">pitchPaint.setColor(getResources().getColor(R.color.colorAccent));</div><div class="line">String pitch = &quot;Pitch&quot;;</div><div class="line">canvas.drawText(pitch,</div><div class="line">        xc - pitchPaint.measureText(pitch) / 2,</div><div class="line">        //这里加上180，是因为要加上最外面那个大的圆形的半径</div><div class="line">        //再加上80，是为了让文字和最大的那个圆产生间隙</div><div class="line">        yc + 180 + 80,</div><div class="line">        pitchPaint);</div></pre></td></tr></table></figure></p>
<p>运行效果：<br><img src="http://www.bit100.com/.zhongzilu/image/TunerView_step_4.png" alt="绘制正下方的文字"></p>
<p>可以看到文字的方向不对，<strong>为什么文字的方向不对呢？</strong>这是因为我们在绘制刻度盘的时候，我们对画布坐标系进行了旋转，画完刻度盘之后，坐标系被旋转了180°，但由于在绘制刻度盘之前，我们对整个画布坐标系进行逆时针旋转了90°，所以实际上只旋转了90°，因此，我们看到绘制的文字不是在正下方，而是在左边，被旋转了90°，<strong>那么这要怎么解决呢？</strong>最简单的方法当然是在绘制文字之前，把画布坐标系旋转回来。所以需要添加一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas.rotate(-90, xc, yc);</div></pre></td></tr></table></figure></p>
<p>运行效果<br><img src="http://www.bit100.com/.zhongzilu/image/TunerView_step_4_1.png" alt="最终效果"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>由于上面的案例代码里用到了很多写死的数字代码(Hard Code)，这不利于代码的灵活性，而且，既然有指针，就应该让指针根据一个提供的输入值，来让指针指向对应的数值位置，所以，我对代码进行了改良，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by zhongzilu on 2016/5/25 0025.</div><div class="line"> */</div><div class="line">public class DialView extends View &#123;</div><div class="line"></div><div class="line">    private float mWidth;</div><div class="line">    private float mHeight;</div><div class="line">    private float mAngle = 0;   //指针旋转角度，值为0时指针垂直显示</div><div class="line">    private static int mMaxValue = 50;  //分值区间的最大值</div><div class="line">    private static int mMinValue = -50; //分值区间的最小值</div><div class="line">    /**输入值，通过输入值来计算指针的旋转角度，即&#123;@mAngle&#125;的值,</div><div class="line">     * 最终在界面上呈现的效果是指针指向输入值的刻度上*/</div><div class="line">    private float mValue = 0;</div><div class="line">    /**刻度盘呈现的总弧度，本案例中总弧度为180，呈半圆形*/</div><div class="line">    private float mArc = 180;</div><div class="line"></div><div class="line">    public DialView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line"></div><div class="line">        //获取屏幕的宽高</div><div class="line">        WindowManager windowManager = (WindowManager) getContext().getSystemService(</div><div class="line">                Context.WINDOW_SERVICE);</div><div class="line">        mWidth = windowManager.getDefaultDisplay().getWidth();</div><div class="line">        mHeight = windowManager.getDefaultDisplay().getHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 注意：</div><div class="line">     * 下方的所以坐标计算和长度计算都是依据在屏幕宽度为621px情况下的</div><div class="line">     * @param canvas</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line"></div><div class="line">        float xc = mWidth / 2;    //圆中心X坐标</div><div class="line">        float yc = mHeight / 2;   //圆中心Y坐标</div><div class="line">        float radius = (float)(xc - xc * 0.05314);   //圆半径</div><div class="line"></div><div class="line">        //画刻度盘</div><div class="line">        Paint paintDegree = new Paint();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 正常情况下，一开始画线或写文字，都是垂直的，但我们的仪表盘</div><div class="line">         * 要求从左边开始画，文字是水平的，所以需要先进行画布旋转90°</div><div class="line">         */</div><div class="line">        canvas.rotate((-mArc / 2), xc, yc);</div><div class="line">        System.out.println(&quot;before rotate==&gt;&quot; + (-mArc / 2));</div><div class="line">        /**</div><div class="line">         * 本案例中，设置的分值区间为（-50 ~ 50)</div><div class="line">         */</div><div class="line">        for (int i = mMinValue; i &lt;= mMaxValue; i++)&#123;</div><div class="line">            //区别整点和非整点</div><div class="line">            if (i % 10 == 0)&#123;</div><div class="line">                //在屏幕宽度为621下，大小为5</div><div class="line">                paintDegree.setStrokeWidth((float)(mWidth * 0.008051));</div><div class="line">                //刻度字体大小是依据是：在屏幕宽度为621的分辨率下，刚好为30</div><div class="line">                paintDegree.setTextSize((float)(mWidth * 0.048309));</div><div class="line">                paintDegree.setAntiAlias(true);</div><div class="line">                paintDegree.setColor(getResources().getColor(R.color.colorAccent));</div><div class="line">                canvas.drawLine(xc, yc - radius, xc, (float)(yc - radius + xc * 0.101449), paintDegree);</div><div class="line">                String degree = String.valueOf(i);</div><div class="line">                canvas.drawText(degree,</div><div class="line">                        //这里使用了Paint对象的measureText()方法,</div><div class="line">                        //该方法是传入一个String类型的参数，经过计算之后返回该String对象中</div><div class="line">                        //文字所占用的宽度</div><div class="line">                        xc - paintDegree.measureText(degree) / 2,</div><div class="line"></div><div class="line">                        //下方mWidth * 0.048309 = 在屏幕宽度为621下，长度为30</div><div class="line">                        yc - radius + (float)(xc * 0.101449 + mWidth * 0.048309),</div><div class="line">                        paintDegree);</div><div class="line">                /**</div><div class="line">                 * 由于两个整点之间只被分为了5分，所以每份的间隔就是2</div><div class="line">                 */</div><div class="line">            &#125; else if (i % 2 == 0)&#123;</div><div class="line">                paintDegree.setStrokeWidth((float)(mWidth * 0.004830));</div><div class="line">                //在屏幕宽度为621下，字体大小为15</div><div class="line">                paintDegree.setTextSize((float)(mWidth * 0.024154));</div><div class="line">                paintDegree.setAntiAlias(true);</div><div class="line">                paintDegree.setColor(getResources().getColor(R.color.grey));</div><div class="line">                /**</div><div class="line">                 * 画灰色短横线，坐标计算依据是灰色短横向长度为深色长横线的一半，</div><div class="line">                 * 并且，两种刻度线的中点在同一个圆的圆弧上</div><div class="line">                 * 由于深色刻度线的长度 = 正中深色小圆的半径 = 屏幕宽度一半的0.101449倍</div><div class="line">                 */</div><div class="line">                canvas.drawLine(xc, </div><div class="line">                        (float)(yc - radius + xc * 0.101449 / 4), </div><div class="line">                        xc, </div><div class="line">                        (float)(yc - radius + xc * 0.101449 / 4 * 3), </div><div class="line">                        paintDegree);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            //通过旋转画布简化坐标运算</div><div class="line">            canvas.rotate(mArc / (float)(mMaxValue - mMinValue), xc, yc);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 三个圆盘的半径和屏幕宽度的一半的比例为</div><div class="line">         * 屏幕宽度一半 ：大圆 ：中圆 ：小圆 =</div><div class="line">         * 1 ：0.481481 ：0.201288 ：0.101449</div><div class="line">         */</div><div class="line">        //画大圆盘</div><div class="line">        Paint bigCircle = new Paint();</div><div class="line">        bigCircle.setColor(getResources().getColor(R.color.colorPrimary));</div><div class="line">        bigCircle.setAntiAlias(true);</div><div class="line">        canvas.drawCircle(xc, yc, (float)(xc * 0.481481), bigCircle);</div><div class="line">        //画中等圆盘</div><div class="line">        Paint midCircle = new Paint();</div><div class="line">        midCircle.setColor(getResources().getColor(R.color.colorPrimaryDark));</div><div class="line">        midCircle.setAntiAlias(true);</div><div class="line">        canvas.drawCircle(xc, yc, (float)(xc * 0.201288), midCircle);</div><div class="line">        //画小圆盘</div><div class="line">        Paint smallCircle = new Paint();</div><div class="line">        smallCircle.setColor(getResources().getColor(R.color.colorAccent));</div><div class="line">        smallCircle.setAntiAlias(true);</div><div class="line">        canvas.drawCircle(xc, yc, (float)(xc * 0.101449), smallCircle);</div><div class="line">        canvas.save();</div><div class="line"></div><div class="line">        //画指针</div><div class="line">        Paint paintCursor = new Paint();</div><div class="line">        //在屏幕宽度为621下，大小为3</div><div class="line">        paintCursor.setStrokeWidth((float)(mWidth * 0.004830));</div><div class="line">        paintCursor.setAntiAlias(true);</div><div class="line">        paintCursor.setColor(getResources().getColor(R.color.colorAccent));</div><div class="line">        /**</div><div class="line">         * 思路：要想让指针以圆心为中心旋转一定角度，要么旋转画布，要么根据坐标来画，</div><div class="line">         * 由于旋转角度比根据坐标更简单，所以就用旋转角度的方式来实现</div><div class="line">         *</div><div class="line">         * 指针具体旋转多少度，得根据算法来计算</div><div class="line">         *</div><div class="line">         * 算法：角度 = 输入值 * （ 总弧度 / 分值总数）</div><div class="line">         *</div><div class="line">         * 举例：本案例中给出的分值区间为（-50 ~ 50）,所以分值总数为100</div><div class="line">         * 假设现在输入值为30，那么角度就为54°</div><div class="line">         */</div><div class="line">        mAngle = mValue * (mArc / (float) (mMaxValue - mMinValue));</div><div class="line">        System.out.println(&quot;mAngle ==&gt;&quot; + mAngle);</div><div class="line">        canvas.rotate(mAngle, xc, yc);</div><div class="line">        /**</div><div class="line">         * xc * 0.101449 = 深色刻度线条的长度</div><div class="line">         * mWidth * 0.064412 = 在屏幕宽度为621下，长度为40</div><div class="line">         * 所以下面第三个参数的值可以理解为距离深色刻度线下方有40倍数的间隙</div><div class="line">         */</div><div class="line">        canvas.drawLine(xc, yc,</div><div class="line">                xc - radius + (float)(xc * 0.101449 + mWidth * 0.064412),</div><div class="line">                yc + 3, paintCursor);</div><div class="line"></div><div class="line">        //覆盖在指针上的圆</div><div class="line">        /**</div><div class="line">         * 由于之前的坐标系已经发生了旋转，所以要在正下方写上文字，就需要旋转回来</div><div class="line">         * 当然也可以通过去计算坐标来显示在正下方，但旋转画布的方式更加简单和更容易理解</div><div class="line">         */</div><div class="line">        canvas.rotate(-(mAngle + mArc / 2), xc, yc);</div><div class="line"></div><div class="line">        Paint pitchPaint = new Paint();</div><div class="line">        pitchPaint.setAntiAlias(true);</div><div class="line">        //在屏幕宽度为621下，字体大小为40</div><div class="line">        pitchPaint.setTextSize((float)(mWidth * 0.048309));</div><div class="line">        pitchPaint.setColor(getResources().getColor(R.color.colorAccent));</div><div class="line">        String pitch = &quot;Pitch&quot;;</div><div class="line">        canvas.drawText(pitch,</div><div class="line">                xc - pitchPaint.measureText(pitch) / 2,</div><div class="line">                //这里加上180，是因为要加上最外面那个大的圆形的半径</div><div class="line">                //再加上(mWidth * 0.123188)，是为了让文字和最大的那个圆产生间隙</div><div class="line">                //在屏幕宽度为621下，间隙为80</div><div class="line">                yc + (float)(xc * 0.481481 + mWidth * 0.123188),</div><div class="line">                pitchPaint);</div><div class="line"></div><div class="line">        //值</div><div class="line">        Paint pitchValuePaint = new Paint();</div><div class="line">        pitchValuePaint.setAntiAlias(true);</div><div class="line">        pitchValuePaint.setTextSize((float)(mWidth * 0.080515));</div><div class="line">        pitchValuePaint.setColor(getResources().getColor(R.color.colorAccent));</div><div class="line">        String value = &quot;- -&quot;;</div><div class="line">        canvas.drawText(value,</div><div class="line">                xc - pitchValuePaint.measureText(value) / 2,</div><div class="line">                yc + (float)(xc * 0.481481 + mWidth * 0.209339),</div><div class="line">                pitchValuePaint);</div><div class="line"></div><div class="line">        canvas.restore();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过修改过后，只需要修改全局变量<code>mValue</code>的值，就可以使指针指向界面上对应的值了，比如<code>mValue = 30</code>，运行效果<br><img src="http://www.bit100.com/.zhongzilu/image/TunerView_step_5.png" alt="指针旋转测试"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，没什么难度，关键点在于绘图时的坐标计算，以及对旋转画布的理解，旋转画布是旋转的画布坐标系。在本案例中，我没有对指针的旋转做动画处理，是因为本文重在讲解Canvas画图，各位也可以自行加上指针旋转动画代码。好了，以上就是今天的内容，各位可以发挥自己的想象力，绘制出更多更有趣的图形。我是钟子路，Thanks for watching!</p>
<blockquote>
<p><strong>作者</strong>：<a href="http://www.bit100.com" target="_blank" rel="external">zhongzilu</a><br><strong>源码</strong>：<a href="https://github.com/zhongzilu/TunerView" target="_blank" rel="external">https://github.com/zhongzilu/TunerView</a> </p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【安卓热修复】当你准备开发一个热修复框架需要了解的一切]]></title>
      <url>http://zhongzilu.github.io/2016/05/24/%E3%80%90%E5%AE%89%E5%8D%93%E7%83%AD%E4%BF%AE%E5%A4%8D%E3%80%91%E5%BD%93%E4%BD%A0%E5%87%86%E5%A4%87%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%A1%86%E6%9E%B6%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E5%88%87/</url>
      <content type="html"><![CDATA[<h2 id="【安卓热修复】当你准备开发一个热修复框架的时候，你需要了解的一切"><a href="#【安卓热修复】当你准备开发一个热修复框架的时候，你需要了解的一切" class="headerlink" title="【安卓热修复】当你准备开发一个热修复框架的时候，你需要了解的一切"></a>【安卓热修复】当你准备开发一个热修复框架的时候，你需要了解的一切</h2><p>很长一段时间前，在我用应用市场软件对我移动设备上的应用更新时，发现每次应用市场提示我更新应用的大小，都有一个节省多少兆大小的醒目文字。当时我很奇怪，难道是对应用安装包进行了压缩吗？过了一段时间后，在我浏览其他人博客时，无意间发现有篇写安卓应用安装包热补丁修复的文章，我仔细看了一遍，一时之间也没看懂，再加上那时也没太多精力，也就搁置起来了，没有进一步了解。</p>
<p>今天工作之余，又在我浏览博客时，再次发现了一篇关于热修复的文章，我看了一下，讲得挺有条理的，特此推荐给大家</p>
<p>原文博客链接：<a href="http://zjutkz.net/2016/05/23/%E5%BD%93%E4%BD%A0%E5%87%86%E5%A4%87%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%A1%86%E6%9E%B6%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E5%88%87/" target="_blank" rel="external">当你准备开发一个热修复框架的时候，你需要了解的一切</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[SEO如何提高百度权重]]></title>
      <url>http://zhongzilu.github.io/2016/05/20/SEO%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%99%BE%E5%BA%A6%E6%9D%83%E9%87%8D/</url>
      <content type="html"><![CDATA[<h2 id="SEO如何提高百度权重"><a href="#SEO如何提高百度权重" class="headerlink" title="SEO如何提高百度权重"></a>SEO如何提高百度权重</h2><blockquote>
<p>大家好，我是钟子路，最近在负责公司的网站SEO，我也不是太会，就去查看很多的资料和博客，当然，其中很多方法都是差不多的，所以我在这里就不重复了， 今天就讲讲我无意间发现的，关于如何提高百度权重的方法，由于该方法还没得到验证，所以这里只是提供一种思路，如果可行，请分享给其他有需要的人。</p>
</blockquote>
<h3 id="科普时间"><a href="#科普时间" class="headerlink" title="科普时间"></a>科普时间</h3><p>百度权重是站长工具推出的针对网站优化关键词排名预计给网站带来流量，划分出0-9十个等级的第三方网站欢迎度评估数据。</p>
<p>百度官方目前只公开了竞价推广用户提供0-10不同分值关键词质量度的评级。</p>
<p>权重数值越大，说明网站自然流量越大，自然流量大，那么相应的关键词排名就相对靠前，权重，流量，关键词排名三者之间是相辅相成的。</p>
<p>网站关键词的数量越多，积累的权重也会越高，不过，这还要看关键词的流量，如果关键词的流量非常的低，即便排名很靠前，权重也不会积累到很多，不过可以积少成多。</p>
<p>百度权重的规则：</p>
<blockquote>
<p>权重1 百度预计流量1~99<br>权重2 百度预计流量100~499<br>权重3 百度预计流量500~999<br>权重4 百度预计流量1000~4999<br>权重5 百度预计流量5000~9999<br>权重6 百度预计流量10000~49999<br>权重7 百度预计流量50000~199999<br>权重8 百度预计流量200000~999999<br>权重9 百度预计流量1000000以上</p>
</blockquote>
<p>站长们要查看自己网站的权重，通常是通过站长工具进行查询的，我也不例外，直接在百度上搜索“站长工具”就可以了，百度权重查询地址<a href="http://rank.chinaz.com/，输入自己网站的网址就可以查询到当前的百度权重了。如下图：" target="_blank" rel="external">http://rank.chinaz.com/，输入自己网站的网址就可以查询到当前的百度权重了。如下图：</a></p>
<p><img src="http://www.bit100.com/.zhongzilu/image/zhanzhanggongju.png" alt=""></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>既然关键字的流量和权重有直接关系，那么我们就可以在自己网站关键字里加入一些高频次、高流量的搜索关键词，这样可以让自己的网站更容易出现在搜索结果里，如果点击了你的网站，就会给自己网站增加一部分流量，而流量的大小决定网站的权重。</p>
<p><strong>那么如何获得高频次、高流量的搜索关键词呢？</strong></p>
<p>这里就需要通过百度指数来进行查找了，百度指数地址<a href="http://index.baidu.com/" target="_blank" rel="external">http://index.baidu.com/</a></p>
<p><img src="http://www.bit100.com/.zhongzilu/image/baidu_index.png" alt=""></p>
<p>输入要查询的关键字就可以查询到关键字的搜索指数以及历史趋势记录</p>
<p><img src="http://www.bit100.com/.zhongzilu/image/baidu_index_key_word.png" alt=""></p>
<p>点击上部【需求图谱】选项卡，可以挖掘指定关键字相近关键字的分布指数</p>
<p><img src="http://www.bit100.com/.zhongzilu/image/baidu_index_chart.png" alt=""></p>
<p>这里的数据挺直观详细的，我就不多赘述了，祝愿各位站长们找到自己满意的关键字，Good luck!</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在Android Studio中创建File Templates]]></title>
      <url>http://zhongzilu.github.io/2016/05/10/%E5%A6%82%E4%BD%95%E5%9C%A8Android-Studio%E4%B8%AD%E5%88%9B%E5%BB%BAFile-Templates/</url>
      <content type="html"><![CDATA[<h2 id="如何在Android-Studio中创建File-Templates"><a href="#如何在Android-Studio中创建File-Templates" class="headerlink" title="如何在Android Studio中创建File Templates"></a>如何在Android Studio中创建File Templates</h2><p>标签： <code>File Template</code> <code>Android Studio</code></p>
<blockquote>
<p>我发现一个可以让写程序变得简单的方法，那就是自定义文件模板(Custom File Templates).那么什么是File Templates呢？说白了，就是一个已经包含一部分代码的源文件</p>
</blockquote>
<h3 id="如何创建File-Templates"><a href="#如何创建File-Templates" class="headerlink" title="如何创建File Templates"></a>如何创建File Templates</h3><p>首先，找到创建File Template的位置，依次打开<code>File ==&gt; Setting ==&gt; Editor ==&gt; File and Code Templates</code><br><img src="http://www.bit100.com/.zhongzilu/image/Settings.png" alt="File Templates Settings"></p>
<p>之后点击 <code>+</code>号添加一个File Template，这里需要填写 File Template的名称和代码。在本次案例中，我们将创建一个实现了部分方法的RecyclerViewAdapter的File Template。因此就取名叫RecyclerViewAdapter<br><img src="http://www.bit100.com/.zhongzilu/image/RecyclerViewAdapter.png" alt="RecyclerViewAdapter"></p>
<p>之后你就可以在下方的代码区域粘贴或者编写你的模板代码了。这里有几个预置的变量可以使用，当文件被创建的时候，这些预置的变量将会被 将会被对应的值替代，变量如下：</p>
<ul>
<li><code>${NAME}</code> 选择的文件的文件名</li>
<li><code>${PACKAGE_NAME}</code>包名</li>
<li><code>${DATE}</code> 系统当前的时间<br>当然，你也可以自定义变量，在本案例中，我们需要提供<code>ViewHolder</code>类和集合List的类型，所以自定义变量分别为<code>${VIEWHOLDER_CLASS}</code>和<code>${ITEM_CLASS}</code></li>
</ul>
<p>那么现在就来编写用于创建模板的代码，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.support.v7.widget.RecyclerView;</div><div class="line">import android.view.LayoutInflater;</div><div class="line">import android.view.View;</div><div class="line">import android.view.ViewGroup;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">#parse(&quot;File Header.java&quot;)</div><div class="line">public class $&#123;NAME&#125; extends RecyclerView.Adapter&lt;$&#123;VIEWHOLDER_CLASS&#125;&gt; &#123;</div><div class="line">  private final Context context;</div><div class="line">  private List&lt;$&#123;ITEM_CLASS&#125;&gt; items;</div><div class="line"></div><div class="line">  public $&#123;NAME&#125;(List&lt;$&#123;ITEM_CLASS&#125;&gt; items, Context context) &#123;</div><div class="line">    this.items = items;</div><div class="line">    this.context = context;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public $&#123;VIEWHOLDER_CLASS&#125; onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">    View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.$&#123;LAYOUT_RES_ID&#125;, parent, false);</div><div class="line">    return new $&#123;VIEWHOLDER_CLASS&#125;(v);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void onBindViewHolder($&#123;VIEWHOLDER_CLASS&#125; holder, int position)&#123;</div><div class="line">    $&#123;ITEM_CLASS&#125; item = items.get(position);</div><div class="line">    //TODO Fill in your logic for binding the view.</div><div class="line">  &#125;</div><div class="line">  @Override</div><div class="line">  public int getItemCount() &#123;</div><div class="line">    if (items == null)&#123;</div><div class="line">      return 0;</div><div class="line">    &#125;</div><div class="line">    return items.size();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当你想要使用这个文件模板时，会提示你提供相关变量的值，比如<code>${VIEWHOLDER_CLASS}</code>和<code>${ITEM_CLASS}</code>,填写的值会自动替换对应的变量，非常的方便。</p>
<p>要使用已经定义好的File Template，只需要选中要创建位置的文件夹，然后点击鼠标右键，再点“New”，你就可以在列表中看到刚创建的File Template的名字<br><img src="http://www.bit100.com/.zhongzilu/image/Selecting-custom-template.png" alt="Selecting custom template"></p>
<p>点击RecyclerViewAdapter后填写相关变量的值<br><img src="http://www.bit100.com/.zhongzilu/image/FillInCustomTemplateVariables.png" alt="Fill In Custom Template Variables"></p>
<p>填写完后点击”OK”，之后你就可以看到自动生成的代码了<br><img src="http://www.bit100.com/.zhongzilu/image/GeneratedClassFromTemplate.png" alt="Generated Class From Template"></p>
<p>这样，今后我要实现一个RecyclerView的Adapter时，就不用再去写那么多代码了</p>
<p>如果你有一些比较好的代码模板，也可以分享给我哦 <em>^_^</em></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在Android Studio(IntelliJ)中创建Live Templates]]></title>
      <url>http://zhongzilu.github.io/2016/05/10/%E5%A6%82%E4%BD%95%E5%9C%A8Android-Studio-IntelliJ-%E4%B8%AD%E5%88%9B%E5%BB%BALive-Templates/</url>
      <content type="html"><![CDATA[<h2 id="如何在Android-Studio-IntelliJ中创建Live-Templates"><a href="#如何在Android-Studio-IntelliJ中创建Live-Templates" class="headerlink" title="如何在Android Studio/IntelliJ中创建Live Templates"></a>如何在Android Studio/IntelliJ中创建Live Templates</h2><p>标签： <code>Android Studio</code> <code>IntelliJ Live</code> <code>Template</code> </p>
<h3 id="何为Live-Templates"><a href="#何为Live-Templates" class="headerlink" title="何为Live Templates?"></a>何为Live Templates?</h3><blockquote>
<p>frequently-used or custom code constructs that you can insert into your source code file quickly, efficiently and accurately.<br>快速，高效，准确的将常用或自定义构造代码插入到你的源代码文件中</p>
</blockquote>
<p>通俗的讲，就是像快捷键一样，只需要输入几个简写的英文字母就可以快速自动插入一行或多行代码。</p>
<p>在Android Studio/IntelliJ编辑器中，默认使用<code>Ctrl + J</code>快捷键可以调出Live Templates，可以自动补全所设置的模板的代码，善用它能够很大程度上减少开发时间。</p>
<p>举个例子，输入<code>psfi</code>，然后按回车键，编辑器将会自动生成代码<code>public static final int</code>，这就节省了19个要输入的字母。</p>
<p>Android Studio/IntelliJ编辑器中预置了一些常用的Live Templates，大家可以自行去查看，查看位置<code>File ==&gt; Settings ==&gt; Editor ==&gt; Live Templates</code><br><img src="http://www.bit100.com/.zhongzilu/image/1462599293525.png" alt="Live Templates"></p>
<h3 id="如何创建自定义的Live-Templates？"><a href="#如何创建自定义的Live-Templates？" class="headerlink" title="如何创建自定义的Live Templates？"></a>如何创建自定义的Live Templates？</h3><ul>
<li>找到Live Templates的位置，然后点击右上角的<code>+</code>号，再选择<code>Template Group</code>，写上一个名称</li>
</ul>
<p><img src="http://www.bit100.com/.zhongzilu/image/1462602208553.png" alt="Template Group"><br><img src="http://www.bit100.com/.zhongzilu/image/1462602471454.png" alt="Custom Template Group"></p>
<ul>
<li>接着再点击<code>+</code>号，选择<code>Live Template</code>，之后填写相关的内容</li>
</ul>
<p><img src="http://www.bit100.com/.zhongzilu/image/1462602753037.png" alt=""></p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>我用一个快速插入RecyclerView控件代码的例子来举例，设置如下图：<br><img src="http://www.bit100.com/.zhongzilu/image/1462603188209.png" alt="RecyclerView Live Template"></p>
<p>填写相关内容完毕之后 ，注意下方的一行红字，此时定义的Live Template还没生效，需要点击<code>Define</code>，然后选择该Live Template要应用到什么样的场景中。因为这里我定义的是安卓的控件代码，所以就归类为XML</p>
<p><img src="http://www.bit100.com/.zhongzilu/image/1462604207098.png" alt="Define Live Template"></p>
<p>点击<code>OK</code>按钮生效。注意勾选右下角的<code>Reformat according to style</code>选项</p>
<p>要想使用刚才定义的Live Template，只需要在android的XML布局文件中输入rcv，然后按回车键就可以了，如下图所示：<br><img src="http://www.bit100.com/.zhongzilu/image/recyclerviewtemplate.gif" alt="Use Live Template"></p>
<p><strong>以上就是如何在Android Studio/IntelliJ编辑器中创建Live Template的方法，相信富有创意的各位能够创建出更多的更方便的Live Template，这对于今后的代码编写大有裨益</strong></p>
<p>另外，我在这里推荐一篇博客：<a href="http://blog.csdn.net/DesmondJ/article/details/47017205" target="_blank" rel="external">http://blog.csdn.net/DesmondJ/article/details/47017205</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Wordpress自定义栏目的使用]]></title>
      <url>http://zhongzilu.github.io/2016/05/10/Wordpress%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%8F%E7%9B%AE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="WordPress自定义栏目的使用"><a href="#WordPress自定义栏目的使用" class="headerlink" title="WordPress自定义栏目的使用"></a>WordPress自定义栏目的使用</h2><blockquote>
<p><strong>前言</strong></p>
<p>最近有个任务，要实现在公司官网上点击某个商品的购买按钮，就跳转到对应的淘宝店页面去。由于公司官网用的WordPress平台，我之前只是听说过，并没有实质性使用过，所以一开始就是一头雾水，再加上网站原本是由外包公司做的，交接时没有任何文档，因此我根本不知如何下手，但最后还是硬着头皮去做了。</p>
</blockquote>
<p>我思考着要完成这个任务我需要怎么做，由于网站上的内容都是动态从数据库中取的，所以如果我要实现点击购买按钮就跳转到对应网店的功能，就不可能在代码中把跳转的店铺地址写死了，必须要从数据库中去读取，并且还要和商品关联起来才行。</p>
<p>这其中肯定涉及到把链接地址写入数据库，WordPress提供了一个管理后台，通过管理后台可以把数据写入数据库。</p>
<p>打开后台，找到文章编辑页面，在右上方有个<code>显示选项</code>，展开后可以显示和隐藏模块。勾选<code>自定义栏目</code><br><img src="http://www.bit100.com/.zhongzilu/image/1460715829974.png" alt="显示选项"></p>
<p>在页面下方可以看到这个模块，在这里可以新增自定义的数据字段，并给它赋值。<br><img src="http://www.bit100.com/.zhongzilu/image/1460715932310.png" alt="自定义栏目"></p>
<p>拿我的任务来举例，我点击购买按钮之后跳转到对应的商品淘宝店，所以商品淘宝店的地址就需要写入数据库，所以现在新增一个自定义字段，点击<code>输入新栏目</code><br><img src="http://www.bit100.com/.zhongzilu/image/1460716205273.png" alt="添加自定义栏目"></p>
<p>输入自定义名称和值，输入完成后点击<code>添加自定义栏目</code><br><img src="http://www.bit100.com/.zhongzilu/image/1460716383075.png" alt="添加自定义栏目"></p>
<p>添加完之后就是如下图所示<br><img src="http://www.bit100.com/.zhongzilu/image/1460773373270.png" alt="添加自定义栏目成功"></p>
<p><strong>自定义栏目添加成功了，那么问题来了，我们如何取到自定义栏目的值并显示在页面上呢？</strong></p>
<p>在WordPress中有个<code>get_post_meta()</code>的函数，官方的解释是：</p>
<blockquote>
<p>This function returns the values of the custom fields with the specified key from the specified post.</p>
</blockquote>
<p>翻译过来大概的意思是：该函数用于取出用户设置的自定义字段的值。</p>
<p><strong>用途</strong></p>
<p>该函数的用处很多，很多主题用来设置文章相应图片的设置，这与将远程图像设置为缩略图有异曲同工之妙，当然自定义字段还可以用于存储许多我们觉得更有用的东西，例如统计信息，等等。</p>
<p><strong>用法</strong></p>
<blockquote>
<p><code>&lt;?php $meta_values = get_post_meta($post_id, $key, $single); ?&gt;</code></p>
</blockquote>
<p><strong>参数解释</strong></p>
<blockquote>
<p><code>$post_id</code>文章的ID（如果在循环中，你可以用 get_the_ID()来设置）,<br><code>$key</code>自定义字段的名称（键值）,<br><code>$single</code>是否以字符串形式返回，false会返回数组形式。</p>
</blockquote>
<p><strong>缺省用法</strong></p>
<blockquote>
<p><code>&lt;?php $value = get_post_meta(76, &#39;key&#39;); ?&gt;</code></p>
</blockquote>
<p><strong>实例</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (have_posts()) :<span class="comment">//如果有文章</span></div><div class="line"> <span class="keyword">while</span> (have_posts()) : the_post(); <span class="comment">//开启主循环</span></div><div class="line">   $value  = get_post_meta(get_the_ID(),<span class="string">'custom_meta'</span>,<span class="keyword">true</span>);</div><div class="line"> <span class="keyword">endwhile</span>; </div><div class="line"> <span class="keyword">endif</span>;</div></pre></td></tr></table></figure></p>
<p>上面介绍完<code>get_post_meta()</code>函数，现在我们就来实现我的这个任务。<br>在项目源代码中找到使用的主题的文件夹，我的文件夹位置为：<code>htdocs/wp-content/themes/jitatheme/</code><br>再找到<code>function.php</code>文件并打开，在这里我们将封装成一个获取地址的函数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*获取淘宝店铺商品的地址</div><div class="line">*/</div><div class="line">function getTB_Url($postID)&#123;</div><div class="line">  $key = &apos;direct_to_tb&apos;;</div><div class="line">  $url = get_post_meta($postID, $key, true);</div><div class="line">  return $url;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后找到我们要修改的页面，用一个<code>&lt;a&gt;</code>标签来实现点击跳转。我们在<code>&lt;a&gt;</code>标签的href属性中来调用刚才封装的函数，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a class=&quot;btn&quot; href=&quot;&lt;?php echo getTB_Url(get_the_ID()); ?&gt;&quot; target=&quot;_blank&quot;&gt;点击购买&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<p>最后在页面上点击测试一下，跳转正确，任务完毕。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ul>
<li>了解了如何在WordPress后台管理界面添加自定义栏目</li>
<li>了解了如何获取自定义栏目的值和<code>get_post_meta()</code>函数的使用</li>
</ul>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[MVC&MVP模式有何不同]]></title>
      <url>http://zhongzilu.github.io/2016/05/10/MVC-MVP%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/</url>
      <content type="html"><![CDATA[<h1 id="MVC-amp-MVP模式有何不同"><a href="#MVC-amp-MVP模式有何不同" class="headerlink" title="MVC &amp; MVP模式有何不同"></a>MVC &amp; MVP模式有何不同</h1><p>标签 :  MVP MVC</p>
<hr>
<p><strong>本文是翻译国外的一篇文章,英语水平有限,翻译有误的地方希望提出来,以方便修改,谢谢</strong></p>
<blockquote>
<p>原文传送门: <a href="http://www.infragistics.com/community/blogs/todd_snyder/archive/2007/10/17/mvc-or-mvp-pattern-whats-the-difference.aspx" target="_blank" rel="external">http://www.infragistics.com/community/blogs/todd_snyder/archive/2007/10/17/mvc-or-mvp-pattern-whats-the-difference.aspx</a></p>
</blockquote>
<hr>
<blockquote>
<p>Over the years I have mentored many developers on using design patterns and best practices.<br>多年来我有辅导过很多开发者使用设计模式和最佳实践</p>
<p>One question that keeps coming up over and over again is:What are the differences between the Model View Controller (MVC) and Model View Presenter (MVP) patterns?<br>一遍又一遍出现的一个问题是: 模型 视图 控制器(MVC模式)和模型 视图 主持人(MVP模式)之间有哪些不同?</p>
<p>Surprisingly the answer is more complex than what you would suspect.<br>令人惊讶的是答案比你想象中的更复杂</p>
<p>Part of reasons I think many developers shy away from using either pattern is the confusion over the differences.<br>我认为一部分原因是因为许多开发者回避使用两种模式带来的混乱</p>
<p>Before we dig into the differences let’s examine how the patterns work and the key benefits to using either one.<br>在我们深入研究两种模式如何工作和使用其中一种带来的关键利益之前</p>
<p>Both (MVC &amp; MVP) patterns have been use for several years and address a key OO principal namely separation of concerns between the UI and the business layers.<br>这两种模式(MVC &amp; MVP)已经使用了好几年,并且处理面向对象的关键就是分离界面UI层和业务层.</p>
<p>There are a number of frameworks is use today that based on these patterns including: JAVA Struts, ROR, Microsoft Smart Client Software Factory (CAB), Microsoft Web Client Software Factory, and the recently announced ASP.Net MVC framework.<br>这里有一些如今正在被使用的,基于这些模式的框架,包括:Java Struts, ROR, Microsoft Smart Client Software Factory (CAB), Microsoft Web Client Software Factory,还有最近发布的ASP.Net MVC框架</p>
<p><strong>Model View Controller (MVC) Pattern</strong><br><img src="http://www.bit100.com/.zhongzilu/image/MVC_View.jpg" alt="MVC"></p>
<p>The MVC pattern is a UI presentation pattern that focuses on separating the UI (View) from its business layer (Model).<br>MVC模式是一个着重于从业务层(Model)分离UI(View)的UI表示模型</p>
<p>The pattern separates responsibilities across three components: the view is responsible for rending UI elements, the controller is responsible for responding to UI actions, and the model is responsible for business behaviors and state management.<br>模型分离的重任横跨三个组件: 视图层负责渲染UI元素, 控制器负责响应UI操作, 模型层负责业务逻辑和状态管理.</p>
<p>In most implementation all three components can directly interact with each other and in some implementations the controller is responsible for determining which view to display (<a href="https://msdn.microsoft.com/en-us/library/ms978723.aspx" target="_blank" rel="external">Front Controller Pattern</a>),<br>多数的实现方法，可以使这三个组件互相直接作用影响，有一些实现的方法里，控制器负责确定哪些试图的显示（<a href="https://msdn.microsoft.com/en-us/library/ms978723.aspx" target="_blank" rel="external">Front Controller Pattern</a>)</p>
<p><strong>Model View Presenter (MVP) Pattern</strong><br><img src="http://www.bit100.com/.zhongzilu/image/MVP_View.jpg" alt="MVP"></p>
<p>The MVP pattern is a UI presentation pattern based on the concepts of the MVC pattern.<br>MVP模型是基于MVC模型的UI表示模型。</p>
<p>The pattern separates responsibilities across four components: the view is responsible for rending UI elements, the view interface is used to loosely couple the presenter from its view, the presenter is responsible for interacting between the view/model, and the model is responsible for business behaviors and state management.<br>模型分离的重任横跨四个组件:视图层负责渲染UI元素， 视图层接口被用于把中介者（Presenter)从视图中解耦，中介者负责视图（View)和模型(Model)之间的交互,模型层负责业务逻辑和状态管理.</p>
<p>In some implementations the presenter interacts with a service (controller) layer to retrieve/persist the model.<br>在某些实现方法中，中介者会和服务层/控制器层交互来获取或持有model。</p>
<p>The view interface and service layer are commonly used to make writing unit tests for the presenter and the model easier.<br>视图接口和服务层通常被用来编写中介者和模型之间的单元测试。</p>
</blockquote>
<h2 id="关键优势"><a href="#关键优势" class="headerlink" title="关键优势"></a>关键优势</h2><blockquote>
<p>Before using any pattern a developers needs to consider the pros and cons of using it.<br>在使用任何开发模式之前，开发人员需要考虑使用它的优点和缺点。</p>
<p>There are a number of key benefits to using either the MVC or MVP pattern (See list below).<br>这里有一些使用MVC和MVP模型的关键好处（请看下面的列表）。</p>
<p>But, there also a few drawbacks to consider. The biggest drawbacks are additional complexity and learning curve.<br>但是，这里也有一些缺点需要考虑。最大的缺点就是它的复杂性和需要付出额外的学习成本。</p>
<p>While the patterns may not be appropriate for simple solutions; advance solutions can greatly benefit from using the pattern.<br>这种模型可能不太适合一般的解决方案；好的解决方案可以从中获得更大的利益。</p>
<p>I’m my experience a have seen a few solutions eliminate a large amount of complexity but being re-factored to use either pattern.<br>在我的经历中，我见过使用这些模式来重构项目，解决了不少的复杂的问题。</p>
<ul>
<li><p>Loose coupling – The presenter/controller are an intermediary between the UI code and the model. This allows the view and the model to evolve independently of each other.<br>松散耦合 - presenter或控制器在UI代码和模型之间充当着中间媒介的角色，这就使得视图和控制器之间互相独立。</p>
</li>
<li><p>Clear separation of concerns/responsibility<br>清晰分离关注点和职责（关于concerns的翻译请自行有道）<br>– UI (Form or Page) – Responsible for rending UI elements<br>UI(表单或页面） - 负责渲染UI元素<br> – Presenter/controller – Responsible for reacting to UI events and interacts with the model<br>中介者/控制器 - 负责对UI事件与模型进行交互<br> – Model – Responsible for business behaviors and state management<br>模型 - 负责业务逻辑和状态管理.</p>
</li>
<li><p>Test Driven – By isolating each major component (UI, Presenter/controller, and model) it is easier to write unit tests. This is especially true when using the MVP pattern which only interacts with the view using an interface.<br>测试驱动 - 通过分离每个主要组件（UI,Presenter/controller, model)更容易编写单元测试，当使用MVP模型且只通过接口来和视图层交互时，就更应该这样做。</p>
</li>
<li><p>Code Reuse – By using a separation of concerns/responsible design approach you will increase code reuse. This is especially true when using a full blown domain model and keeping all the business/state management logic where it belongs.<br>代码复用 - 通过使用分离关注点和职责的设计可以增加你的代码复用。在使用全面的域模型和保持所属业务和状态管理的逻辑时，就更应该这样做。</p>
</li>
<li><p>Hide Data Access – Using these patterns forces you to put the data access code where it belongs in a data access layer. There a number of other patterns that typical works with the MVP/MVC pattern for data access. Two of the most common ones are repository and unit of work. (See Martin Fowler – Patterns of Enterprise Application Architecture for more details)<br>隐藏数据访问 - 使用这种模式会强迫你使用数据接入层中的数据接入代码。这里有一些其他典型的使用MVP/MVC模型来进行数据访问的模型，最常见的两个就是库和工作单元。（想看更多细节请看Martin Fowler的企业应用架构模式【Martin Fowler - Patterns of Enterprise Application Architecture】)</p>
</li>
<li><p>Flexibility/Adaptable – By isolating most of your code into the presenter/controller and model components your code base is more adaptable to change. For example consider how much UI and data access technologies have changed over the years and the number of choices we have available today. A properly design solution using MVC or MVP can support multi UI and data access technologies at the same time.<br>灵活/适用 - 通过分离Presenter/controller和model组件可以使你的代码更灵活适用.举个例子,这些年来有许多UI技术和数据接入技术都有所改变,如今我们有许多的选择.恰当的使用MVC或者MVP模式来设计解决方案,可以同时支持多种UI技术和数据接入技术.</p>
</li>
</ul>
</blockquote>
<h2 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h2><blockquote>
<p>So what really are the differences between the MVC and MVP pattern.<br>Actually there are not a whole lot of differences between them.<br>因此,MVC和MVP模式之间真正的区别.其实是没有太多区别.</p>
<p>Both patterns focus on separating responsibility across multi components and promote loosely coupling the UI (View) from the business layer (Model).<br>这两者都是专注跨组件分离职责,促进UI层从业务层中解耦.</p>
<p>The major differences are how the pattern is implemented and in some advanced scenarios you need both presenters and controllers.<br>主要的区别在于如何实现,在某些高级的应用场景中需要同时有Presenter和Controler</p>
<p>Here are the key differences between the patterns:<br>这里有些这两种模式之间的关键区别:</p>
<ul>
<li><p>MVP模式<br>– View is more loosely coupled to the model. The presenter is responsible for binding the model to the view.<br>视图和模型之间耦合更加松散.中介者负责把model绑定到视图层.<br>– Easier to unit test because interaction with the view is through an interface<br>更加容易编写单元测试,因为都是通过接口和视图交互的.<br>– Usually view to presenter map one to one. Complex views may have multi presenters.<br>通常情况下,视图和中介者是一一对应的.复杂的视图可能会有多个中介者.</p>
</li>
<li><p>MVC模式<br>– Controller are based on behaviors and can be shared across views<br>控制器是建立在行为上的,并且可以跨视图共享<br>– Can be responsible for determining which view to display<br>能够负责决定要显示哪个视图</p>
</li>
</ul>
<p>Hopefully you found this post interesting and it helped clarify the differences between the MVC and MVP pattern.<br>希望你会觉得这篇文章是有趣的,这篇文章会帮助你理清MVC和MVP模式之间的区别.</p>
<p>If not, do not be discouraged patterns are powerful tools that can be hard to use sometimes.<br>如果没理清,请不要泄气,模型是一个强大的工具,以至于有时在使用时会觉得很困难</p>
<p>One thing to remember is that a pattern is a blue print and not an out of the box solutions.<br>你只需要记住,模型只是一个蓝图,并不是快速的解决方案.</p>
<p>Developers should use them as a guide and modify the implementation according to their problem domain.<br>开发者应该把它们作为指导手册,并根据遇到的问题修正实现方案.</p>
</blockquote>
<hr>
<blockquote>
<p><strong>作者</strong> :<a href="http://www.bit100.com" target="_blank" rel="external">zhongzilu</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Android开发之MVP初体验]]></title>
      <url>http://zhongzilu.github.io/2016/05/10/Android%E5%BC%80%E5%8F%91%E4%B9%8BMVP%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="Android开发-MVP之初体验"><a href="#Android开发-MVP之初体验" class="headerlink" title="Android开发 MVP之初体验"></a>Android开发 MVP之初体验</h1><p>标签 ：Android MVP MVC</p>
<hr>
<p>熟悉安卓开发的童鞋应该都熟悉MVC架构模式, MVC开发模式即:</p>
<blockquote>
<p>Model(模型) – View(视图) – Control(控制器)</p>
</blockquote>
<p>逻辑图如下:<br><img src="http://www.bit100.com/.zhongzilu/image/MVC.png" alt="MVC"></p>
<p>而这种开发模式有个缺点,就是在项目越来越大时,文件会越来越多,查找起来很不方便,而且Activity或者Fragment里面的代码会越来越臃肿,看起来很凌乱,要修改更是让人头疼,于是就提出了一种MVP的开发模式,MVP开发模式即:</p>
<blockquote>
<p>Model(模型) – View(视图) – Presente(任命者/中介)</p>
</blockquote>
<p>逻辑图如下:<br><img src="http://www.bit100.com/.zhongzilu/image/mvp.png" alt="MVP"></p>
<p>网上有很多讲解MVP的文章和教程,我这里就不详细介绍了,但还有很多人看过教程之后依然不知如何实现MVP,今天主要通过实际代码的方式来体验MVP开发</p>
<p>本次使用的代码为Github上的一个开源项目,名为<a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="external">androidmvp</a></p>
<blockquote>
<p>传送门 <a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="external">https://github.com/antoniolg/androidmvp</a></p>
</blockquote>
<h2 id="先看看界面"><a href="#先看看界面" class="headerlink" title="先看看界面"></a>先看看界面</h2><p>界面很简单,就是一个登录界面和一个ListView填充的主界面,登录之后跳转到主界面,主界面上显示一个列表<br><img src="http://www.bit100.com/.zhongzilu/image/loginScreenShot.png" alt="登录界面"><img src="http://www.bit100.com/.zhongzilu/image/mainScreenShot.png" alt="主界面"></p>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>用Android Studio打开项目之后可以看到如下的项目结构<br><img src="http://www.bit100.com/.zhongzilu/image/structure.png" alt="项目结构"></p>
<p>通过截图可以看出,该项目是根据<strong>界面来分类的</strong>,Login文件夹下放的是所有与登录界面有关的文件,main文件夹下放的是所有与主界面有关的文件</p>
<p>其中, Login文件夹下共有6个文件, 3个类文件, 3个接口文件</p>
<p>类文件:</p>
<blockquote>
<ul>
<li>LoginActivity</li>
<li>LoginInteratorImpl</li>
<li>LoginPresenterImpl</li>
</ul>
</blockquote>
<p>接口文件:</p>
<blockquote>
<ul>
<li>LoginView</li>
<li>LoginInteractor</li>
<li>LoginPresenter</li>
</ul>
</blockquote>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>打开<strong>LoginActivity.java</strong>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class LoginActivity extends Activity implements LoginView, View.OnClickListener &#123;</div><div class="line"></div><div class="line">    private ProgressBar progressBar;</div><div class="line">    private EditText username;</div><div class="line">    private EditText password;</div><div class="line">    private LoginPresenter presenter;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_login);</div><div class="line"></div><div class="line">        //实例化控件</div><div class="line">        ...</div><div class="line"></div><div class="line">        presenter = new LoginPresenterImpl(this);</div><div class="line">    &#125;</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>从上面代码可以看出,该Activity实现了LoginView的接口和View的点击事件, 并且实例化了一个LoginPresenterImpl对象</p>
<p>现在打开<strong>LoginView.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface LoginView &#123;</div><div class="line">    void showProgress();</div><div class="line"></div><div class="line">    void hideProgress();</div><div class="line"></div><div class="line">    void setUsernameError();</div><div class="line"></div><div class="line">    void setPasswordError();</div><div class="line"></div><div class="line">    void navigateToHome();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到LoginView文件中定义了几个接口, 通过名称可以很容易知道每个接口是用来干什么的<br>返回LoginActivity也很容易发现是如何实现这几个接口的,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showProgress</span><span class="params">()</span> </span>&#123;</div><div class="line">    progressBar.setVisibility(View.VISIBLE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hideProgress</span><span class="params">()</span> </span>&#123;</div><div class="line">    progressBar.setVisibility(View.GONE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsernameError</span><span class="params">()</span> </span>&#123;</div><div class="line">    username.setError(getString(R.string.username_error));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPasswordError</span><span class="params">()</span> </span>&#123;</div><div class="line">    password.setError(getString(R.string.password_error));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">navigateToHome</span><span class="params">()</span> </span>&#123;</div><div class="line">    startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainActivity.class));</div><div class="line">    finish();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打开<strong>LoginPresenter.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginPresenter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">validateCredentials</span><span class="params">(String username, String password)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到定义了两个接口,其中validateCredentials接口是用来验证用户名和密码是否通过验证的<br>在LoginActivity中也有实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override public void onClick(View v) &#123;</div><div class="line">    presenter.validateCredentials(username.getText().toString(), </div><div class="line">        password.getText().toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>看到这里, 我们可以总结出LoginActivity没有做任何逻辑相关的事情,而是在做界面显示相关和界面跳转的事情, 就连验证帐号的逻辑都是交给LoginPresenterImpl类的</strong></p>
<p>那么现在顺藤摸瓜,打开LoginPresenterImpl.java文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class LoginPresenterImpl implements LoginPresenter, </div><div class="line">        LoginInteractor.OnLoginFinishedListener &#123;</div><div class="line"></div><div class="line">    private LoginView loginView;</div><div class="line">    private LoginInteractor loginInteractor;</div><div class="line"></div><div class="line">    public LoginPresenterImpl(LoginView loginView) &#123;</div><div class="line">        this.loginView = loginView;</div><div class="line">        this.loginInteractor = new LoginInteractorImpl();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //其他方法的实现</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到该类实现了LoginPresenter和LoginInteractor.OnLoginFinishedListener的接口,  并且在构造方法的参数为LoginView, 那么问题来了, <strong>为什么要传递LoginView类型的参数呢?</strong></p>
<p>我们刚才也看到了,在LoginView中定义了几个接口, 而在LoginActivity中有对这几个接口的实现, 所以传递这个参数, 是有利于LoginPresenterImpl类调用LoginActivity的实现方法, 用于界面上的显示, 这就达到了逻辑代码和显示代码的分离</p>
<p>好了,现在来看看是怎么实现LoginPresenter中的validateCredentials接口的吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override public void validateCredentials(String username, String password) &#123;</div><div class="line"></div><div class="line">    if (loginView != null) &#123;</div><div class="line">        loginView.showProgress();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    loginInteractor.login(username, password, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到这里,有同学该有疑问了,<strong>为什么在这个方法里我没看到实现帐号验证的具体逻辑呢?</strong></p>
<p>没错,这里不应该有帐号验证的具体逻辑代码,因为LoginPresenterImpl类充当的是任命者或者称中介者的身份, 中介者只负责联系<strong>界面类</strong>和<strong>具体实现逻辑代码的类</strong>,如果还不能理解,就想想房地产中介吧, 他们只负责联系买房者和卖房者, 其他的事都不管(抱歉, 我没有鄙视或看不起房地产中介人员的意思, 这里只是做个举例, 在此说声对不起).</p>
<p>我们看到代码中, 把接收到的username和password参数传递给了一个login方法, 该方法在LoginInteractor文件中, 我们再打开<strong>LoginInteractor.java</strong>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface LoginInteractor &#123;</div><div class="line"></div><div class="line">    interface OnLoginFinishedListener &#123;</div><div class="line">        void onUsernameError();</div><div class="line"></div><div class="line">        void onPasswordError();</div><div class="line"></div><div class="line">        void onSuccess();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void login(String username, String password, OnLoginFinishedListener listener);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以定义了一个login接口和一个OnLoginFinishedListener接口类, 返回LoginPresenterImpl.java文件可以很容易看到OnLoginFinishedListener接口类中接口的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override public void onUsernameError() &#123;</div><div class="line">    if (loginView != null) &#123;</div><div class="line">        loginView.setUsernameError();</div><div class="line">        loginView.hideProgress();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override public void onPasswordError() &#123;</div><div class="line">    if (loginView != null) &#123;</div><div class="line">        loginView.setPasswordError();</div><div class="line">        loginView.hideProgress();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override public void onSuccess() &#123;</div><div class="line">    if (loginView != null) &#123;</div><div class="line">        loginView.navigateToHome();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这些接口的实现中同样只是调用LoginView中的接口,并没有具体的逻辑操作代码</p>
<p>在该类的构造方法中我们会发现, 这里实例化了一个<strong>LoginInteractorImpl</strong>对象, 我们现在打开LoginInteractorImpl.java文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class LoginInteractorImpl implements LoginInteractor &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void login(final String username, final String password, final OnLoginFinishedListener listener) &#123;</div><div class="line">    </div><div class="line">        // Mock login. I&apos;m creating a handler to delay the answer a couple of seconds</div><div class="line">        new Handler().postDelayed(new Runnable() &#123;</div><div class="line">        </div><div class="line">            @Override public void run() &#123;</div><div class="line">            </div><div class="line">                boolean error = false;</div><div class="line">                if (TextUtils.isEmpty(username))&#123;</div><div class="line">                    listener.onUsernameError();</div><div class="line">                    error = true;</div><div class="line">                &#125;</div><div class="line">                if (TextUtils.isEmpty(password))&#123;</div><div class="line">                    listener.onPasswordError();</div><div class="line">                    error = true;</div><div class="line">                &#125;</div><div class="line">                if (!error)&#123;</div><div class="line">                    listener.onSuccess();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, 2000);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到该类实现了LoginInteractor中的login接口, 并且在login方法中进行了具体的逻辑处理, 如果验证通过, 调用onSuccess接口</p>
<p><strong>好了,整个登录流程讲完了,最后我们再来梳理一下整个流程:</strong></p>
<blockquote>
<ol>
<li>在LoginActivity中,通过LoginPresenter接口类中的validateCredentials接口,把username和password传递给LoginPresenter的实现类LoginPresenterImpl</li>
<li>LoginPresenterImpl类再通过LoginInteractor接口类中的login接口, 把username和password传递给LoginInteractor的实现类LoginInteractorImpl</li>
<li>在LoginInteractorImpl类中进行具体的逻辑处理, 如果验证通过,则调用LoginInteractor.OnLoginFinishedListener接口类中的onSuccess接口, 即调用了LoginPresenterImpl类中实现的onSuccess接口</li>
<li>LoginPresenterImpl类中实现的onSuccess接口中,调用了LoginView接口类中的navigateToHome接口,即调用了LoginActivity类中实现的navigateToHome接口</li>
<li>最后在navigateToHome接口中实现Activity的跳转,跳转到MainActivity</li>
</ol>
</blockquote>
<p><strong>流程图如下:</strong><br><img src="http://www.bit100.com/.zhongzilu/image/flow_chart.png" alt="Alt text"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在MVP开发模式中, Activity只负责界面的显示和跳转相关的操作, 具体的逻辑处理通过调用接口来传递给Presenter(中介者) 既不做界面显示的操作,也不做具体的逻辑处理操作, 具体的逻辑处理通过调用接口,让Interactor即交互类来完成</p>
<p>交互类的逻辑处理结果,通过调用Presenter中实现的接口, 再由Presenter要实现的接口中调用Activity中实现的接口来进行UI的显示或界面跳转</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>好了,<code>安卓开发 MVP之初体验</code>讲完了,写了那么多,希望大家能够看懂了,如果还有什么问题,可以问我<a href="http://ask.android-studio.org/?/people/zhongzilu" target="_blank" rel="external">Follow Me</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[【微表情心理学】耳朵的秘密]]></title>
      <url>http://zhongzilu.github.io/2016/05/10/%E3%80%90%E5%BE%AE%E8%A1%A8%E6%83%85%E5%BF%83%E7%90%86%E5%AD%A6%E3%80%91%E8%80%B3%E6%9C%B5%E7%9A%84%E7%A7%98%E5%AF%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>如果你仔细观察我们的耳朵，你会发现耳朵就像一个倒置的胎儿。他的头部朝下，臀部朝上。耳朵可以被看做事他人体的缩小版</p>
</blockquote>
<h3 id="耳朵大小某种程度上体现一个人的生命力和思想深度"><a href="#耳朵大小某种程度上体现一个人的生命力和思想深度" class="headerlink" title="耳朵大小某种程度上体现一个人的生命力和思想深度"></a>耳朵大小某种程度上体现一个人的生命力和思想深度</h3><p>通常来说，一个人的耳朵越大，他就越充满激情和活力，他多半精力旺盛，但也很容易脾气暴躁，比如美国前总统比尔·克林顿。耳朵中等大小的人，多半思想冷静、理性而客观，比如法国影星苏菲·玛索。而小耳朵的人，多半具有很强的观察力，而且适应能力很强，对待事情也比较有耐心</p>
<h3 id="耳朵反映一个人的性格特征"><a href="#耳朵反映一个人的性格特征" class="headerlink" title="耳朵反映一个人的性格特征"></a>耳朵反映一个人的性格特征</h3><p>大耳朵的人多半活力四射，行动力和执行力比较强，有个性，有思想</p>
<p>耳朵外形美观的人，内心相对平静，富有想象力，具有坚持不懈的品质和乐于竞争的精神</p>
<p>耳轮在起始处粗壮，而在走向中间的部位是剧烈变细的人多半比较顽固，敏感，情绪不稳定，容易消沉</p>
<p>耳朵外形粗糙，粗笨或过宽，过厚，此人往往比较麻木缺乏感情，思维不受控制，甚至有时还很野蛮，具有强烈的攻击性</p>
<p>中等大小的耳朵为正常耳朵，虽不具备丰富想象力和热情，但感情稳定，不易出现波动，而且做事更加理性，逻辑性思维很强，做事前喜欢深思熟虑，权衡再三，与人交往时不会无理争辩，而是做出让人信服的言论。总之此类人为人处世相对稳重，并且善于处理工作和生活之间的关系</p>
<p>小耳朵通常缺乏强烈的野心，自信心，想象力和创造性，但他们多半反应迅速，身体灵敏，并且具有极强的专注力和观察力。性情上，一般较为敏感，更容易闷闷不乐，郁郁寡欢，也常陷入悲观局面。但他们行事严谨，很少出现差错，往往也会取得令人骄傲的成绩</p>
<h3 id="扯耳朵或摸耳垂"><a href="#扯耳朵或摸耳垂" class="headerlink" title="扯耳朵或摸耳垂"></a>扯耳朵或摸耳垂</h3><p>在谈话中，很多人习惯做出扯耳朵或者摸耳垂的动作，通常这种动作表示他们试图打断对方说话。</p>
<p>摸耳垂的动作是一种自我触摸，自我安慰的行为。通常当人们对谈话内容不感兴趣而产生乏味，无趣的情绪甚至对内容反感时会出现此举动。一方面是想要打断对方的潜意识，另一方面是借此来安抚自己消除内心的浮躁和不安。</p>
<p>当人们紧张、内心焦虑不安、说谎、表示反对意见时也会有此举动</p>
<h3 id="咬嘴唇或隐藏嘴唇"><a href="#咬嘴唇或隐藏嘴唇" class="headerlink" title="咬嘴唇或隐藏嘴唇"></a>咬嘴唇或隐藏嘴唇</h3><p>出现此举通常是由于出现某种压力或紧张情绪。这是一种消极情绪</p>
<p>突然收拢嘴唇或嘟起嘴，如果在谈话时出现此举动，通常说明此人对所讲话的内容在心理上出现了反对意见或是不完全认可的态度，此时他正在思考怎么样转换正在谈论的话题或者是准备提出自己的不同意见</p>
<blockquote>
<p>作者：zhongzilu</p>
</blockquote>
]]></content>
      
        
    </entry>
    
  
  
</search>
